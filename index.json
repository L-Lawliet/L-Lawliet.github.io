[{"title":"About","date":"","description":"希望这里的教程能给大家提供灵感","body":"Unity 游戏开发\u0026hellip;\n这里主要是想把自己日常开发所遇到的问题、感悟的见解全写出来，为大家提供一些思路和灵感。\n","ref":"/about/"},{"title":"Fantasy Factor","date":"","description":"Unity Tools by Fantasy Factor","body":"email: 2771918131@qq.com\n Fantasy Factor      Fantasy Factor   UnityCompare      UCompare   A tool for comparing Unity3D Prefabs, quickly comparing differences, copying components, copying properties, etc. The principle is based on the comparison of the subtrees of two Prefabs in sequence (by name), and then the differences are displayed in a tree structure. Then, by clicking in, you can see the differences in the Components of the two sub-GameObjects. After selecting a specific GameObject or Component, you can see the comparison based on SerializedObject and SerializedProperty, and then you can perform editing operations.\n Feature List  Compare Prefab Differences Visualize Results Filterable Results Customizable Ignored Properties Quick Copy of GameObject Quick Copy of Component Quick Comparison Menu Synchronized Tree List Component Display Consistent with Unity  ","ref":"/fantasyfactor/"},{"title":"xlua Delegate 泄漏检查","date":"","description":"xlua Delegate 泄漏检查","body":"排查和定位xLua中Delegate没有销毁的情况\n前言  笔者在开发项目时，发现在xLua Dispose时总是会有DelegateBridge没有移除的情况，这有很多原因导致的，其中除了有之前讨论过的《UnityEvent引起的内存泄漏》，也不乏一些日常写业务逻辑疏忽导致的。但无论哪种情况，在销毁xLua虚拟机前调用多次GC释放，而仍然存在的DelegateBridge就代表原来Lua逻辑有未正常销毁的情况，这体现其背后可能存在内存泄漏等问题，而本篇文章就是研究如何去找到没有释放所引用的Lua代码位置。\n InvalidOperationException: try to dispose a LuaEnv with C# callback! 源码方案  xLua在虚拟机销毁前，会先调用多次GC，然后再释放ObjectTranslator的对象。\n //调用多次GC是为了让Lua和C#之间没有引用关系的对象得以释放。 public void Dispose() { FullGc(); System.GC.Collect(); System.GC.WaitForPendingFinalizers(); Dispose(true); System.GC.Collect(); System.GC.WaitForPendingFinalizers(); }  而在Dispose ObjectTranslator时，会释放掉所有的DelegateBridge。在释放每一个DelegateBridge都会先确认是否存活（IsAlive），如果有一个则会抛出异常。\n if (!translator.AllDelegateBridgeReleased()) { throw new InvalidOperationException(\u0026quot;try to dispose a LuaEnv with C# callback!\u0026quot;); }  由于信息有限，所以并不知道是哪个对象哪句代码所注册Delegate，因此需要扩展对应的检查。\n 输出Delegate信息  首先较为简单的方案就是把没有释放的Delegate信息输出出来，其中包括Method的名称、类型等。\n //Class DelegateBridgeBase public string GetMessage() { StringBuilder builder = new StringBuilder(); if(bindTo != null) { foreach (var item in bindTo) { if (item.Value != null) { builder.AppendFormat(\u0026#34;key:{0} methodName:{1} FullyQualifiedName:{2}\\n\u0026#34;, item.Key, item.Value.Method.Name, item.Value.Method.DeclaringType.Name); } } } else if(firstValue != null) { builder.AppendFormat(\u0026#34;key:{0} methodName:{1} FullyQualifiedName:{2}\\n\u0026#34;, firstKey, firstValue.Method.Name, firstValue.Method.DeclaringType.Name); } return builder.ToString(); } //Class ObjectTranslator public bool AllDelegateBridgeReleased(IntPtr L, ref string message) { StringBuilder builder = new StringBuilder(); bool result = true; foreach (var kv in delegate_bridges) { if (kv.Value.IsAlive) { builder.AppendLine(delegateBridgeBase.GetInfo()); } } message = builder.ToString(); return result; }  这样就可以获取到所有没有释放的Delegate信息了。\n debug.traceback  虽然获取Delegate信息能找到一些蛛丝马迹，但其实还远远不够，因为相同类型的Delegate实在太多了，而且如果是反射Warp的方式，类似methodName:__Gen_Delegate_Imp7 FullyQualifiedName:XLuaGenDelegateImpl0的信息一点用都没有。这时候就需要增加其他方法来获取更精确的信息了，例如获取Lua堆栈信息。\n  lua有一个debug.traceback()的API是可以获取到当前Lua逻辑中的堆栈信息的。\n //在C#端增加以下逻辑 private string GetStack(RealStatePtr L) { var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;traceback\u0026#34;); LuaAPI.xlua_pgettable(L, -2); var index = LuaAPI.lua_pcall(L, 0, 1, 0); string luaStack = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStack; }  尝试在ObjectTranslator.CreateDelegateBridge()调用，输出日志：\n stack traceback: [C]:in local 'loadFun' Script/B:12: in field'Fun2' Script/A:32: in field'Fun1' ......  这样就可以在创建DelegateBridge时获取到调用的Lua代码堆栈，然后保存起来，等销毁时把没有释放的堆栈信息输出。\n //将原来的CreateDelegateBridge方法改成私有，把weakReference作为out结果返回。 private object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx, out WeakReference weakReference) { ... } //增加新的CreateDelegateBridge提供给外部调用 public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx) { WeakReference weakReference = null; var stack = this.GetStack(L); var result = CreateDelegateBridge(L, delegateType, idx, out weakReference); if(weakReference != null) { int hash = weakReference.GetHashCode(); //利用weakReference的哈希值来作为key  bridgesReferenceInfos[hash] = stack; } return result; }  AllDelegateBridgeReleased和ReleaseLuaBase也需要根据weakReference.GetHashCode()处理（获取信息和释放），这里就不再赘述了。\n debug.getinfo  其实使用traceback已经能完美解决问题了，为什么还有下文呢？这是因为笔者在接入到项目后，发现项目变的很卡，特别是在创建模块（场景、界面）时。在一轮抽丝剥茧后，发现了debug.traceback是一个性能消耗巨大的API，在Editor下十次调用就有100ms，这即使在Editor下也是不可接受的。\n  所以在一轮查找后，笔者找到了debug.getinfo的方法来实现功能。\n -- 获取当前调用层级所在的lua文件路径 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).source -- 获取当前调用层级（代码堆栈）所在的行号 -- 1就是第一层 debug.getinfo(1, \u0026#34;l\u0026#34;).currentline  在C#侧增加了接口，替代了原来的GetStack()。\n private string GetInfo(RealStatePtr L, int maxLevel = 5) { luaStackBuffer.Clear(); var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;getinfo\u0026#34;); LuaAPI.xlua_pgettable(L, -2); for (int i = 0; i \u0026lt; maxLevel; i++) { LuaAPI.lua_pushvalue(L, -1); int level = i + 2; //1为C端，没必要输出  LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;S\u0026#34;); //参数  LuaAPI.lua_pcall(L, 2, 1, 0); if (LuaAPI.lua_isnil(L, -1)) //当前节点是nil，表明没有上一层  { LuaAPI.lua_pop(L, 1); break; } LuaAPI.xlua_pushasciistring(L, \u0026#34;source\u0026#34;); LuaAPI.xlua_pgettable(L, -2); string luaPath = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 2); LuaAPI.lua_pushvalue(L, -1); LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;l\u0026#34;); //参数  LuaAPI.lua_pcall(L, 2, 1, 0); LuaAPI.xlua_pushasciistring(L, \u0026#34;currentline\u0026#34;); LuaAPI.xlua_pgettable(L, -2); int line = LuaAPI.xlua_tointeger(L, -1); luaStackBuffer.AppendFormat(\u0026#34;{0}: {1}\\n\u0026#34;, luaPath, line); LuaAPI.lua_pop(L, 2); } LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStackBuffer.ToString(); } @Script/B: 12 @Script/A: 32  测试了一下性能，比traceback好一点，但也有80ms/10次。这也是万万不可接受的。 所以调试了其他方案，最后可以使用linedefined来替代currentline。linedefined与currentline不一样的地方就是，只能获取到当前function开始所在的行号，而不能获得代码精确的行号。\n -- 获取当前调用层级所在的lua文件路径 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).source -- 获取当前调用层级调用函数所在的行号 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).linedefined  修改原来的GetInfo()。\n private string GetInfo(RealStatePtr L, int maxLevel = 5) { luaStackBuffer.Clear(); var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;getinfo\u0026#34;); LuaAPI.xlua_pgettable(L, -2); for (int i = 0; i \u0026lt; maxLevel; i++) { LuaAPI.lua_pushvalue(L, -1); int level = i + 2; //1为C端，没必要输出  LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;S\u0026#34;); //参数  var index = LuaAPI.lua_pcall(L, 2, 1, 0); if(LuaAPI.lua_isnil(L, -1)) //当前节点是nil，表明没有上一层  { LuaAPI.lua_pop(L, 1); break; } LuaAPI.xlua_pushasciistring(L, \u0026#34;source\u0026#34;); LuaAPI.xlua_pgettable(L, -2); string luaPath = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 1); LuaAPI.xlua_pushasciistring(L, \u0026#34;linedefined\u0026#34;); LuaAPI.xlua_pgettable(L, -2); int line = LuaAPI.xlua_tointeger(L, -1); luaStackBuffer.AppendFormat(\u0026#34;{0}: {1}\\n\u0026#34;, luaPath, line); LuaAPI.lua_pop(L, 2); } LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStackBuffer.ToString(); } @Script/B: 5 @Script/A: 30  改进后的方案所得到的堆栈信息可能没有那么的准确（因为没有精确的堆栈行号），但有lua代码地址和函数名已经能大大缩小其范围，相对耗时（一百倍）来说，具有极高的性价比。 以下是三种方式的对比：\n    方案 耗时（ms/10次）     traceback 112   getinfo（精确行号） 83   getinfo（函数行号） 1    总结  在通过一系列测试，最后采用了debug.getinfo的方式来获取堆栈，并且采用一个消耗极低的方式获取到对应的函数行号，从而方便定位到问题的模块。如果想要更精确可以和debug.traceback结合处理，日常使用低耗版本监控，有需要定位时采用精确定位。\n","ref":"/blog/xlua/delegatememoryleak/"},{"title":"Unity URP issue","date":"","description":"URP的疑难杂症","body":"总结在URP项目中遇到的疑难杂症\n版本  URP: 10.10.1  URP合批失败 隐藏的Keywords导致的合批失败 问题描述：\n 开启了SRP Batch时，两个模型使用了相同的shader，并且使用相同的变体，但无法SRP合批。 在FrameDebugger中提示“SRP:Node use different shader keywords”，但使用中的keywords是一样的。  问题原因：\n 材质球中残留了关键字导致的，虽然在实际使用中并没有用到，但Unity会认为两者使用了不同变体，而不会让其合批。 例如创建了材质球，先使用shaderA（例如lit.shader），调整了自发光设置，材质就会多了_EMISSION关键字，然后再替换成shaderB（没有_EMISSION关键字），这样材质球就残留了对应的keyword，而实际上shaderB没有_EMISSION和对应的变体。  参考： SRP Batch竟然和RenderQueue有关，有解吗\n打包shader丢失Pass/Variant  打包出来的shader（安装包、ab包）会丢失掉Pass、Variant等。\n 问题描述：\n 打包出来的shader（安装包、ab包）会丢失掉LightMode为ShadowCaster的Pass。 检查了Shader并没有问题 Editor下运行没有问题 Editor下查看shader编译的文件没有问题  问题原因：\n UnityEditor.Rendering.Universal.ShaderPreprocessor在检测GraphicsSettings和QualitySettings中的PipelineAsset时，发现没有supportsMainLightShadows和supportsAdditionalLightShadows时，会剔除掉LightMode为ShadowCaster的Pass。  ShaderFeatures  记录shader特性的枚举值，可用于后续剔除Pass、Variants的枚举值\n    Feature 说明 条件     MainLight 主光源 一定激活   MainLightShadows 主光源阴影 supportsMainLightShadows   AdditionalLights 多光源 additionalLightsRenderingMode == LightRenderingMode.PerPixel   AdditionalLightShadows 多光源阴影 AdditionalLights \u0026amp;\u0026amp; supportsAdditionalLightShadows   VertexLighting 顶点光照 additionalLightsRenderingMode == LightRenderingMode.PerVertex   SoftShadows 软阴影 (MainLightShadows || AdditionalLightShadows) \u0026amp;\u0026amp; supportsSoftShadows   MixedLighting 混合光照 supportsMixedLighting   TerrainHoles 地形挖空 supportsTerrainHoles   DeferredShading 延迟渲染 renderingMode == RenderingMode.Deferred   DeferredWithAccurateGbufferNormals 高精度GBuffer法线纹理\n（延迟渲染） 所有Renderer.accurateGbufferNormals == true   DeferredWithoutAccurateGbufferNormals 非高精确GBuffer法线纹理\n（延迟渲染） 所有Renderer.accurateGbufferNormals == false   ScreenSpaceOcclusion 屏幕空间环境光遮蔽\n（SSAO） 任意Renderer激活ScreenSpaceAmbientOcclusion    StripUnusedFeatures  主要为剔除没有使用的特性，剔除情况如下：\n    Keyword 说明 剔除条件     _MAIN_LIGHT_SHADOWS 主光源阴影 ShaderFeatures.MainLightShadows未激活   _MAIN_LIGHT_SHADOWS_CASCADE 主光源级联阴影 ShaderFeatures.MainLightShadows未激活   _SHADOWS_SOFT 软阴影 ShaderFeatures.SoftShadows未激活   _MIXED_LIGHTING_SUBTRACTIVE 混合光照相减 ShaderFeatures.MixedLighting未激活   LIGHTMAP_SHADOW_MIXING 光照贴图混合 ShaderFeatures.MixedLighting未激活   SHADOWS_SHADOWMASK 阴影遮罩 ShaderFeatures.MixedLighting未激活   _ADDITIONAL_LIGHT_SHADOWS 多光源阴影 ShaderFeatures.AdditionalLightShadows或ShaderFeatures.AdditionalLightShadows未激活   _DEFERRED_ADDITIONAL_LIGHT_SHADOWS 多光源阴影（延迟渲染） ShaderFeatures.AdditionalLightShadows未激活   _ADDITIONAL_LIGHTS 多光源（逐像素） ShaderFeatures.AdditionalLights未激活   _ADDITIONAL_LIGHTS_VERTEX 多光源（逐顶点） ShaderFeatures.VertexLighting未激活   _SCREEN_SPACE_OCCLUSION 屏幕空间环境光遮蔽 ShaderFeatures.ScreenSpaceOcclusion未激活    StripInvalidVariants  主要为剔除不合法的shader变体，剔除情况如下：\n    Keyword 说明 剔除条件     _MAIN_LIGHT_SHADOWS_CASCADE 主光源的级联阴影 _MAIN_LIGHT_SHADOWS未激活   _ADDITIONAL_LIGHT_SHADOWS 多光源阴影 _ADDITIONAL_LIGHTS未激活   _DEFERRED_ADDITIONAL_LIGHT_SHADOWS 多光源阴影（延迟渲染） _ADDITIONAL_LIGHTS未激活   _SHADOWS_SOFT 软阴影 _MAIN_LIGHT_SHADOWS、_MAIN_LIGHT_SHADOWS、_ADDITIONAL_LIGHTS都未激活    StripUnsupportedVariants  主要为剔除不支持的shader变体，剔除情况如下：\n    Keyword 说明 剔除条件     DIRLIGHTMAP_COMBINED 烘培开启方向图 LIGHTMAP_ON未激活   _USE_DRAW_PROCEDURAL DrawProcedural GLES20   _MAIN_LIGHT_SHADOWS_CASCADE 主光源的级联阴影 GLES20   _DETAIL_MULX2 两倍的Detail纹理 GLES20   _DETAIL_SCALED 自定义缩放的Detail纹理 GLES20   _CLEARCOAT 透明图层（车漆）效果 GLES20   _CLEARCOATMAP 透明图层（车漆）效果纹理 GLES20    StripUnusedPass  主要为剔除没有在用的Pass，剔除情况如下：\n    Pass(LightMode) 说明 剔除条件     Meta 生成Lightmapping的Pass 一定剔除   ShadowCaster 阴影捕获Pass ShaderFeatures.MainLightShadows、ShaderFeatures.AdditionalLightShadows未激活    Other  其他剔除情况，剔除情况如下：\n    Keyword 说明 剔除条件     _ALPHATEST_ON 启动AlphaTest Lit.shader,并且ShaderFeatures.TerrainHole未激活       Pass(Name) 说明 剔除条件     GBuffer GBuffer的Pass ShaderFeatures.DeferredShading未激活   GBuffer GBuffer的Pass ShaderFeatures.DeferredWithAccurateGbufferNormals激活\n_GBUFFER_NORMALS_OCT未激活   GBuffer GBuffer的Pass ShaderFeatures.DeferredWithoutAccurateGbufferNormals激活\n_GBUFFER_NORMALS_OCT激活   ","ref":"/blog/urp/issue/"},{"title":"HLSL","date":"","description":"HLSL","body":"HLSL的一些基础机制和常用函数\n常用函数 基本运算    名称 用例 描述 最小着色器模型 备注     max max(x, y) 返回x和y中的最大值 1    min min(x, y) 返回x和y中的最小值 1    mul mul(x, y) 返回x和y相乘的结果 1    abs abs(x) 返回x的绝对值 1    round round(x) 返回x的四舍五入结果 1    sqrt sqrt(x) 返回x的平方根 1    rsqrt rsqrt(x) 返回x的平方根的倒数 1    degrees degrees(x) 将弧度x转换为角度 1    redians redians(x) 将角度x转换为弧度 1    noise noise(x) 使用Perlin噪声算法生成-1到1之间的随机数 1    rcp rcp(x) 对分量求倒数 5     幂函数\u0026amp;指数函数\u0026amp;对数函数    名称 用例 描述 最小着色器模型 备注     pow pow(x, y) 返回x的y次幂 1    exp exp(x) 返回e的x次幂 1    exp2 exp2(x) 返回2的x次幂 1    ldexp ldexp(x, exp) 返回x和2的exp次方的乘积 1    log log(x) 返回以e为底，x的对数 1    log10 log10(x) 返回以10为底，x的对数 1    log2 log2(x) 返回以2为底，x的对数 1    frexp frexp(x, out exp) 将浮点数x分解为尾数和指数：$x=ret*2^{exp}$，函数返回尾数，exp返回指数 1     三角函数和双曲函数    名称 用例 描述 最小着色器模型 备注     sin sin(x) 返回x弧度的正弦 1    cos cos(x) 返回x弧度的余弦 1    tan tan(x) 返回x弧度的正切 1    sincos sincos(x, out s, out c) 返回x弧度的正弦和余弦 1    asin asin(x) 返回x弧度的反正弦 1    acos acos(x) 返回x弧度的反余弦 1    atan atan(x) 返回x弧度的反正切 1    atan2 atan2(y, x) 返回y/x的反正切值 1    sinh sinh(x) 返回x弧度的双曲正弦值，$\\frac{e^x-e^{-x}}{2}$ 1    cosh cosh(x) 返回x弧度的双曲余弦值，$\\frac{e^x+e^{-x}}{2}$ 1    tanh tanh(x) 返回x弧度的双曲正切值，$\\frac{e^x-e^{-x}}{e^x+e^{-x}}$ 1     数据范围    名称 用例 描述 最小着色器模型 备注     ceil ceil(x) 返回x的向上取整 1    floor floor(x) 返回x的向下取整 1    step step(x, y) 如果x小于等于y则返回1，否则返回0 1    saturate saturate(x) 将x限定在[0, 1] 1    clamp clamp(x, min, max) 将x限制在[min, max] 1    fmod fmod(x, y) 返回x对y取余的余数 1    frac frac(x) 返回x的小数部分 1    modf modf(x, out ip) 将值x分为小数和整数部分，每个部分的符号与x相同，ip返回整数部分，函数返回小数部分 1    lerp lerp(x, y, s) 使用s在x和y之间线性插值：$x+s(y-x)$ 1    smoothstep smoothstep(min, max, x) 如果x在[min，max]范围内，则返回介于0和1之间的平滑Hermite插值，如果x小于min则返回0，如果x大于max则返回1 1     类型判断    名称 用例 描述 最小着色器模型 备注     all all(x) 如果x的所有分量都不为0，则返回true；否则返回false 1    clip clip(x) 如果x小于0，则丢弃当前像素 1    sign sign(x) 如果x小于0，返回-1，如果x等于0，返回0，如果x大于0，返回1 1    isinf isinf(x) 如果x为正无穷或负无穷，返回true，否则返回false 1    isfinite isfinite(x) 与isinf相反 1    isnan isnan(x) 如果x为NAN，则返回true，否则返回false 1     向量和矩阵    名称 用例 描述 最小着色器模型 备注     length length(v) 返回向量v的长度 1    normalize normalize(v) 返回v的归一化向量 1    distance distance(a, b) 返回a和b之间的距离 1    dot dot(a, b) 返回a和b的点积 1    cross cross(a, b) 返回a和b的叉积 1    determinant determinant(m) 返回矩阵m的行列式的值 1    transpose transpose(m) 返回m的转置 1     光线运算    名称 用例 描述 最小着色器模型 备注     reflect reflect(i, n) 以i为入射方向，n为法线的反射光 1    refrect refrect(i, n, ri) 以i为入射方向，n为法线方向，ri为折射率的折射光 1    lit lit(n_dot_l, n_dot_h, m) 输入归一化的法线和光向量的点积，半角向量和法线的点积，高光指数，返回光照向量（环境光，漫反射，高光，1） 1    faceforward faceforward(n, i, ng) 返回面向视图方向的曲面法向量 1     纹理查找    名称 用例 描述 最小着色器模型 备注     tex1D tex1D(s, t) 返回s在t处的值 1    tex1D tex1D(s, t, ddx, ddy) 使用偏导数对2D纹理进行采样以选择Mip级别 1    tex1Dproj tex1Dproj(s, t) 将xyz除以w，然后进行纹理查找 1    tex1Dlod tex1Dlod(s, t) 使用lod查找纹理s在t.w处的值 1    tex1Dbias tex1Dbias(s, t) 将t.w决定的某个Mip层偏置后的纹理查找 1    tex1Dgrad tex1Dgrad(s, t, ddx, ddy) 使用微分并指定Mip层的纹理查找 1    ","ref":"/blog/shader/hlsl/"},{"title":"YooAsset插件","date":"","description":"学习YooAsset插件和分析","body":"YooAsset是一个Unity资源系统，集合资源打包、分包、更新、加载等。\n信息  官网：YooAsset 版本：1.4.2 源码：https://github.com/tuyoogame/YooAsset  构建 收集  检测配置合法性 收集所有Package的资源（遍历所有的Group，然后再遍历所有的Collector）  AssetBundleCollectorSettingData.Setting.GetPackageAssets(buildMode, packageName); 剔除未被引用的依赖资源 录入所有收集器收集的资源 录入相关依赖的资源 记录关键信息 填充主动收集资源的依赖列表 计算完整的资源包名 移除不参与构建的资源 构建资源包  Runtime 初始化  YooAssets初始化。  创建驱动器YooAssetsDriver用于调度系统的Update 创建远程调试器RemoteDebuggerInRuntime用于调试加载情况 初始化异步系统OperationSystem    // 初始化资源系统 YooAssets.Initialize();  创建Package。  创建package 设置为默认的package    // 创建默认的资源包 var package = YooAssets.CreateAssetsPackage(\u0026#34;DefaultPackage\u0026#34;); // 设置该资源包为默认的资源包，可以使用YooAssets相关加载接口加载该资源包内容。 YooAssets.SetDefaultAssetsPackage(package);  初始化资源系统（Editor模拟）  EditorSimulateModeHelper.SimulateBuild会调用AssetBundleSimulateBuilder构建资源清单 再把Parameters传入package进行资源清单初始化 package根据mode创建EditorSimulateModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 EditorSimulateModeImpl进行初始化。 调用EditorSimulateModeInitializationOperation加载清单，并且设置清单到EditorSimulateModeImpl    var createParameters = new EditorSimulateModeParameters(); createParameters.SimulatePatchManifestPath = EditorSimulateModeHelper.SimulateBuild(packageName); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（单机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建OfflinePlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 OfflinePlayModeImpl进行初始化。 调用OfflinePlayModeInitializationOperation  获取Package版本号 加载清单。 设置清单到OfflinePlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（联机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建HostPlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 HostPlayModeImpl进行初始化。 调用HostPlayModeInitializationOperation  获取补丁水印（安装包版本号和补丁版本号），如果水印不一致，则清空缓存目录。 获取缓存目录Package版本号，如果存在，则加载和解析缓存目录清单 在缓存目录清单加载失败（版本号不对、hash值不对、清单不存在等），则获取安装包Package版本号，并且把版本号和清单写入到缓存目录。最后再加载安卓包清单。 设置清单到HostPlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters); 更新 //更新Package版本信息 var operation = package.UpdatePackageVersionAsync(); yield return operation; //更新Package资源清单 package.UpdatePackageManifestAsync(operation.PackageVersion); //创建下载器 var downloader = YooAssets.CreatePatchDownloader(downloadingMaxNum, failedTryAgain);  只有联机模式才有更新系统\n  HostPlayModeUpdatePackageVersionOperation请求远端版本号信息。 HostPlayModeUpdatePackageManifestOperation更新补丁清单。  加载Cache清单，判断版本号是否为最新 当版本号不是最新时，下载远端清单到Cache目录。 重新加载Cache清单。 校验清单的资源包，将正确的补丁放入CacheSystem   PatchDownloaderOperation下载补丁（不包含已有缓存、内置资源） 清除过期的补丁文件  扩展  由于代码比较简单易懂，并且框架解耦的较好，扩展性比较好。\n 更新  目前热更方式为CDN获取版本信息，可以增加后台模式，以适应后台更新的方案。\n //AssetsPackage.InitializeAsync()  if (...) { ... } else if (_playMode == EPlayMode.ServerPlayMode) { var serverPlayModeImpl = new ServerPlayModeImpl(); ... } 疑问  覆盖安装情况下，资源是否正常？   会通过水印判断安装包是否有变更，如果安装包变更了，则清除Cache目录\n  断点续传是否会出现缺漏的问题？   每次会对文件计算hash值进行校验。没有缺漏问题。\n  热更是否要在Cache增加一份副本？   安装包的内容只有一份。热更时会使用IsBuildinPatchBundle进行判断剔除。\n  CDN需要全量补丁？   发布没有差异补丁的概念，所以都是全量补丁\n 对比 Addressable  Group与Addressable的差不多，都是用于资源分组使用 没有了自定义Entry的概念，取而代之增加了Collector对资源进行收集设置。 收集器的地址保存的是字符串，移动文件夹时会出现丢失的问题。 获取Entry地址和寻址信息需要手动拼写 Tags只能对Group设置，无法只对Collector和Entry设置 Group相对于Addressable去除了很多独立设置，无法对AB进行独立设置压缩方式，命名方式等 地址和寻址两套方式可以选择使用 支持旧的构建模式和SBP模式 配置有Json和Bytes两种，bytes只是简单序列化了，并没有做压缩处理。 Group之上还增加了Package的概念，用于构建时可以分情况构建。 有多种构建模式，例如演练和模拟模式可以方便调试 有调试器和报告查看工具 更新地址需要运行设置。 支持构建原文件 Editor模拟模式，需要每次运行时调用构建，需要生成列表清单。目前只有收集到的资源需要生成清单，理论上速度应该不慢。 构建时才会检查资源是否重复收集 Operation采用的是Update来处理，没有采用协程。Operation通过状态来去区分任务，需要等待子Operation完成来改变状态。 有加密接口。Android采用加密只能使用偏移头文件的方式，如果采用其他方式，将无法加载SteamingAsset目录资源。  问题  在AssetBundleFileLoader加载失败时会调用CacheSystem.DiscardFile清除，但实际上会清除整个Cache目录！！！ 缺少SpriteAtlas打包 加载场景时，会自动清空资源引用计数，导致对象池中的对象丢失资源引用。 只有在加载场景时才会检测资源引用计数  优点  代码结构较为简单，容易扩展 多线程下载 多线程校验文件 开箱即用  缺点  每次都需要校验文件，全量计算文件Hash，数量一多会比较耗时 收集器需要填写配置，有资源需要特殊处理时，比较难处理 补丁为全量资源上传CDN，如果改成增量补丁，并且按版本分开目录，需要扩展新的mode。 寻址的Key值无法自定义，相同文件名会出现Key重复的问题。 ","ref":"/blog/plugin/yooasset/"},{"title":"构建iOS包","date":"","description":"构建iOS包","body":"在构建iOS包时，遇到了挺多问题，因此记录下来，以备不时之需\n环境  Unity:2020.3.26f1 XCode:13.2.1(13C100)  导出xcodeproj  使用UnityEditor.BuildPipeline.BuildPlayer构建即可，然后就导出xcodeproj。\n 设置xcodeproj配置 PBXProject工具  PBXProject是Unity用于修改导出的xcode工程参数的工具。 P.S.需要安装iOSSupport\n //初始化PBXProject UnityEditor.iOS.Xcode.PBXProject project = new UnityEditor.iOS.Xcode.PBXProject(); string projectName = UnityEditor.iOS.Xcode.PBXProject.GetPBXProjectPath(projectPath); //使用BuildPlayer的构建目录地址获取PBX项目地址 project.ReadFromFile(projectName); //读取项目配置文件  //修改配置的逻辑....  project.WriteToFile(projectName); //把修改后的配置写入  添加引用库  某些第三方SDK需要加入引用的库。 例如Bugly，需要增加以下库：\n  libz.tbd libc++.tbd Security.framework SystemConfiguration.framework JavaScriptCore.framework  然后可以使用AddFrameworkToProject进行添加这些库。\n//先获取UnityFramework的targetGUID，用于指定需要添加库的配置 string frameworkGUID = project.GetUnityFrameworkTargetGuid(); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libz.tbd\u0026#34;, false); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libc++.tbd\u0026#34;, false); ... 设置属性  需要设置某些构建属性时，需要用到SetBuildProperty方法。 例如关闭Bitcode\n //获取UnityMain和UnityFramework的targetGUID，用于指定需要修改属性的配置 string mainTargetGUID = project.GetUnityMainTargetGuid(); string frameworkGUID = project.GetUnityFrameworkTargetGuid(); //Bitcode需要都关闭 project.SetBuildProperty(mainTargetGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode project.SetBuildProperty(frameworkGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode  //发布版时，需要修改签名类型 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY[sdk=iphoneos*]\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态  project.SetBuildProperty(mainTargetGUID, \u0026#34;PROVISIONING_PROFILE_SPECIFIER\u0026#34;, m_Setting.ProvisioningProfileName); //需要设置ProvisioningProfile ExportOptions  Method：方式  app-store enterprise ad-hoc development   BundleID：包名 ProvisioningProfile：证书名字 TeamID：证书的TeamID Certificate：签名证书  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34; -//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;compileBitcode\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;destination\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;export\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;manageAppVersionAndBuildNumber\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;method\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${METHOD}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;provisioningProfiles\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;${BUNDLE_ID}\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${PROVISIONING_PROFILE}\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;signingCertificate\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${CERTIFICATE}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;signingStyle\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;manual\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;stripSwiftSymbols\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;teamID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${TEAM_ID}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;thinning\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026amp;lt;none\u0026amp;gt;\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 错误处理 环境错误  The data couldn’t be read because it isn’t in the correct format\n  https://www.jianshu.com/p/103f414fa870 https://stackoverflow.com/questions/58272706/error-exportarchive-the-data-couldn-t-be-read-because-it-isn-t-in-the-correct\n sqlite3环境问题导致的报错，执行如下指令即可：\ngem list | grep sqlite3 gem install sqlite3 --platform=ruby rvm use system --default 类型错误  Error Domain=IDEProfileLocatorErrorDomain Code=4 \u0026ldquo;No \u0026ldquo;iOS App Development\u0026rdquo; profiles for team \u0026lsquo;*****\u0026rsquo; \u0026hellip;..\n 确保provisioning profile中填入的类型正确\n授权问题  \u0026ldquo;error: \u0026ldquo;Unity-iPhone\u0026rdquo; requires a provisioning profile. Select a provisioning profile in the Signing \u0026amp; Capabilities editor. (in target \u0026lsquo;Unity-iPhone\u0026rsquo; from project \u0026lsquo;Unity-iPhone\u0026rsquo;)\u0026rdquo;\n 一般是没有登录provisioning profile对应的开发者账号，或者是没有安装provisioning profile对应的Capabilities\n","ref":"/blog/publish/buildios/"},{"title":"UnityEvent引起的内存泄漏","date":"","description":"UnityEvent引起的内存泄漏","body":"一个由UnityEvent缓存机制引起的内存泄漏问题\n前言  笔者在开发项目时，发现在xLua Dispose时总是会有DelegateBridge没有移除的情况，而排查了一轮，发现就算是一个简单界面也会出现这种情况。 后来经过一轮排查，发现Button的点击事件触发了，就会出现无法移除DelegateBridgeBase，然后翻看了xLua的issue（xLua#139）发现很早就有这个问题，而且也有人提供了解决方案。\n 问题原因 首先这个问题归根到底是由UnityEvent的缓存机制导致：\n Unity在设计UnityEvent时，为其加了缓存机制，也就是上一次调用过的Calls会缓存起来，然后在增加/删除callback时，对缓存设置脏标记。然后在下一次触发事件时，在有变动时才会重新生成Calls。\n //这里截取Unity 2020.3.x版本UnityEvent.CS \u0026lt;InvokableCallList\u0026gt;类的片段 //与Issue中的版本代码有点差异，但机制大致相同 public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); m_NeedsUpdate = true; } ... public List\u0026lt;BaseInvokableCall\u0026gt; PrepareInvoke() { if (m_NeedsUpdate) { m_ExecutingCalls.Clear(); m_ExecutingCalls.AddRange(m_PersistentCalls); m_ExecutingCalls.AddRange(m_RuntimeCalls); m_NeedsUpdate = false; } return m_ExecutingCalls; } 那么问题就来，由于在每次触发（Invoke）事件前，才会重新生成Calls,就算之前已经对callback进行了Remove了，只要没有调用，缓存还会保留已经移除的函数。\n问题危害 正常流程 在xLua框架中，lua需要监听C#的事件，需要把function(lua)设置到LUA_REGISTRYINDEX，并且把引用给到C#，C#再生成Delegate，然后把Delegate和引用封装到DelegateBridge(C#)对象中。 这样，只要把此Delegate绑定到对应的事件中，当事件触发后，就会调用此Delegate，再由DelegateBridge根据引用获取并调用function(lua)。\n由于DelegateBridge只以弱引用的方式保存，所以当移除事件后，Delegate只与对应的DelegateBridge有引用关系，所以在下一轮GC即可销毁掉DelegateBridge，从而接触对应引用的function(lua)（将function从LUA_REGISTRYINDEX中释放掉）。\n这个时候，lua gc就可以把function以及对应upvalue销毁（假设没有任何其他对象引用）。\n泄漏情况 上述都是function(lua)与Delegate绑定和释放的正常流程。而在UnityEvent内存泄漏的情况下，又会变得怎样呢？\n这里我们加入比较常见的情景：\nlocal item = {} item.name = \u0026#34;name\u0026#34; item.button = .... --获取Button对象 item.button.onClick:AddListener(function () print(item.name) end) ...--一顿操作 item.button.onClick:RemoveAllListeners() 根据前文，如果我们在移除前触发了点击事件，那么UnityEvent就会缓存了Delegate，从而保留了DelegateBridge。这个时候唯一办法就是等button释放掉，顺带把UnityEvent也释放，这样DelegateBridge才能给GC回收。\n但是，我们button却给lua的table对象引用了，而这个table又是闭包函数的upvalue值，而最糟糕的是，这个闭包函数却给DelegateBridge引用了（通过LUA_REGISTRYINDEX）。所以，这个table以及button(userdata)都无法给GC回收。\n那么现在就形成了一个死结，而这个死结只要有任何一处解开就可以完全解开了，但现在处处都无法解开。\n解决方案 调用Invoke 根据xLua#139，可以在RemoveAllListener之后，手动调用一次Invoke，这样就可以清除掉Calls。\n 但此方法有个问题，假设Button在Inspector界面上绑定了持久化事件，就会多触发一次事件，可能会有意想不到的bug出现。所以不建议使用\n 反射 根据xLua#139，其实可以通过反射去释放掉UnityEvent中的缓存。\nprivate static MethodInfo prepareInvoke; public static void ReleaseUnusedListeners(this UnityEventBase unityEventBase) { if (prepareInvoke == null) { BindingFlags flag = BindingFlags.Instance | BindingFlags.NonPublic; Type type = unityEventBase.GetType(); prepareInvoke = type.GetMethod(\u0026#34;PrepareInvoke\u0026#34;, flag); } prepareInvoke.Invoke(unityEventBase, null); } ... item.button.onClick:RemoveAllListeners() item.button.onClick:ReleaseUnusedListeners()  笔者在issue基础上进行了优化。 此方案副作用小，只要不忘记调用，就可以释放掉对应事件。笔者也是采用这套方案。 这里要注意的是，如果是采用Generate的方式，需要增加ButtonClickedEvent等参数的接口，不然xlua会找不到方法。\n 升级版本 UnityEvent这个内存泄漏的问题，在Unity 2021.2.x版本就已经修复了（吐槽：这个bug在2017年前就已经存在了）。\n Scripting: Fixed a memory leak happening when removing listeners from a UnityEvent that is never raised afterwards. (1303095) 所以可以通过升级版进行修复。\n public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); // removals are done synchronously to avoid leaks  var newExecutingCalls = new List\u0026lt;BaseInvokableCall\u0026gt;(m_PersistentCalls.Count + m_RuntimeCalls.Count); newExecutingCalls.AddRange(m_PersistentCalls); newExecutingCalls.AddRange(m_RuntimeCalls); m_ExecutingCalls = newExecutingCalls; m_NeedsUpdate = false; } ","ref":"/blog/unity3d/unityeventmemoryleak/"},{"title":"C#知识点-反射","date":"","description":"收纳一些常用的C#知识点","body":"收纳归总一些常用的C#技巧或者知识点\nType.IsByRef  当参数的类型为引用传递时，IsByRef为True。此时要获得最终类型需要调用GetElementType()。\n private class CustomTypeClass { //Console：type name:Int32 isByRef:False  public void Fun(int value) { } //Console：type name:Int32\u0026amp; isByRef:True elementType:Int32  public void Fun(ref int value) { } //Console：type name:Object isByRef:False  public void Fun(object obj) { } //Console：type name:Object\u0026amp; isByRef:True elementType:Object  public void Fun(ref object obj) { } //Console：type name:Int32[] isByRef:False  public void Fun(int[] intarray) { } //Console：type name:Int32[]\u0026amp; isByRef:True elementType:Int32[]  public void Fun(ref int[] intarray) { } } static void Main(string[] args) { MethodInfo[] methodInfos = typeof(CustomTypeClass).GetMethods(); foreach (var methodInfo in methodInfos) { ParameterInfo[] parameters = methodInfo.GetParameters(); foreach (var parameter in parameters) { var parameterType = parameter.ParameterType; Debug.WriteLine(string.Format(\u0026#34;method name:{0}\u0026#34;, methodInfo.Name)); LogType(parameterType); } } } private static void LogType(Type type) { if (type.IsByRef) { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1} elementType:{2}\u0026#34;, type.Name, type.IsByRef, type.GetElementType().Name)); } else { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1}\u0026#34;, type.Name, type.IsByRef)); } } ","ref":"/blog/csharp/reflection/"},{"title":"Github Action自动化部署Hugo","date":"","description":"教你如何使用Github Action自动化部署Hugo静态页面","body":"每次用Hugo写完Blog，都要重新编译，然后提交到对应的仓库，重复并且繁琐。所以，这里就教大家如何使用Github的自动化构建工具-Action，自动编译部署到Github Pages上。\n由于本文只是教如何使用Github Action，因此，Hugo的调试和部署，不额外拓展。\nRepositorie  创建两个仓库用于后续Action使用\n Source Repositorie  创建一个{xxxxx}.github.source   P.S.{xxxxx}为自己的域名。\n  Source仓库，是用来放置Hugo源码的。  Page Repositorie  创建一个{xxxxx}.github.io   P.S.{xxxxx}为自己的域名。如果使用Github Pages的域名，请与Github账号名一致\n  Page仓库用于放置生成后的Html页面  Github Action  使用Action自动化部署到Pages\n Create ssh-keygen // 使用命令生成公钥和密钥 // {email}为你的邮箱地址 // 注意：不要输入密码，直接回车即可，因为有密码的话，Action运行时会卡在输入密码的步骤 ssh-keygen -t rsa -b 4096 -C \u0026quot;{email}\u0026quot; 这样，本地就会产生一个公钥和一个密钥\n 记住，一定要生成4096以上，不然后续Action时无法正常连接Pages仓库\n Source Repositorie  进入\u0026quot;Settings/secrets/Actions\u0026rdquo; 点击\u0026quot;New repository secret\u0026rdquo; Title填写\u0026quot;ACTIONS_DEPLOY_KEY\u0026rdquo; Value填写私钥文件的内容 确定       Pages Repositorie  进入\u0026quot;Settings/Deploy keys\u0026rdquo; 点击\u0026quot;Add deploy key\u0026rdquo; Title填写\u0026quot;Public of ACTIONS_DEPLOY_KEY\u0026rdquo; Key填写.pub文件（公钥）的内容 勾选\u0026quot;Allow write access\u0026rdquo; 确定       Add Action  在源码仓库的\u0026rdquo;.github/workflows\u0026quot;下已经有\u0026quot;gh-pages.yml\u0026quot;用于生成Pages\n  如果没有，请完整阅读\u0026quot;Create Action\u0026rdquo;。\n Create Action  参考actions-hugo\n name: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.74.2' extended: true - name: Setup Node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm ci - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: publish_dir: ./public publish_branch: master # deploying cname: Change Action  hugo-version为Hugo版本，尽量改成与自己调试的环境一直版本 修改deploy_key为\u0026quot;${{ secrets.ACTIONS_DEPLOY_KEY }}\u0026rdquo;   ACTIONS_DEPLOY_KEY为刚才添加的密钥\n  修改external_repository为放置Pages的Repositorie地址 修改publish_branch为Page仓库的主干，例如master或者main 增加cname为你的域名，用于域名解析。P.S.如果没有，则注释或者删除此行  Deploy  当你在Source Repositorie提交修改时，“github pages”这个action就会自动启动，然后初始化环境、编译、部署，实现完全的自动化。而你，只需要在提交文章几分钟后，刷新一下页面。\n      ","ref":"/blog/git/githubaction-hugo/"},{"title":"","date":"","description":"","body":"","ref":"/blog/lua/hotreload/"},{"title":"联络","date":"","description":"","body":"","ref":"/contact/"}]