[{"title":"xLua-数据结构","date":"","description":"阐述xLua的数据结构设计","body":"阐述xLua中的数据结构设计\n整体  先来看一下整体的结构图\n  Class table  C#的静态函数接口在Lua中的结构是怎样一种方式存储？下面的结构图能够很好的表示。\n C#类的静态函数接口（包括静态字段/静态属性/构造函数等warp的）是以table（Class table）的形式存储在_G[\u0026quot;CS\u0026quot;]表中。\n静态属性/字段 当调用静态属性/字段时，根据属性/字段名在对应的Class table中获取对应warp的Function并调用。\n构造函数 对类的table调用()时，自动调用其元表中的__call函数，而这就是C#函数中的__CreateInstance。\n Object metatable  C#的对象在Lua中的结构是怎样一种方式存储？下面的结构图能够很好的表示。\n C#对象的函数接口（包括字段/属性等warp的）是以metatable（Object metatable）的形式存储在REGISTRYINDEX表中。 在初始化对象时，先根据完全类名获取到相应Class的table，然后通过其metatable的__call函数实例化一个C#对象。 接着创建对象对应的userdata，然后将对应的Object metatable设置给对象的userdata。\n","ref":"/blog/xlua/datastructure/"},{"title":"C#知识点-反射","date":"","description":"收纳一些常用的C#知识点","body":"收纳归总一些常用的C#技巧或者知识点\nType.IsByRef  当参数的类型为引用传递时，IsByRef为True。此时要获得最终类型需要调用GetElementType()。\n private class CustomTypeClass { //Console：type name:Int32 isByRef:False  public void Fun(int value) { } //Console：type name:Int32\u0026amp; isByRef:True elementType:Int32  public void Fun(ref int value) { } //Console：type name:Object isByRef:False  public void Fun(object obj) { } //Console：type name:Object\u0026amp; isByRef:True elementType:Object  public void Fun(ref object obj) { } //Console：type name:Int32[] isByRef:False  public void Fun(int[] intarray) { } //Console：type name:Int32[]\u0026amp; isByRef:True elementType:Int32[]  public void Fun(ref int[] intarray) { } } static void Main(string[] args) { MethodInfo[] methodInfos = typeof(CustomTypeClass).GetMethods(); foreach (var methodInfo in methodInfos) { ParameterInfo[] parameters = methodInfo.GetParameters(); foreach (var parameter in parameters) { var parameterType = parameter.ParameterType; Debug.WriteLine(string.Format(\u0026#34;method name:{0}\u0026#34;, methodInfo.Name)); LogType(parameterType); } } } private static void LogType(Type type) { if (type.IsByRef) { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1} elementType:{2}\u0026#34;, type.Name, type.IsByRef, type.GetElementType().Name)); } else { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1}\u0026#34;, type.Name, type.IsByRef)); } } ","ref":"/blog/csharp/reflection/"},{"title":"About","date":"","description":"希望这里的教程能给大家提供灵感","body":"Unity主程、游戏迷、胶佬、垃圾佬\u0026hellip;\n这里主要是想把自己日常开发所遇到的问题、感悟的见解全写出来，为大家提供一些思路和灵感。\n同时也提供一个交流的平台。\n","ref":"/about/"},{"title":"Github Action自动化部署Hugo","date":"","description":"教你如何使用Github Action自动化部署Hugo静态页面","body":"每次用Hugo写完Blog，都要重新编译，然后提交到对应的仓库，重复并且繁琐。所以，这里就教大家如何使用Github的自动化构建工具-Action，自动编译部署到Github Pages上。\n由于本文只是教如何使用Github Action，因此，Hugo的调试和部署，不额外拓展。\nRepositorie  创建两个仓库用于后续Action使用\n Source Repositorie  创建一个{xxxxx}.github.source   P.S.{xxxxx}为自己的域名。\n  Source仓库，是用来放置Hugo源码的。  Page Repositorie  创建一个{xxxxx}.github.io   P.S.{xxxxx}为自己的域名。如果使用Github Pages的域名，请与Github账号名一致\n  Page仓库用于放置生成后的Html页面  Github Action  使用Action自动化部署到Pages\n Create ssh-keygen // 使用命令生成公钥和密钥 // {email}为你的邮箱地址 // 注意：不要输入密码，直接回车即可，因为有密码的话，Action运行时会卡在输入密码的步骤 ssh-keygen -t rsa -b 4096 -C \u0026quot;{email}\u0026quot; 这样，本地就会产生一个公钥和一个密钥\n 记住，一定要生成4096以上，不然后续Action时无法正常连接Pages仓库\n Source Repositorie  进入\u0026quot;Settings/secrets/Actions\u0026rdquo; 点击\u0026quot;New repository secret\u0026rdquo; Title填写\u0026quot;ACTIONS_DEPLOY_KEY\u0026rdquo; Value填写私钥文件的内容 确定  Pages Repositorie  进入\u0026quot;Settings/Deploy keys\u0026rdquo; 点击\u0026quot;Add deploy key\u0026rdquo; Title填写\u0026quot;Public of ACTIONS_DEPLOY_KEY\u0026rdquo; Key填写.pub文件（公钥）的内容 勾选\u0026quot;Allow write access\u0026rdquo; 确定  Add Action  在源码仓库的\u0026rdquo;.github/workflows\u0026quot;下已经有\u0026quot;gh-pages.yml\u0026quot;用于生成Pages\n  如果没有，请完整阅读\u0026quot;Create Action\u0026rdquo;。\n Create Action  参考actions-hugo\n name: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.74.2' extended: true - name: Setup Node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm ci - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: publish_dir: ./public publish_branch: master # deploying cname: Change Action  hugo-version为Hugo版本，尽量改成与自己调试的环境一直版本 修改deploy_key为\u0026quot;${{ secrets.ACTIONS_DEPLOY_KEY }}\u0026rdquo;   ACTIONS_DEPLOY_KEY为刚才添加的密钥\n  修改external_repository为放置Pages的Repositorie地址 修改publish_branch为Page仓库的主干，例如master或者main 增加cname为你的域名，用于域名解析。P.S.如果没有，则注释或者删除此行  Deploy  当你在Source Repositorie提交修改时，“github pages”这个action就会自动启动，然后初始化环境、编译、部署，实现完全的自动化。而你，只需要在提交文章几分钟后，刷新一下页面。\n ","ref":"/blog/git/githubaction-hugo/"},{"title":"","date":"","description":"","body":"","ref":"/blog/lua/hotreload/"},{"title":"联络","date":"","description":"","body":"","ref":"/contact/"}]