[{"title":"Unity性能优化技巧汇总","date":"","description":"Unity性能优化技巧汇总","body":"汇总一些简单的性能优化技巧\nPhysics（物理） 减少FixedUpdate调用次数 FixedUpdate是采用固定的调用间隔：Time.fixedDeltaTime，由于是固定调用间隔，因此每帧的调用次数实际上是通过Time.deltaTime/Time.fixedDeltaTime计算出来的，如果当前帧卡顿了，那么FixedUpdate很大可能（超过Time.fixedDeltaTime）会增加调用次数，情况会更糟。\n而通过设置Time.maximumDeltaTime，可以将把次数减少。最终次数为Min(Time.deltaTime, Time.maximumDeltaTime)/Time.fixedDeltaTime，例如默认为0.333，则单帧最大调用次数可以达到17次，而如果改成0.100，则单帧最大调用次数会降到5次。\n有两种修改方式：\n 通过菜单：ProjectSetting \u0026gt; Time \u0026gt; Maximum Allowed Timestep修改 1 通过代码：Time.maximumDeltaTime 2       去除physics.processing 即使没有用到物理碰撞功能，但物理逻辑仍然会运行，会产生耗时。这个时候可以关闭Physics.autoSimulation来减少这部分耗时。3 关闭Physics.autoSimulation后，如果需要射线检测，则需要开启Physics.autoSyncTransforms或者手动调用**Physics.SyncTransforms()**来将Transform的变更同步到物理引擎。\n      Physics.autoSyncTransforms有两个常见的耗时堆栈：Physics.SyncColliderTransform和Physics.SyncRigidbodyTransform，都是在Transform发生变化时才会有计算。\n        Time, https://docs.unity3d.com/Manual/class-TimeManager.html \u0026#x21a9;\u0026#xfe0e;\n Time.maximumDeltaTime, https://docs.unity3d.com/ScriptReference/Time-maximumDeltaTime.html \u0026#x21a9;\u0026#xfe0e;\n 如果Unity没有用到物理部分，应该如何关闭？, https://answer.uwa4d.com/question/6285b2a7b87a4573515d6387 \u0026#x21a9;\u0026#xfe0e;\n  ","ref":"/blog/unity3d/optimization/"},{"title":"Unity URP 优化技巧","date":"","description":"URP的优化技巧","body":"URP项目的优化技巧汇总，由于篇幅问题，部分优化中的原理会在其他文章中详细介绍。\n版本  URP: 10.10.1  Bloom优化 关闭HQ HQ选项能够让Bloom效果更加平滑。这是因为开启HQ后，降采样前会对原图进行一次Blur，然后再升采样时会有部分采用双向三次插值采样。\nHQ开启带来更好的效果，随之而来也带来更大的性能消耗。具体统计数据可以查看URP Bloom效果文章，里面有更详细的分析。\n 所以关闭HQ可以带来2~3ms（小米9）的减少，而效果往往不会相差太多。\n 降迭代 URP的Bloom算法是通过多次降采样和多次升采样来进行Blur操作的，而往往需要多次迭代来达到Blur的效果。 但迭代次数多意味着需要多次Blit，而每次Blit都需要等待上一次的结果，所以也无法做到并行处理，而随着迭代次数增多，Blit的尺寸越来越小，后面的Blit并没有充分利用GPU的算力。 而越往后的低尺寸Blur，实际上并不会对最终效果做出很大权重的贡献。\n综合上述情况，URP Bloom提供了Skip Iterations的选项，可以减少原有的迭代次数:\n//PostProcessPass.CS // Determine the iteration count int maxSize = Mathf.Max(tw, th); int iterations = Mathf.FloorToInt(Mathf.Log(maxSize, 2f) - 1); iterations -= m_Bloom.skipIterations.value; 与关闭HQ一样，具体统计数据可以查看URP Bloom效果文章，里面有更详细的分析。\n 所以减少迭代次数可以带来1~2ms（小米9）的减少，而效果往往不会相差太多。 当然，迭代次数减少也不是越小越好的，需要根据实际情况考虑。\n 降采样 Bloom后处理本来就有降采样处理。首先会降1/4（宽高各1/2），然后再逐级下降。\n这个操作本来就已经能降低采样规模，不过还可以进一步减少。\n 就是在首次降采样时可以更激进的使用1/8~1/16，这样每级的采样纹理会更较小，可以减少带宽。\n //PostProcessPass.CS void SetupBloom(CommandBuffer cmd, int source, Material uberMaterial) { int tw; int th; if (m_Bloom.downSample.value) { // Start at quarter-res  tw = m_Descriptor.width \u0026gt;\u0026gt; 2; th = m_Descriptor.height \u0026gt;\u0026gt; 2; } else { // Start at half-res  tw = m_Descriptor.width \u0026gt;\u0026gt; 1; th = m_Descriptor.height \u0026gt;\u0026gt; 1; } //... }  值得注意，这么做并不是没有缺点的： 纹理越小，锯齿感越明显。特别在高强度的情况下特别明显。\n","ref":"/blog/urp/optimize/"},{"title":"About","date":"","description":"希望这里的教程能给大家提供灵感","body":"Unity 游戏开发\u0026hellip;\n这里主要是想把自己日常开发所遇到的问题、感悟的见解全写出来，为大家提供一些思路和灵感。\n","ref":"/about/"},{"title":"Fantasy Factor","date":"","description":"Unity Tools by Fantasy Factor","body":"email: 2771918131@qq.com\n Fantasy Factor      Fantasy Factor   UnityCompare      UCompare   A tool for comparing Unity3D Prefabs, quickly comparing differences, copying components, copying properties, etc. The principle is based on the comparison of the subtrees of two Prefabs in sequence (by name), and then the differences are displayed in a tree structure. Then, by clicking in, you can see the differences in the Components of the two sub-GameObjects. After selecting a specific GameObject or Component, you can see the comparison based on SerializedObject and SerializedProperty, and then you can perform editing operations.\n Feature List  Compare Prefab Differences Visualize Results Filterable Results Customizable Ignored Properties Quick Copy of GameObject Quick Copy of Component Quick Comparison Menu Synchronized Tree List Component Display Consistent with Unity  ","ref":"/fantasyfactor/"},{"title":"URP Bloom效果","date":"","description":"URP Bloom后处理","body":"分析URP的Bloom效果\n原理分析 源码剖析  URP的Bloom是作为后处理实现在PostProcessPass中。C#部分的核心代码有SetupBloom()。\n // Start at half-res int tw = m_Descriptor.width \u0026gt;\u0026gt; 1; int th = m_Descriptor.height \u0026gt;\u0026gt; 1; // Determine the iteration count int maxSize = Mathf.Max(tw, th); int iterations = Mathf.FloorToInt(Mathf.Log(maxSize, 2f) - 1); iterations -= m_Bloom.skipIterations.value; int mipCount = Mathf.Clamp(iterations, 1, k_MaxPyramidSize);  由上文原理分析可知，为了减少模糊时的采样次数，模糊之前首先需要先降一次分辨率，所以先计算分辨率一半的宽高值。 然后使用半分辨率的宽高值来计算模糊需要迭代的次数（注意：这里并不是Blur的次数），例如2400，则需要迭代9次，然后剔除需要忽略的迭代次数，不开启skipIterations时，skipIterations.value默认为1次，再对迭代次数限制一下，因此最终迭代次数为8次。 P.S.实际上，这里最后用了mipCount来命名才是较为准确的说法，按照迭代次数的字面理解，应该是Blur的次数（横向+纵向视为一次Blur），但排除了预降采样后，Blur的次数等于mipCount-1。因此用mipCount较为贴切，以2400举例，mip[0]就是1200，mip[1]为600，mip[2]为300\u0026hellip;。而首次Blur就是mip[0]到mip[1]，这样就能理解后续的逻辑。\n //设置材质球属性 //...  // Prefilter var desc = GetCompatibleDescriptor(tw, th, m_DefaultHDRFormat); cmd.GetTemporaryRT(ShaderConstants._BloomMipDown[0], desc, FilterMode.Bilinear); cmd.GetTemporaryRT(ShaderConstants._BloomMipUp[0], desc, FilterMode.Bilinear); Blit(cmd, source, ShaderConstants._BloomMipDown[0], bloomMaterial, 0);  首先进行模糊前预处理，其中包含降采样和提取亮部信息。\n #if _BLOOM_HQ  float texelSize = _SourceTex_TexelSize.x; half4 A = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(-1.0, -1.0)); half4 B = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(0.0, -1.0)); half4 C = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(1.0, -1.0)); half4 D = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(-0.5, -0.5)); half4 E = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(0.5, -0.5)); half4 F = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(-1.0, 0.0)); half4 G = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv); half4 H = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(1.0, 0.0)); half4 I = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(-0.5, 0.5)); half4 J = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(0.5, 0.5)); half4 K = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(-1.0, 1.0)); half4 L = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(0.0, 1.0)); half4 M = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + texelSize * float2(1.0, 1.0)); half2 div = (1.0 / 4.0) * half2(0.5, 0.125); half4 o = (D + E + I + J) * div.x; o += (A + B + G + F) * div.y; o += (B + C + H + G) * div.y; o += (F + G + L + K) * div.y; o += (G + H + M + L) * div.y; half3 color = o.xyz; #else  half3 color = SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv).xyz; #endif  降采样为了减少后续模糊的采样的性能压力，由于对画质有不同的要求，所以会有High Quality Filtering（后续简称HQ）的选项。 可以看出，在正常状态下直接采样，然后利用纹理的双向二次插值来平滑。 而开启HQ后，将会对原始纹理进行一次Blur处理，这样效果会更好，随之而来的是性能开销也会更大。\n  接下来就是gaussian pyramid，这是降采样的高斯模糊算法。\n int lastDown = ShaderConstants._BloomMipDown[0]; for (int i = 1; i \u0026lt; mipCount; i++) { tw = Mathf.Max(1, tw \u0026gt;\u0026gt; 1); th = Mathf.Max(1, th \u0026gt;\u0026gt; 1); int mipDown = ShaderConstants._BloomMipDown[i]; int mipUp = ShaderConstants._BloomMipUp[i]; desc.width = tw; desc.height = th; cmd.GetTemporaryRT(mipDown, desc, FilterMode.Bilinear); cmd.GetTemporaryRT(mipUp, desc, FilterMode.Bilinear); Blit(cmd, lastDown, mipUp, bloomMaterial, 1); Blit(cmd, mipUp, mipDown, bloomMaterial, 2); lastDown = mipDown; }  每次循环，纹理都会降到原来的1/4，这样的好处是可以通过采样的双向二次插值来代替部分卷积计算。 然后采用横向和纵向分别做高斯模糊的方式（常见的优化手段，通过拆分来减少采样次数）。\n // FragBlurH() // 9-tap gaussian blur on the downsampled source half3 c0 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(texelSize * 4.0, 0.0))); half3 c1 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(texelSize * 3.0, 0.0))); half3 c2 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(texelSize * 2.0, 0.0))); half3 c3 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(texelSize * 1.0, 0.0))); half3 c4 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv )); half3 c5 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(texelSize * 1.0, 0.0))); half3 c6 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(texelSize * 2.0, 0.0))); half3 c7 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(texelSize * 3.0, 0.0))); half3 c8 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(texelSize * 4.0, 0.0))); half3 color = c0 * 0.01621622 + c1 * 0.05405405 + c2 * 0.12162162 + c3 * 0.19459459 + c4 * 0.22702703 + c5 * 0.19459459 + c6 * 0.12162162 + c7 * 0.05405405 + c8 * 0.01621622; // FragBlurV() // Optimized bilinear 5-tap gaussian on the same-sized source (9-tap equivalent) half3 c0 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(0.0, texelSize * 3.23076923))); half3 c1 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv - float2(0.0, texelSize * 1.38461538))); half3 c2 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv )); half3 c3 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(0.0, texelSize * 1.38461538))); half3 c4 = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv + float2(0.0, texelSize * 3.23076923))); half3 color = c0 * 0.07027027 + c1 * 0.31621622 + c2 * 0.22702703 + c3 * 0.31621622 + c4 * 0.07027027;  可以看出来，横向采样了9个点，而纵向则只采样5个点。这是因为横向的输入纹理是原纹理，而到纵向时，输入纹理是已经降分辨率的纹理，由于降采样已经对纵向进行了一次平均计算（双向二次插值）,所以只需要5个点也能达到模糊效果。\n // Upsample (bilinear by default, HQ filtering does bicubic instead for (int i = mipCount - 2; i \u0026gt;= 0; i--) { int lowMip = (i == mipCount - 2) ? ShaderConstants._BloomMipDown[i + 1] : ShaderConstants._BloomMipUp[i + 1]; int highMip = ShaderConstants._BloomMipDown[i]; int dst = ShaderConstants._BloomMipUp[i]; cmd.SetGlobalTexture(ShaderConstants._SourceTexLowMip, lowMip); Blit(cmd, highMip, BlitDstDiscardContent(cmd, dst), bloomMaterial, 3); } half3 Upsample(float2 uv) { half3 highMip = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTex, sampler_LinearClamp, uv)); #if _BLOOM_HQ \u0026amp;\u0026amp; !defined(SHADER_API_GLES)  half3 lowMip = DecodeHDR(SampleTexture2DBicubic(TEXTURE2D_X_ARGS(_SourceTexLowMip, sampler_LinearClamp), uv, _SourceTexLowMip_TexelSize.zwxy, (1.0).xx, unity_StereoEyeIndex)); #else  half3 lowMip = DecodeHDR(SAMPLE_TEXTURE2D_X(_SourceTexLowMip, sampler_LinearClamp, uv)); #endif  return lerp(highMip, lowMip, Scatter); }  非HQ状态下，每次升采样都会用highMip(n+1)和lowMip(n)进行一次插值混合，混合比例就是Scatter值，这样能控制模糊的散射程度。 在HQ状态下，一样是使用highMip和lowMip进行混合，唯一的不同就是获取lowMip是使用了双向三次插值来进行采样。这样获取的颜色值会进一步平滑，但随之而来的就是性能消耗也随之提升。\n 性能优化 简单优化  根据上面源码分析可知，开了HQ性能会下降，HQ首次缩放时会对原图（全屏尺寸）做了一次模糊（单个像素做13次采样），升采样阶段又会调用SampleTexture2DBicubic做了双向三次插值计算，这两部分额外的采样和计算导致了开启HQ后耗时增加。\n  另外URP Bloom在升降采样过程中，默认的缩放次数其实比较高，也就是Blit次数较多，按照2400*1080的尺寸，迭代次数为9次，mip为8（8 = 9 - 1，默认忽略一次）， 按Prefilter（1次）、降采样（7次*2）、升采样（7次），默认一共需要做22次Blit。而我们知道移动端对于处理Blit其实也有耗时，而且当纹理小的一定程度时，对于Blur的影响将会减少。根据游戏画面影响程度，笔者将Skip iterations设为6，mip为3(3 = 9 - 6)，Blur的次数也就降为2，而Blit的次数也减少到7次。\n 最后在小米9测出来优化前后影响（由于受到发热降频影响，数据可能跟实际有少许出入）：\n   描述 帧率 耗时     开启HQ、没有限制迭代次数 23 43ms   关闭HQ、没有限制迭代次数 25 40ms   关闭HQ、限制到两次 26 38ms     可以看出，在经过调整参数来优化后，整体的耗时能减少5ms，而效果并没有太大的差别。\n 粗暴的对比一下优化前后的Sample次数，就能知道为什么能减少那么耗时了（N为屏幕尺寸像素数量，T为迭代次数）：\n Prefilter：  关闭HQ：$N$ 开启HQ：$P = 13 * N$   DownHorizontal：  $DH = 9 * (\\frac{1}{4}N + \\frac{1}{16}N + \\frac{1}{64}N + \u0026hellip;) \\Rightarrow DH = 9 * \\frac{1 - (\\frac{1}{4})^T}{3}N $   DownVertical：  $DV = 5 * (\\frac{1}{16}N + \\frac{1}{64}N + \\frac{1}{256}N + \u0026hellip;) = \\Rightarrow DH = 5 * \\frac{1}{4} * \\frac{1 - (\\frac{1}{4})^T}{3}N $   Up：  关闭HQ：$UP = (\\frac{1}{4}N + \\frac{1}{16}N + \\frac{1}{64}N + \u0026hellip;) \\Rightarrow DH = \\frac{1 - (\\frac{1}{4})^T}{3}N $ 开启HQ：$UP = 4 * (\\frac{1}{4}N + \\frac{1}{16}N + \\frac{1}{64}N + \u0026hellip;) \\Rightarrow DH = 4 * \\frac{1 - (\\frac{1}{4})^T}{3}N $       描述 Blit次数 采样次数     开启HQ、没有限制迭代次数 22 17.74971*N   关闭HQ、没有限制迭代次数 22 4.74977*N   关闭HQ、限制到两次 7 4.515625*N    Dual Blur算法  Dual (Kawase) Blur算法跟URP的Bloom算法都采用了降采样、升采样来优化模糊算法，唯一的不同是URP使用的是高斯模糊加降采样，而Dual是采用Kawase加降采样。 Dual从算法来说就是DownHorizontal和DownVertical合并为一个，只降采样中间和四个角落顶点。升采样则对中心周边八个顶点进行采样。 对比来说，两者的采样次数其实相差无几，但Blit次数可以减少1/3左右。综合来说两者性能实际上差别是有的，但没有预想中那么大。\n","ref":"/blog/urp/postprocess_bloom/"},{"title":"xlua Delegate 泄漏检查","date":"","description":"xlua Delegate 泄漏检查","body":"排查和定位xLua中Delegate没有销毁的情况\n前言  笔者在开发项目时，发现在xLua Dispose时总是会有DelegateBridge没有移除的情况，这有很多原因导致的，其中除了有之前讨论过的《UnityEvent引起的内存泄漏》，也不乏一些日常写业务逻辑疏忽导致的。但无论哪种情况，在销毁xLua虚拟机前调用多次GC释放，而仍然存在的DelegateBridge就代表原来Lua逻辑有未正常销毁的情况，这体现其背后可能存在内存泄漏等问题，而本篇文章就是研究如何去找到没有释放所引用的Lua代码位置。\n InvalidOperationException: try to dispose a LuaEnv with C# callback! 源码方案  xLua在虚拟机销毁前，会先调用多次GC，然后再释放ObjectTranslator的对象。\n //调用多次GC是为了让Lua和C#之间没有引用关系的对象得以释放。 public void Dispose() { FullGc(); System.GC.Collect(); System.GC.WaitForPendingFinalizers(); Dispose(true); System.GC.Collect(); System.GC.WaitForPendingFinalizers(); }  而在Dispose ObjectTranslator时，会释放掉所有的DelegateBridge。在释放每一个DelegateBridge都会先确认是否存活（IsAlive），如果有一个则会抛出异常。\n if (!translator.AllDelegateBridgeReleased()) { throw new InvalidOperationException(\u0026quot;try to dispose a LuaEnv with C# callback!\u0026quot;); }  由于信息有限，所以并不知道是哪个对象哪句代码所注册Delegate，因此需要扩展对应的检查。\n 输出Delegate信息  首先较为简单的方案就是把没有释放的Delegate信息输出出来，其中包括Method的名称、类型等。\n //Class DelegateBridgeBase public string GetMessage() { StringBuilder builder = new StringBuilder(); if(bindTo != null) { foreach (var item in bindTo) { if (item.Value != null) { builder.AppendFormat(\u0026#34;key:{0} methodName:{1} FullyQualifiedName:{2}\\n\u0026#34;, item.Key, item.Value.Method.Name, item.Value.Method.DeclaringType.Name); } } } else if(firstValue != null) { builder.AppendFormat(\u0026#34;key:{0} methodName:{1} FullyQualifiedName:{2}\\n\u0026#34;, firstKey, firstValue.Method.Name, firstValue.Method.DeclaringType.Name); } return builder.ToString(); } //Class ObjectTranslator public bool AllDelegateBridgeReleased(IntPtr L, ref string message) { StringBuilder builder = new StringBuilder(); bool result = true; foreach (var kv in delegate_bridges) { if (kv.Value.IsAlive) { builder.AppendLine(delegateBridgeBase.GetInfo()); } } message = builder.ToString(); return result; }  这样就可以获取到所有没有释放的Delegate信息了。\n debug.traceback  虽然获取Delegate信息能找到一些蛛丝马迹，但其实还远远不够，因为相同类型的Delegate实在太多了，而且如果是反射Warp的方式，类似methodName:__Gen_Delegate_Imp7 FullyQualifiedName:XLuaGenDelegateImpl0的信息一点用都没有。这时候就需要增加其他方法来获取更精确的信息了，例如获取Lua堆栈信息。\n  lua有一个debug.traceback()的API是可以获取到当前Lua逻辑中的堆栈信息的。\n //在C#端增加以下逻辑 private string GetStack(RealStatePtr L) { var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;traceback\u0026#34;); LuaAPI.xlua_pgettable(L, -2); var index = LuaAPI.lua_pcall(L, 0, 1, 0); string luaStack = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStack; }  尝试在ObjectTranslator.CreateDelegateBridge()调用，输出日志：\n stack traceback: [C]:in local 'loadFun' Script/B:12: in field'Fun2' Script/A:32: in field'Fun1' ......  这样就可以在创建DelegateBridge时获取到调用的Lua代码堆栈，然后保存起来，等销毁时把没有释放的堆栈信息输出。\n //将原来的CreateDelegateBridge方法改成私有，把weakReference作为out结果返回。 private object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx, out WeakReference weakReference) { ... } //增加新的CreateDelegateBridge提供给外部调用 public object CreateDelegateBridge(RealStatePtr L, Type delegateType, int idx) { WeakReference weakReference = null; var stack = this.GetStack(L); var result = CreateDelegateBridge(L, delegateType, idx, out weakReference); if(weakReference != null) { int hash = weakReference.GetHashCode(); //利用weakReference的哈希值来作为key  bridgesReferenceInfos[hash] = stack; } return result; }  AllDelegateBridgeReleased和ReleaseLuaBase也需要根据weakReference.GetHashCode()处理（获取信息和释放），这里就不再赘述了。\n debug.getinfo  其实使用traceback已经能完美解决问题了，为什么还有下文呢？这是因为笔者在接入到项目后，发现项目变的很卡，特别是在创建模块（场景、界面）时。在一轮抽丝剥茧后，发现了debug.traceback是一个性能消耗巨大的API，在Editor下十次调用就有100ms，这即使在Editor下也是不可接受的。\n  所以在一轮查找后，笔者找到了debug.getinfo的方法来实现功能。\n -- 获取当前调用层级所在的lua文件路径 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).source -- 获取当前调用层级（代码堆栈）所在的行号 -- 1就是第一层 debug.getinfo(1, \u0026#34;l\u0026#34;).currentline  在C#侧增加了接口，替代了原来的GetStack()。\n private string GetInfo(RealStatePtr L, int maxLevel = 5) { luaStackBuffer.Clear(); var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;getinfo\u0026#34;); LuaAPI.xlua_pgettable(L, -2); for (int i = 0; i \u0026lt; maxLevel; i++) { LuaAPI.lua_pushvalue(L, -1); int level = i + 2; //1为C端，没必要输出  LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;S\u0026#34;); //参数  LuaAPI.lua_pcall(L, 2, 1, 0); if (LuaAPI.lua_isnil(L, -1)) //当前节点是nil，表明没有上一层  { LuaAPI.lua_pop(L, 1); break; } LuaAPI.xlua_pushasciistring(L, \u0026#34;source\u0026#34;); LuaAPI.xlua_pgettable(L, -2); string luaPath = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 2); LuaAPI.lua_pushvalue(L, -1); LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;l\u0026#34;); //参数  LuaAPI.lua_pcall(L, 2, 1, 0); LuaAPI.xlua_pushasciistring(L, \u0026#34;currentline\u0026#34;); LuaAPI.xlua_pgettable(L, -2); int line = LuaAPI.xlua_tointeger(L, -1); luaStackBuffer.AppendFormat(\u0026#34;{0}: {1}\\n\u0026#34;, luaPath, line); LuaAPI.lua_pop(L, 2); } LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStackBuffer.ToString(); } @Script/B: 12 @Script/A: 32  测试了一下性能，比traceback好一点，但也有80ms/10次。这也是万万不可接受的。 所以调试了其他方案，最后可以使用linedefined来替代currentline。linedefined与currentline不一样的地方就是，只能获取到当前function开始所在的行号，而不能获得代码精确的行号。\n -- 获取当前调用层级所在的lua文件路径 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).source -- 获取当前调用层级调用函数所在的行号 -- 1就是第一层 debug.getinfo(1, \u0026#34;S\u0026#34;).linedefined  修改原来的GetInfo()。\n private string GetInfo(RealStatePtr L, int maxLevel = 5) { luaStackBuffer.Clear(); var oldTop = LuaAPI.lua_gettop(L); int debug = LuaAPI.xlua_getglobal(L, \u0026#34;debug\u0026#34;); LuaAPI.xlua_pushasciistring(L, \u0026#34;getinfo\u0026#34;); LuaAPI.xlua_pgettable(L, -2); for (int i = 0; i \u0026lt; maxLevel; i++) { LuaAPI.lua_pushvalue(L, -1); int level = i + 2; //1为C端，没必要输出  LuaAPI.xlua_pushinteger(L, level); //参数  LuaAPI.xlua_pushasciistring(L, \u0026#34;S\u0026#34;); //参数  var index = LuaAPI.lua_pcall(L, 2, 1, 0); if(LuaAPI.lua_isnil(L, -1)) //当前节点是nil，表明没有上一层  { LuaAPI.lua_pop(L, 1); break; } LuaAPI.xlua_pushasciistring(L, \u0026#34;source\u0026#34;); LuaAPI.xlua_pgettable(L, -2); string luaPath = LuaAPI.lua_tostring(L, -1); LuaAPI.lua_pop(L, 1); LuaAPI.xlua_pushasciistring(L, \u0026#34;linedefined\u0026#34;); LuaAPI.xlua_pgettable(L, -2); int line = LuaAPI.xlua_tointeger(L, -1); luaStackBuffer.AppendFormat(\u0026#34;{0}: {1}\\n\u0026#34;, luaPath, line); LuaAPI.lua_pop(L, 2); } LuaAPI.lua_pop(L, 2); LuaAPI.lua_settop(L, oldTop); return luaStackBuffer.ToString(); } @Script/B: 5 @Script/A: 30  改进后的方案所得到的堆栈信息可能没有那么的准确（因为没有精确的堆栈行号），但有lua代码地址和函数名已经能大大缩小其范围，相对耗时（一百倍）来说，具有极高的性价比。 以下是三种方式的对比：\n    方案 耗时（ms/10次）     traceback 112   getinfo（精确行号） 83   getinfo（函数行号） 1    总结  在通过一系列测试，最后采用了debug.getinfo的方式来获取堆栈，并且采用一个消耗极低的方式获取到对应的函数行号，从而方便定位到问题的模块。如果想要更精确可以和debug.traceback结合处理，日常使用低耗版本监控，有需要定位时采用精确定位。\n","ref":"/blog/xlua/delegatememoryleak/"},{"title":"Unity URP issue","date":"","description":"URP的疑难杂症","body":"总结在URP项目中遇到的疑难杂症\n版本  URP: 10.10.1  URP合批失败 隐藏的Keywords导致的合批失败 问题描述：\n 开启了SRP Batch时，两个模型使用了相同的shader，并且使用相同的变体，但无法SRP合批。 在FrameDebugger中提示“SRP:Node use different shader keywords”，但使用中的keywords是一样的。  问题原因：\n 材质球中残留了关键字导致的，虽然在实际使用中并没有用到，但Unity会认为两者使用了不同变体，而不会让其合批。 例如创建了材质球，先使用shaderA（例如lit.shader），调整了自发光设置，材质就会多了_EMISSION关键字，然后再替换成shaderB（没有_EMISSION关键字），这样材质球就残留了对应的keyword，而实际上shaderB没有_EMISSION和对应的变体。  参考： SRP Batch竟然和RenderQueue有关，有解吗\n打包shader丢失Pass/Variant  打包出来的shader（安装包、ab包）会丢失掉Pass、Variant等。\n 问题描述：\n 打包出来的shader（安装包、ab包）会丢失掉LightMode为ShadowCaster的Pass。 检查了Shader并没有问题 Editor下运行没有问题 Editor下查看shader编译的文件没有问题  问题原因：\n UnityEditor.Rendering.Universal.ShaderPreprocessor在检测GraphicsSettings和QualitySettings中的PipelineAsset时，发现没有supportsMainLightShadows和supportsAdditionalLightShadows时，会剔除掉LightMode为ShadowCaster的Pass。  ShaderFeatures  记录shader特性的枚举值，可用于后续剔除Pass、Variants的枚举值\n    Feature 说明 条件     MainLight 主光源 一定激活   MainLightShadows 主光源阴影 supportsMainLightShadows   AdditionalLights 多光源 additionalLightsRenderingMode == LightRenderingMode.PerPixel   AdditionalLightShadows 多光源阴影 AdditionalLights \u0026amp;\u0026amp; supportsAdditionalLightShadows   VertexLighting 顶点光照 additionalLightsRenderingMode == LightRenderingMode.PerVertex   SoftShadows 软阴影 (MainLightShadows || AdditionalLightShadows) \u0026amp;\u0026amp; supportsSoftShadows   MixedLighting 混合光照 supportsMixedLighting   TerrainHoles 地形挖空 supportsTerrainHoles   DeferredShading 延迟渲染 renderingMode == RenderingMode.Deferred   DeferredWithAccurateGbufferNormals 高精度GBuffer法线纹理\n（延迟渲染） 所有Renderer.accurateGbufferNormals == true   DeferredWithoutAccurateGbufferNormals 非高精确GBuffer法线纹理\n（延迟渲染） 所有Renderer.accurateGbufferNormals == false   ScreenSpaceOcclusion 屏幕空间环境光遮蔽\n（SSAO） 任意Renderer激活ScreenSpaceAmbientOcclusion    StripUnusedFeatures  主要为剔除没有使用的特性，剔除情况如下：\n    Keyword 说明 剔除条件     _MAIN_LIGHT_SHADOWS 主光源阴影 ShaderFeatures.MainLightShadows未激活   _MAIN_LIGHT_SHADOWS_CASCADE 主光源级联阴影 ShaderFeatures.MainLightShadows未激活   _SHADOWS_SOFT 软阴影 ShaderFeatures.SoftShadows未激活   _MIXED_LIGHTING_SUBTRACTIVE 混合光照相减 ShaderFeatures.MixedLighting未激活   LIGHTMAP_SHADOW_MIXING 光照贴图混合 ShaderFeatures.MixedLighting未激活   SHADOWS_SHADOWMASK 阴影遮罩 ShaderFeatures.MixedLighting未激活   _ADDITIONAL_LIGHT_SHADOWS 多光源阴影 ShaderFeatures.AdditionalLightShadows或ShaderFeatures.AdditionalLightShadows未激活   _DEFERRED_ADDITIONAL_LIGHT_SHADOWS 多光源阴影（延迟渲染） ShaderFeatures.AdditionalLightShadows未激活   _ADDITIONAL_LIGHTS 多光源（逐像素） ShaderFeatures.AdditionalLights未激活   _ADDITIONAL_LIGHTS_VERTEX 多光源（逐顶点） ShaderFeatures.VertexLighting未激活   _SCREEN_SPACE_OCCLUSION 屏幕空间环境光遮蔽 ShaderFeatures.ScreenSpaceOcclusion未激活    StripInvalidVariants  主要为剔除不合法的shader变体，剔除情况如下：\n    Keyword 说明 剔除条件     _MAIN_LIGHT_SHADOWS_CASCADE 主光源的级联阴影 _MAIN_LIGHT_SHADOWS未激活   _ADDITIONAL_LIGHT_SHADOWS 多光源阴影 _ADDITIONAL_LIGHTS未激活   _DEFERRED_ADDITIONAL_LIGHT_SHADOWS 多光源阴影（延迟渲染） _ADDITIONAL_LIGHTS未激活   _SHADOWS_SOFT 软阴影 _MAIN_LIGHT_SHADOWS、_MAIN_LIGHT_SHADOWS、_ADDITIONAL_LIGHTS都未激活    StripUnsupportedVariants  主要为剔除不支持的shader变体，剔除情况如下：\n    Keyword 说明 剔除条件     DIRLIGHTMAP_COMBINED 烘培开启方向图 LIGHTMAP_ON未激活   _USE_DRAW_PROCEDURAL DrawProcedural GLES20   _MAIN_LIGHT_SHADOWS_CASCADE 主光源的级联阴影 GLES20   _DETAIL_MULX2 两倍的Detail纹理 GLES20   _DETAIL_SCALED 自定义缩放的Detail纹理 GLES20   _CLEARCOAT 透明图层（车漆）效果 GLES20   _CLEARCOATMAP 透明图层（车漆）效果纹理 GLES20    StripUnusedPass  主要为剔除没有在用的Pass，剔除情况如下：\n    Pass(LightMode) 说明 剔除条件     Meta 生成Lightmapping的Pass 一定剔除   ShadowCaster 阴影捕获Pass ShaderFeatures.MainLightShadows、ShaderFeatures.AdditionalLightShadows未激活    Other  其他剔除情况，剔除情况如下：\n    Keyword 说明 剔除条件     _ALPHATEST_ON 启动AlphaTest Lit.shader,并且ShaderFeatures.TerrainHole未激活       Pass(Name) 说明 剔除条件     GBuffer GBuffer的Pass ShaderFeatures.DeferredShading未激活   GBuffer GBuffer的Pass ShaderFeatures.DeferredWithAccurateGbufferNormals激活\n_GBUFFER_NORMALS_OCT未激活   GBuffer GBuffer的Pass ShaderFeatures.DeferredWithoutAccurateGbufferNormals激活\n_GBUFFER_NORMALS_OCT激活   ","ref":"/blog/urp/issue/"},{"title":"HLSL","date":"","description":"HLSL","body":"HLSL的一些基础机制和常用函数\n常用函数 基本运算    名称 用例 描述 最小着色器模型 备注     max max(x, y) 返回x和y中的最大值 1    min min(x, y) 返回x和y中的最小值 1    mul mul(x, y) 返回x和y相乘的结果 1    abs abs(x) 返回x的绝对值 1    round round(x) 返回x的四舍五入结果 1    sqrt sqrt(x) 返回x的平方根 1    rsqrt rsqrt(x) 返回x的平方根的倒数 1    degrees degrees(x) 将弧度x转换为角度 1    redians redians(x) 将角度x转换为弧度 1    noise noise(x) 使用Perlin噪声算法生成-1到1之间的随机数 1    rcp rcp(x) 对分量求倒数 5     幂函数\u0026amp;指数函数\u0026amp;对数函数    名称 用例 描述 最小着色器模型 备注     pow pow(x, y) 返回x的y次幂 1    exp exp(x) 返回e的x次幂 1    exp2 exp2(x) 返回2的x次幂 1    ldexp ldexp(x, exp) 返回x和2的exp次方的乘积 1    log log(x) 返回以e为底，x的对数 1    log10 log10(x) 返回以10为底，x的对数 1    log2 log2(x) 返回以2为底，x的对数 1    frexp frexp(x, out exp) 将浮点数x分解为尾数和指数：$x=ret*2^{exp}$，函数返回尾数，exp返回指数 1     三角函数和双曲函数    名称 用例 描述 最小着色器模型 备注     sin sin(x) 返回x弧度的正弦 1    cos cos(x) 返回x弧度的余弦 1    tan tan(x) 返回x弧度的正切 1    sincos sincos(x, out s, out c) 返回x弧度的正弦和余弦 1    asin asin(x) 返回x弧度的反正弦 1    acos acos(x) 返回x弧度的反余弦 1    atan atan(x) 返回x弧度的反正切 1    atan2 atan2(y, x) 返回y/x的反正切值 1    sinh sinh(x) 返回x弧度的双曲正弦值，$\\frac{e^x-e^{-x}}{2}$ 1    cosh cosh(x) 返回x弧度的双曲余弦值，$\\frac{e^x+e^{-x}}{2}$ 1    tanh tanh(x) 返回x弧度的双曲正切值，$\\frac{e^x-e^{-x}}{e^x+e^{-x}}$ 1     数据范围    名称 用例 描述 最小着色器模型 备注     ceil ceil(x) 返回x的向上取整 1    floor floor(x) 返回x的向下取整 1    step step(x, y) 如果x小于等于y则返回1，否则返回0 1    saturate saturate(x) 将x限定在[0, 1] 1    clamp clamp(x, min, max) 将x限制在[min, max] 1    fmod fmod(x, y) 返回x对y取余的余数 1    frac frac(x) 返回x的小数部分 1    modf modf(x, out ip) 将值x分为小数和整数部分，每个部分的符号与x相同，ip返回整数部分，函数返回小数部分 1    lerp lerp(x, y, s) 使用s在x和y之间线性插值：$x+s(y-x)$ 1    smoothstep smoothstep(min, max, x) 如果x在[min，max]范围内，则返回介于0和1之间的平滑Hermite插值，如果x小于min则返回0，如果x大于max则返回1 1     类型判断    名称 用例 描述 最小着色器模型 备注     all all(x) 如果x的所有分量都不为0，则返回true；否则返回false 1    clip clip(x) 如果x小于0，则丢弃当前像素 1    sign sign(x) 如果x小于0，返回-1，如果x等于0，返回0，如果x大于0，返回1 1    isinf isinf(x) 如果x为正无穷或负无穷，返回true，否则返回false 1    isfinite isfinite(x) 与isinf相反 1    isnan isnan(x) 如果x为NAN，则返回true，否则返回false 1     向量和矩阵    名称 用例 描述 最小着色器模型 备注     length length(v) 返回向量v的长度 1    normalize normalize(v) 返回v的归一化向量 1    distance distance(a, b) 返回a和b之间的距离 1    dot dot(a, b) 返回a和b的点积 1    cross cross(a, b) 返回a和b的叉积 1    determinant determinant(m) 返回矩阵m的行列式的值 1    transpose transpose(m) 返回m的转置 1     光线运算    名称 用例 描述 最小着色器模型 备注     reflect reflect(i, n) 以i为入射方向，n为法线的反射光 1    refrect refrect(i, n, ri) 以i为入射方向，n为法线方向，ri为折射率的折射光 1    lit lit(n_dot_l, n_dot_h, m) 输入归一化的法线和光向量的点积，半角向量和法线的点积，高光指数，返回光照向量（环境光，漫反射，高光，1） 1    faceforward faceforward(n, i, ng) 返回面向视图方向的曲面法向量 1     纹理查找    名称 用例 描述 最小着色器模型 备注     tex1D tex1D(s, t) 返回s在t处的值 1    tex1D tex1D(s, t, ddx, ddy) 使用偏导数对2D纹理进行采样以选择Mip级别 1    tex1Dproj tex1Dproj(s, t) 将xyz除以w，然后进行纹理查找 1    tex1Dlod tex1Dlod(s, t) 使用lod查找纹理s在t.w处的值 1    tex1Dbias tex1Dbias(s, t) 将t.w决定的某个Mip层偏置后的纹理查找 1    tex1Dgrad tex1Dgrad(s, t, ddx, ddy) 使用微分并指定Mip层的纹理查找 1    ","ref":"/blog/shader/hlsl/"},{"title":"YooAsset插件","date":"","description":"学习YooAsset插件和分析","body":"YooAsset是一个Unity资源系统，集合资源打包、分包、更新、加载等。\n信息  官网：YooAsset 版本：1.4.2 源码：https://github.com/tuyoogame/YooAsset  构建 收集  检测配置合法性 收集所有Package的资源（遍历所有的Group，然后再遍历所有的Collector）  AssetBundleCollectorSettingData.Setting.GetPackageAssets(buildMode, packageName); 剔除未被引用的依赖资源 录入所有收集器收集的资源 录入相关依赖的资源 记录关键信息 填充主动收集资源的依赖列表 计算完整的资源包名 移除不参与构建的资源 构建资源包  Runtime 初始化  YooAssets初始化。  创建驱动器YooAssetsDriver用于调度系统的Update 创建远程调试器RemoteDebuggerInRuntime用于调试加载情况 初始化异步系统OperationSystem    // 初始化资源系统 YooAssets.Initialize();  创建Package。  创建package 设置为默认的package    // 创建默认的资源包 var package = YooAssets.CreateAssetsPackage(\u0026#34;DefaultPackage\u0026#34;); // 设置该资源包为默认的资源包，可以使用YooAssets相关加载接口加载该资源包内容。 YooAssets.SetDefaultAssetsPackage(package);  初始化资源系统（Editor模拟）  EditorSimulateModeHelper.SimulateBuild会调用AssetBundleSimulateBuilder构建资源清单 再把Parameters传入package进行资源清单初始化 package根据mode创建EditorSimulateModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 EditorSimulateModeImpl进行初始化。 调用EditorSimulateModeInitializationOperation加载清单，并且设置清单到EditorSimulateModeImpl    var createParameters = new EditorSimulateModeParameters(); createParameters.SimulatePatchManifestPath = EditorSimulateModeHelper.SimulateBuild(packageName); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（单机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建OfflinePlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 OfflinePlayModeImpl进行初始化。 调用OfflinePlayModeInitializationOperation  获取Package版本号 加载清单。 设置清单到OfflinePlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（联机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建HostPlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 HostPlayModeImpl进行初始化。 调用HostPlayModeInitializationOperation  获取补丁水印（安装包版本号和补丁版本号），如果水印不一致，则清空缓存目录。 获取缓存目录Package版本号，如果存在，则加载和解析缓存目录清单 在缓存目录清单加载失败（版本号不对、hash值不对、清单不存在等），则获取安装包Package版本号，并且把版本号和清单写入到缓存目录。最后再加载安卓包清单。 设置清单到HostPlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters); 更新 //更新Package版本信息 var operation = package.UpdatePackageVersionAsync(); yield return operation; //更新Package资源清单 package.UpdatePackageManifestAsync(operation.PackageVersion); //创建下载器 var downloader = YooAssets.CreatePatchDownloader(downloadingMaxNum, failedTryAgain);  只有联机模式才有更新系统\n  HostPlayModeUpdatePackageVersionOperation请求远端版本号信息。 HostPlayModeUpdatePackageManifestOperation更新补丁清单。  加载Cache清单，判断版本号是否为最新 当版本号不是最新时，下载远端清单到Cache目录。 重新加载Cache清单。 校验清单的资源包，将正确的补丁放入CacheSystem   PatchDownloaderOperation下载补丁（不包含已有缓存、内置资源） 清除过期的补丁文件  扩展  由于代码比较简单易懂，并且框架解耦的较好，扩展性比较好。\n 更新  目前热更方式为CDN获取版本信息，可以增加后台模式，以适应后台更新的方案。\n //AssetsPackage.InitializeAsync()  if (...) { ... } else if (_playMode == EPlayMode.ServerPlayMode) { var serverPlayModeImpl = new ServerPlayModeImpl(); ... } 疑问  覆盖安装情况下，资源是否正常？   会通过水印判断安装包是否有变更，如果安装包变更了，则清除Cache目录\n  断点续传是否会出现缺漏的问题？   每次会对文件计算hash值进行校验。没有缺漏问题。\n  热更是否要在Cache增加一份副本？   安装包的内容只有一份。热更时会使用IsBuildinPatchBundle进行判断剔除。\n  CDN需要全量补丁？   发布没有差异补丁的概念，所以都是全量补丁\n 对比 Addressable  Group与Addressable的差不多，都是用于资源分组使用 没有了自定义Entry的概念，取而代之增加了Collector对资源进行收集设置。 收集器的地址保存的是字符串，移动文件夹时会出现丢失的问题。 获取Entry地址和寻址信息需要手动拼写 Tags只能对Group设置，无法只对Collector和Entry设置 Group相对于Addressable去除了很多独立设置，无法对AB进行独立设置压缩方式，命名方式等 地址和寻址两套方式可以选择使用 支持旧的构建模式和SBP模式 配置有Json和Bytes两种，bytes只是简单序列化了，并没有做压缩处理。 Group之上还增加了Package的概念，用于构建时可以分情况构建。 有多种构建模式，例如演练和模拟模式可以方便调试 有调试器和报告查看工具 更新地址需要运行设置。 支持构建原文件 Editor模拟模式，需要每次运行时调用构建，需要生成列表清单。目前只有收集到的资源需要生成清单，理论上速度应该不慢。 构建时才会检查资源是否重复收集 Operation采用的是Update来处理，没有采用协程。Operation通过状态来去区分任务，需要等待子Operation完成来改变状态。 有加密接口。Android采用加密只能使用偏移头文件的方式，如果采用其他方式，将无法加载SteamingAsset目录资源。  问题  在AssetBundleFileLoader加载失败时会调用CacheSystem.DiscardFile清除，但实际上会清除整个Cache目录！！！ 缺少SpriteAtlas打包 加载场景时，会自动清空资源引用计数，导致对象池中的对象丢失资源引用。 只有在加载场景时才会检测资源引用计数  优点  代码结构较为简单，容易扩展 多线程下载 多线程校验文件 开箱即用  缺点  每次都需要校验文件，全量计算文件Hash，数量一多会比较耗时 收集器需要填写配置，有资源需要特殊处理时，比较难处理 补丁为全量资源上传CDN，如果改成增量补丁，并且按版本分开目录，需要扩展新的mode。 寻址的Key值无法自定义，相同文件名会出现Key重复的问题。 ","ref":"/blog/plugin/yooasset/"},{"title":"构建iOS包","date":"","description":"构建iOS包","body":"在构建iOS包时，遇到了挺多问题，因此记录下来，以备不时之需\n环境  Unity:2020.3.26f1 XCode:13.2.1(13C100)  导出xcodeproj  使用UnityEditor.BuildPipeline.BuildPlayer构建即可，然后就导出xcodeproj。\n 设置xcodeproj配置 PBXProject工具  PBXProject是Unity用于修改导出的xcode工程参数的工具。 P.S.需要安装iOSSupport\n //初始化PBXProject UnityEditor.iOS.Xcode.PBXProject project = new UnityEditor.iOS.Xcode.PBXProject(); string projectName = UnityEditor.iOS.Xcode.PBXProject.GetPBXProjectPath(projectPath); //使用BuildPlayer的构建目录地址获取PBX项目地址 project.ReadFromFile(projectName); //读取项目配置文件  //修改配置的逻辑....  project.WriteToFile(projectName); //把修改后的配置写入  添加引用库  某些第三方SDK需要加入引用的库。 例如Bugly，需要增加以下库：\n  libz.tbd libc++.tbd Security.framework SystemConfiguration.framework JavaScriptCore.framework  然后可以使用AddFrameworkToProject进行添加这些库。\n//先获取UnityFramework的targetGUID，用于指定需要添加库的配置 string frameworkGUID = project.GetUnityFrameworkTargetGuid(); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libz.tbd\u0026#34;, false); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libc++.tbd\u0026#34;, false); ... 设置属性  需要设置某些构建属性时，需要用到SetBuildProperty方法。 例如关闭Bitcode\n //获取UnityMain和UnityFramework的targetGUID，用于指定需要修改属性的配置 string mainTargetGUID = project.GetUnityMainTargetGuid(); string frameworkGUID = project.GetUnityFrameworkTargetGuid(); //Bitcode需要都关闭 project.SetBuildProperty(mainTargetGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode project.SetBuildProperty(frameworkGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode  //发布版时，需要修改签名类型 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY[sdk=iphoneos*]\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态  project.SetBuildProperty(mainTargetGUID, \u0026#34;PROVISIONING_PROFILE_SPECIFIER\u0026#34;, m_Setting.ProvisioningProfileName); //需要设置ProvisioningProfile ExportOptions  Method：方式  app-store enterprise ad-hoc development   BundleID：包名 ProvisioningProfile：证书名字 TeamID：证书的TeamID Certificate：签名证书  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34; -//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;compileBitcode\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;destination\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;export\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;manageAppVersionAndBuildNumber\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;method\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${METHOD}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;provisioningProfiles\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;${BUNDLE_ID}\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${PROVISIONING_PROFILE}\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;signingCertificate\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${CERTIFICATE}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;signingStyle\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;manual\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;stripSwiftSymbols\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;teamID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${TEAM_ID}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;thinning\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026amp;lt;none\u0026amp;gt;\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 隐私清单  参考：https://blog.csdn.net/qq_37672438/article/details/137133195 参考：https://juejin.cn/post/7365723860997390372\n 错误处理 环境错误  The data couldn’t be read because it isn’t in the correct format\n  https://www.jianshu.com/p/103f414fa870 https://stackoverflow.com/questions/58272706/error-exportarchive-the-data-couldn-t-be-read-because-it-isn-t-in-the-correct\n sqlite3环境问题导致的报错，执行如下指令即可：\ngem list | grep sqlite3 gem install sqlite3 --platform=ruby rvm use system --default 类型错误  Error Domain=IDEProfileLocatorErrorDomain Code=4 \u0026ldquo;No \u0026ldquo;iOS App Development\u0026rdquo; profiles for team \u0026lsquo;*****\u0026rsquo; \u0026hellip;..\n 确保provisioning profile中填入的类型正确\n授权问题  \u0026ldquo;error: \u0026ldquo;Unity-iPhone\u0026rdquo; requires a provisioning profile. Select a provisioning profile in the Signing \u0026amp; Capabilities editor. (in target \u0026lsquo;Unity-iPhone\u0026rsquo; from project \u0026lsquo;Unity-iPhone\u0026rsquo;)\u0026rdquo;\n 一般是没有登录provisioning profile对应的开发者账号，或者是没有安装provisioning profile对应的Capabilities\n","ref":"/blog/publish/buildios/"},{"title":"UnityEvent引起的内存泄漏","date":"","description":"UnityEvent引起的内存泄漏","body":"一个由UnityEvent缓存机制引起的内存泄漏问题\n前言  笔者在开发项目时，发现在xLua Dispose时总是会有DelegateBridge没有移除的情况，而排查了一轮，发现就算是一个简单界面也会出现这种情况。 后来经过一轮排查，发现Button的点击事件触发了，就会出现无法移除DelegateBridgeBase，然后翻看了xLua的issue（xLua#139）发现很早就有这个问题，而且也有人提供了解决方案。\n 问题原因 首先这个问题归根到底是由UnityEvent的缓存机制导致：\n Unity在设计UnityEvent时，为其加了缓存机制，也就是上一次调用过的Calls会缓存起来，然后在增加/删除callback时，对缓存设置脏标记。然后在下一次触发事件时，在有变动时才会重新生成Calls。\n //这里截取Unity 2020.3.x版本UnityEvent.CS \u0026lt;InvokableCallList\u0026gt;类的片段 //与Issue中的版本代码有点差异，但机制大致相同 public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); m_NeedsUpdate = true; } ... public List\u0026lt;BaseInvokableCall\u0026gt; PrepareInvoke() { if (m_NeedsUpdate) { m_ExecutingCalls.Clear(); m_ExecutingCalls.AddRange(m_PersistentCalls); m_ExecutingCalls.AddRange(m_RuntimeCalls); m_NeedsUpdate = false; } return m_ExecutingCalls; } 那么问题就来，由于在每次触发（Invoke）事件前，才会重新生成Calls,就算之前已经对callback进行了Remove了，只要没有调用，缓存还会保留已经移除的函数。\n问题危害 正常流程 在xLua框架中，lua需要监听C#的事件，需要把function(lua)设置到LUA_REGISTRYINDEX，并且把引用给到C#，C#再生成Delegate，然后把Delegate和引用封装到DelegateBridge(C#)对象中。 这样，只要把此Delegate绑定到对应的事件中，当事件触发后，就会调用此Delegate，再由DelegateBridge根据引用获取并调用function(lua)。\n由于DelegateBridge只以弱引用的方式保存，所以当移除事件后，Delegate只与对应的DelegateBridge有引用关系，所以在下一轮GC即可销毁掉DelegateBridge，从而接触对应引用的function(lua)（将function从LUA_REGISTRYINDEX中释放掉）。\n这个时候，lua gc就可以把function以及对应upvalue销毁（假设没有任何其他对象引用）。\n泄漏情况 上述都是function(lua)与Delegate绑定和释放的正常流程。而在UnityEvent内存泄漏的情况下，又会变得怎样呢？\n这里我们加入比较常见的情景：\nlocal item = {} item.name = \u0026#34;name\u0026#34; item.button = .... --获取Button对象 item.button.onClick:AddListener(function () print(item.name) end) ...--一顿操作 item.button.onClick:RemoveAllListeners() 根据前文，如果我们在移除前触发了点击事件，那么UnityEvent就会缓存了Delegate，从而保留了DelegateBridge。这个时候唯一办法就是等button释放掉，顺带把UnityEvent也释放，这样DelegateBridge才能给GC回收。\n但是，我们button却给lua的table对象引用了，而这个table又是闭包函数的upvalue值，而最糟糕的是，这个闭包函数却给DelegateBridge引用了（通过LUA_REGISTRYINDEX）。所以，这个table以及button(userdata)都无法给GC回收。\n那么现在就形成了一个死结，而这个死结只要有任何一处解开就可以完全解开了，但现在处处都无法解开。\n解决方案 调用Invoke 根据xLua#139，可以在RemoveAllListener之后，手动调用一次Invoke，这样就可以清除掉Calls。\n 但此方法有个问题，假设Button在Inspector界面上绑定了持久化事件，就会多触发一次事件，可能会有意想不到的bug出现。所以不建议使用\n 反射 根据xLua#139，其实可以通过反射去释放掉UnityEvent中的缓存。\nprivate static MethodInfo prepareInvoke; public static void ReleaseUnusedListeners(this UnityEventBase unityEventBase) { if (prepareInvoke == null) { BindingFlags flag = BindingFlags.Instance | BindingFlags.NonPublic; Type type = unityEventBase.GetType(); prepareInvoke = type.GetMethod(\u0026#34;PrepareInvoke\u0026#34;, flag); } prepareInvoke.Invoke(unityEventBase, null); } ... item.button.onClick:RemoveAllListeners() item.button.onClick:ReleaseUnusedListeners()  笔者在issue基础上进行了优化。 此方案副作用小，只要不忘记调用，就可以释放掉对应事件。笔者也是采用这套方案。 这里要注意的是，如果是采用Generate的方式，需要增加ButtonClickedEvent等参数的接口，不然xlua会找不到方法。\n 升级版本 UnityEvent这个内存泄漏的问题，在Unity 2021.2.x版本就已经修复了（吐槽：这个bug在2017年前就已经存在了）。\n Scripting: Fixed a memory leak happening when removing listeners from a UnityEvent that is never raised afterwards. (1303095) 所以可以通过升级版进行修复。\n public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); // removals are done synchronously to avoid leaks  var newExecutingCalls = new List\u0026lt;BaseInvokableCall\u0026gt;(m_PersistentCalls.Count + m_RuntimeCalls.Count); newExecutingCalls.AddRange(m_PersistentCalls); newExecutingCalls.AddRange(m_RuntimeCalls); m_ExecutingCalls = newExecutingCalls; m_NeedsUpdate = false; } ","ref":"/blog/unity3d/unityeventmemoryleak/"},{"title":"C#知识点-反射","date":"","description":"收纳一些常用的C#知识点","body":"收纳归总一些常用的C#技巧或者知识点\nType.IsByRef  当参数的类型为引用传递时，IsByRef为True。此时要获得最终类型需要调用GetElementType()。\n private class CustomTypeClass { //Console：type name:Int32 isByRef:False  public void Fun(int value) { } //Console：type name:Int32\u0026amp; isByRef:True elementType:Int32  public void Fun(ref int value) { } //Console：type name:Object isByRef:False  public void Fun(object obj) { } //Console：type name:Object\u0026amp; isByRef:True elementType:Object  public void Fun(ref object obj) { } //Console：type name:Int32[] isByRef:False  public void Fun(int[] intarray) { } //Console：type name:Int32[]\u0026amp; isByRef:True elementType:Int32[]  public void Fun(ref int[] intarray) { } } static void Main(string[] args) { MethodInfo[] methodInfos = typeof(CustomTypeClass).GetMethods(); foreach (var methodInfo in methodInfos) { ParameterInfo[] parameters = methodInfo.GetParameters(); foreach (var parameter in parameters) { var parameterType = parameter.ParameterType; Debug.WriteLine(string.Format(\u0026#34;method name:{0}\u0026#34;, methodInfo.Name)); LogType(parameterType); } } } private static void LogType(Type type) { if (type.IsByRef) { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1} elementType:{2}\u0026#34;, type.Name, type.IsByRef, type.GetElementType().Name)); } else { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1}\u0026#34;, type.Name, type.IsByRef)); } } ","ref":"/blog/csharp/reflection/"},{"title":"Github Action自动化部署Hugo","date":"","description":"教你如何使用Github Action自动化部署Hugo静态页面","body":"每次用Hugo写完Blog，都要重新编译，然后提交到对应的仓库，重复并且繁琐。所以，这里就教大家如何使用Github的自动化构建工具-Action，自动编译部署到Github Pages上。\n由于本文只是教如何使用Github Action，因此，Hugo的调试和部署，不额外拓展。\nRepositorie  创建两个仓库用于后续Action使用\n Source Repositorie  创建一个{xxxxx}.github.source   P.S.{xxxxx}为自己的域名。\n  Source仓库，是用来放置Hugo源码的。  Page Repositorie  创建一个{xxxxx}.github.io   P.S.{xxxxx}为自己的域名。如果使用Github Pages的域名，请与Github账号名一致\n  Page仓库用于放置生成后的Html页面  Github Action  使用Action自动化部署到Pages\n Create ssh-keygen // 使用命令生成公钥和密钥 // {email}为你的邮箱地址 // 注意：不要输入密码，直接回车即可，因为有密码的话，Action运行时会卡在输入密码的步骤 ssh-keygen -t rsa -b 4096 -C \u0026quot;{email}\u0026quot; 这样，本地就会产生一个公钥和一个密钥\n 记住，一定要生成4096以上，不然后续Action时无法正常连接Pages仓库\n Source Repositorie  进入\u0026quot;Settings/secrets/Actions\u0026rdquo; 点击\u0026quot;New repository secret\u0026rdquo; Title填写\u0026quot;ACTIONS_DEPLOY_KEY\u0026rdquo; Value填写私钥文件的内容 确定       Pages Repositorie  进入\u0026quot;Settings/Deploy keys\u0026rdquo; 点击\u0026quot;Add deploy key\u0026rdquo; Title填写\u0026quot;Public of ACTIONS_DEPLOY_KEY\u0026rdquo; Key填写.pub文件（公钥）的内容 勾选\u0026quot;Allow write access\u0026rdquo; 确定       Add Action  在源码仓库的\u0026rdquo;.github/workflows\u0026quot;下已经有\u0026quot;gh-pages.yml\u0026quot;用于生成Pages\n  如果没有，请完整阅读\u0026quot;Create Action\u0026rdquo;。\n Create Action  参考actions-hugo\n name: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.74.2' extended: true - name: Setup Node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm ci - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: publish_dir: ./public publish_branch: master # deploying cname: Change Action  hugo-version为Hugo版本，尽量改成与自己调试的环境一直版本 修改deploy_key为\u0026quot;${{ secrets.ACTIONS_DEPLOY_KEY }}\u0026rdquo;   ACTIONS_DEPLOY_KEY为刚才添加的密钥\n  修改external_repository为放置Pages的Repositorie地址 修改publish_branch为Page仓库的主干，例如master或者main 增加cname为你的域名，用于域名解析。P.S.如果没有，则注释或者删除此行  Deploy  当你在Source Repositorie提交修改时，“github pages”这个action就会自动启动，然后初始化环境、编译、部署，实现完全的自动化。而你，只需要在提交文章几分钟后，刷新一下页面。\n      ","ref":"/blog/git/githubaction-hugo/"},{"title":"","date":"","description":"","body":"","ref":"/blog/lua/hotreload/"},{"title":"联络","date":"","description":"","body":"","ref":"/contact/"}]