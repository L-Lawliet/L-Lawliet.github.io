[{"title":"HLSL","date":"","description":"HLSL","body":"HLSL的一些基础机制和常用函数\n常用函数 基本运算    名称 用例 描述 最小着色器模型 备注     max max(x, y) 返回x和y中的最大值 1    min min(x, y) 返回x和y中的最小值 1    mul mul(x, y) 返回x和y相乘的结果 1    abs abs(x) 返回x的绝对值 1    round round(x) 返回x的四舍五入结果 1    sqrt sqrt(x) 返回x的平方根 1    rsqrt rsqrt(x) 返回x的平方根的倒数 1    degrees degrees(x) 将弧度x转换为角度 1    redians redians(x) 将角度x转换为弧度 1    noise noise(x) 使用Perlin噪声算法生成-1到1之间的随机数 1    rcp rcp(x) 对分量求倒数 5     幂函数\u0026amp;指数函数\u0026amp;对数函数    名称 用例 描述 最小着色器模型 备注     pow pow(x, y) 返回x的y次幂 1    exp exp(x) 返回e的x次幂 1    exp2 exp2(x) 返回2的x次幂 1    ldexp ldexp(x, exp) 返回x和2的exp次方的乘积 1    log log(x) 返回以e为底，x的对数 1    log10 log10(x) 返回以10为底，x的对数 1    log2 log2(x) 返回以2为底，x的对数 1    frexp frexp(x, out exp) 将浮点数x分解为尾数和指数：$x=ret*2^{exp}$，函数返回尾数，exp返回指数 1     三角函数和双曲函数    名称 用例 描述 最小着色器模型 备注     sin sin(x) 返回x弧度的正弦 1    cos cos(x) 返回x弧度的余弦 1    tan tan(x) 返回x弧度的正切 1    sincos sincos(x, out s, out c) 返回x弧度的正弦和余弦 1    asin asin(x) 返回x弧度的反正弦 1    acos acos(x) 返回x弧度的反余弦 1    atan atan(x) 返回x弧度的反正切 1    atan2 atan2(y, x) 返回y/x的反正切值 1    sinh sinh(x) 返回x弧度的双曲正弦值，$\\frac{e^x-e^{-x}}{2}$ 1    cosh cosh(x) 返回x弧度的双曲余弦值，$\\frac{e^x+e^{-x}}{2}$ 1    tanh tanh(x) 返回x弧度的双曲正切值，$\\frac{e^x-e^{-x}}{e^x+e^{-x}}$ 1     数据范围    名称 用例 描述 最小着色器模型 备注     ceil ceil(x) 返回x的向上取整 1    floor floor(x) 返回x的向下取整 1    step step(x, y) 如果x小于等于y则返回1，否则返回0 1    saturate saturate(x) 将x限定在[0, 1] 1    clamp clamp(x, min, max) 将x限制在[min, max] 1    fmod fmod(x, y) 返回x对y取余的余数 1    frac frac(x) 返回x的小数部分 1    modf modf(x, out ip) 将值x分为小数和整数部分，每个部分的符号与x相同，ip返回整数部分，函数返回小数部分 1    lerp lerp(x, y, s) 使用s在x和y之间线性插值：$x+s(y-x)$ 1    smoothstep smoothstep(min, max, x) 如果x在[min，max]范围内，则返回介于0和1之间的平滑Hermite插值，如果x小于min则返回0，如果x大于max则返回1 1     类型判断    名称 用例 描述 最小着色器模型 备注     all all(x) 如果x的所有分量都不为0，则返回true；否则返回false 1    clip clip(x) 如果x小于0，则丢弃当前像素 1    sign sign(x) 如果x小于0，返回-1，如果x等于0，返回0，如果x大于0，返回1 1    isinf isinf(x) 如果x为正无穷或负无穷，返回true，否则返回false 1    isfinite isfinite(x) 与isinf相反 1    isnan isnan(x) 如果x为NAN，则返回true，否则返回false 1     向量和矩阵    名称 用例 描述 最小着色器模型 备注     length length(v) 返回向量v的长度 1    normalize normalize(v) 返回v的归一化向量 1    distance distance(a, b) 返回a和b之间的距离 1    dot dot(a, b) 返回a和b的点积 1    cross cross(a, b) 返回a和b的叉积 1    determinant determinant(m) 返回矩阵m的行列式的值 1    transpose transpose(m) 返回m的转置 1     光线运算    名称 用例 描述 最小着色器模型 备注     reflect reflect(i, n) 以i为入射方向，n为法线的反射光 1    refrect refrect(i, n, ri) 以i为入射方向，n为法线方向，ri为折射率的折射光 1    lit lit(n_dot_l, n_dot_h, m) 输入归一化的法线和光向量的点积，半角向量和法线的点积，高光指数，返回光照向量（环境光，漫反射，高光，1） 1    faceforward faceforward(n, i, ng) 返回面向视图方向的曲面法向量 1     纹理查找    名称 用例 描述 最小着色器模型 备注     tex1D tex1D(s, t) 返回s在t处的值 1    tex1D tex1D(s, t, ddx, ddy) 使用偏导数对2D纹理进行采样以选择Mip级别 1    tex1Dproj tex1Dproj(s, t) 将xyz除以w，然后进行纹理查找 1    tex1Dlod tex1Dlod(s, t) 使用lod查找纹理s在t.w处的值 1    tex1Dbias tex1Dbias(s, t) 将t.w决定的某个Mip层偏置后的纹理查找 1    tex1Dgrad tex1Dgrad(s, t, ddx, ddy) 使用微分并指定Mip层的纹理查找 1    ","ref":"/blog/shader/hlsl/"},{"title":"YooAsset插件","date":"","description":"学习YooAsset插件和分析","body":"YooAsset是一个Unity资源系统，集合资源打包、分包、更新、加载等。\n信息  官网：YooAsset 版本：1.4.2 源码：https://github.com/tuyoogame/YooAsset  构建 收集  检测配置合法性 收集所有Package的资源（遍历所有的Group，然后再遍历所有的Collector）  AssetBundleCollectorSettingData.Setting.GetPackageAssets(buildMode, packageName); 剔除未被引用的依赖资源 录入所有收集器收集的资源 录入相关依赖的资源 记录关键信息 填充主动收集资源的依赖列表 计算完整的资源包名 移除不参与构建的资源 构建资源包  Runtime 初始化  YooAssets初始化。  创建驱动器YooAssetsDriver用于调度系统的Update 创建远程调试器RemoteDebuggerInRuntime用于调试加载情况 初始化异步系统OperationSystem    // 初始化资源系统 YooAssets.Initialize();  创建Package。  创建package 设置为默认的package    // 创建默认的资源包 var package = YooAssets.CreateAssetsPackage(\u0026#34;DefaultPackage\u0026#34;); // 设置该资源包为默认的资源包，可以使用YooAssets相关加载接口加载该资源包内容。 YooAssets.SetDefaultAssetsPackage(package);  初始化资源系统（Editor模拟）  EditorSimulateModeHelper.SimulateBuild会调用AssetBundleSimulateBuilder构建资源清单 再把Parameters传入package进行资源清单初始化 package根据mode创建EditorSimulateModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 EditorSimulateModeImpl进行初始化。 调用EditorSimulateModeInitializationOperation加载清单，并且设置清单到EditorSimulateModeImpl    var createParameters = new EditorSimulateModeParameters(); createParameters.SimulatePatchManifestPath = EditorSimulateModeHelper.SimulateBuild(packageName); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（单机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建OfflinePlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 OfflinePlayModeImpl进行初始化。 调用OfflinePlayModeInitializationOperation  获取Package版本号 加载清单。 设置清单到OfflinePlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters);  初始化资源系统（联机模式）  把Parameters传入package进行资源清单初始化 package根据mode创建HostPlayModeImpl，这是包含了IPlayModeServices和IBundleServices具体实现的集合。 package创建AssetSystemImpl，然后进行初始化。 HostPlayModeImpl进行初始化。 调用HostPlayModeInitializationOperation  获取补丁水印（安装包版本号和补丁版本号），如果水印不一致，则清空缓存目录。 获取缓存目录Package版本号，如果存在，则加载和解析缓存目录清单 在缓存目录清单加载失败（版本号不对、hash值不对、清单不存在等），则获取安装包Package版本号，并且把版本号和清单写入到缓存目录。最后再加载安卓包清单。 设置清单到HostPlayModeImpl 校验清单的资源包，将正确的补丁放入CacheSystem      var createParameters = new OfflinePlayModeParameters(); InitializationOperation initializationOperation = package.InitializeAsync(createParameters); 更新 //更新Package版本信息 var operation = package.UpdatePackageVersionAsync(); yield return operation; //更新Package资源清单 package.UpdatePackageManifestAsync(operation.PackageVersion); //创建下载器 var downloader = YooAssets.CreatePatchDownloader(downloadingMaxNum, failedTryAgain);  只有联机模式才有更新系统\n  HostPlayModeUpdatePackageVersionOperation请求远端版本号信息。 HostPlayModeUpdatePackageManifestOperation更新补丁清单。  加载Cache清单，判断版本号是否为最新 当版本号不是最新时，下载远端清单到Cache目录。 重新加载Cache清单。 校验清单的资源包，将正确的补丁放入CacheSystem   PatchDownloaderOperation下载补丁（不包含已有缓存、内置资源） 清除过期的补丁文件  扩展  由于代码比较简单易懂，并且框架解耦的较好，扩展性比较好。\n 更新  目前热更方式为CDN获取版本信息，可以增加后台模式，以适应后台更新的方案。\n //AssetsPackage.InitializeAsync()  if (...) { ... } else if (_playMode == EPlayMode.ServerPlayMode) { var serverPlayModeImpl = new ServerPlayModeImpl(); ... } 疑问  覆盖安装情况下，资源是否正常？   会通过水印判断安装包是否有变更，如果安装包变更了，则清除Cache目录\n  断点续传是否会出现缺漏的问题？   每次会对文件计算hash值进行校验。没有缺漏问题。\n  热更是否要在Cache增加一份副本？   安装包的内容只有一份。热更时会使用IsBuildinPatchBundle进行判断剔除。\n  CDN需要全量补丁？   发布没有差异补丁的概念，所以都是全量补丁\n 对比 Addressable  Group与Addressable的差不多，都是用于资源分组使用 没有了自定义Entry的概念，取而代之增加了Collector对资源进行收集设置。 收集器的地址保存的是字符串，移动文件夹时会出现丢失的问题。 获取Entry地址和寻址信息需要手动拼写 Tags只能对Group设置，无法只对Collector和Entry设置 Group相对于Addressable去除了很多独立设置，无法对AB进行独立设置压缩方式，命名方式等 地址和寻址两套方式可以选择使用 支持旧的构建模式和SBP模式 配置有Json和Bytes两种，bytes只是简单序列化了，并没有做压缩处理。 Group之上还增加了Package的概念，用于构建时可以分情况构建。 有多种构建模式，例如演练和模拟模式可以方便调试 有调试器和报告查看工具 更新地址需要运行设置。 支持构建原文件 Editor模拟模式，需要每次运行时调用构建，需要生成列表清单。目前只有收集到的资源需要生成清单，理论上速度应该不慢。 构建时才会检查资源是否重复收集 Operation采用的是Update来处理，没有采用协程。Operation通过状态来去区分任务，需要等待子Operation完成来改变状态。 有加密接口。Android采用加密只能使用偏移头文件的方式，如果采用其他方式，将无法加载SteamingAsset目录资源。  问题  缺少SpriteAtlas打包 加载场景时，会自动清空资源引用计数，导致对象池中的对象丢失资源引用。  优点  代码结构较为简单，容易扩展 多线程下载 多线程校验文件 开箱即用  缺点  每次都需要校验文件，全量计算文件Hash，数量一多会比较耗时 收集器需要填写配置，有资源需要特殊处理时，比较难处理 补丁为全量资源上传CDN，如果改成增量补丁，并且按版本分开目录，需要扩展新的mode。 寻址的Key值无法自定义，相同文件名会出现Key重复的问题。 ","ref":"/blog/plugin/yooasset/"},{"title":"构建iOS包","date":"","description":"构建iOS包","body":"在构建iOS包时，遇到了挺多问题，因此记录下来，以备不时之需\n环境  Unity:2020.3.26f1 XCode:13.2.1(13C100)  导出xcodeproj  使用UnityEditor.BuildPipeline.BuildPlayer构建即可，然后就导出xcodeproj。\n 设置xcodeproj配置 PBXProject工具  PBXProject是Unity用于修改导出的xcode工程参数的工具。 P.S.需要安装iOSSupport\n //初始化PBXProject UnityEditor.iOS.Xcode.PBXProject project = new UnityEditor.iOS.Xcode.PBXProject(); string projectName = UnityEditor.iOS.Xcode.PBXProject.GetPBXProjectPath(projectPath); //使用BuildPlayer的构建目录地址获取PBX项目地址 project.ReadFromFile(projectName); //读取项目配置文件  //修改配置的逻辑....  project.WriteToFile(projectName); //把修改后的配置写入  添加引用库  某些第三方SDK需要加入引用的库。 例如Bugly，需要增加以下库：\n  libz.tbd libc++.tbd Security.framework SystemConfiguration.framework JavaScriptCore.framework  然后可以使用AddFrameworkToProject进行添加这些库。\n//先获取UnityFramework的targetGUID，用于指定需要添加库的配置 string frameworkGUID = project.GetUnityFrameworkTargetGuid(); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libz.tbd\u0026#34;, false); project.AddFrameworkToProject(frameworkGUID, \u0026#34;libc++.tbd\u0026#34;, false); ... 设置属性  需要设置某些构建属性时，需要用到SetBuildProperty方法。 例如关闭Bitcode\n //获取UnityMain和UnityFramework的targetGUID，用于指定需要修改属性的配置 string mainTargetGUID = project.GetUnityMainTargetGuid(); string frameworkGUID = project.GetUnityFrameworkTargetGuid(); //Bitcode需要都关闭 project.SetBuildProperty(mainTargetGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode project.SetBuildProperty(frameworkGUID, \u0026#34;ENABLE_BITCODE\u0026#34;, \u0026#34;No\u0026#34;); //用于开启关闭Bitcode  //发布版时，需要修改签名类型 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态 project.SetBuildProperty(mainTargetGUID, \u0026#34;CODE_SIGN_IDENTITY[sdk=iphoneos*]\u0026#34;, \u0026#34;Apple Distribution\u0026#34;); //用于设置成发布状态  project.SetBuildProperty(mainTargetGUID, \u0026#34;PROVISIONING_PROFILE_SPECIFIER\u0026#34;, m_Setting.ProvisioningProfileName); //需要设置ProvisioningProfile ExportOptions  Method：方式  app-store enterprise ad-hoc development   BundleID：包名 ProvisioningProfile：证书名字 TeamID：证书的TeamID Certificate：签名证书  \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026#34; -//Apple//DTD PLIST 1.0//EN\u0026#34; \u0026#34;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026#34;\u0026gt; \u0026lt;plist version=\u0026#34;1.0\u0026#34;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;compileBitcode\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;destination\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;export\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;manageAppVersionAndBuildNumber\u0026lt;/key\u0026gt; \u0026lt;false/\u0026gt; \u0026lt;key\u0026gt;method\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${METHOD}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;provisioningProfiles\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;${BUNDLE_ID}\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${PROVISIONING_PROFILE}\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;key\u0026gt;signingCertificate\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${CERTIFICATE}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;signingStyle\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;manual\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;stripSwiftSymbols\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;key\u0026gt;teamID\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;${TEAM_ID}\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;thinning\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;\u0026amp;lt;none\u0026amp;gt;\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 错误处理 环境错误  The data couldn’t be read because it isn’t in the correct format\n  https://www.jianshu.com/p/103f414fa870 https://stackoverflow.com/questions/58272706/error-exportarchive-the-data-couldn-t-be-read-because-it-isn-t-in-the-correct\n sqlite3环境问题导致的报错，执行如下指令即可：\ngem list | grep sqlite3 gem install sqlite3 --platform=ruby rvm use system --default 类型错误  Error Domain=IDEProfileLocatorErrorDomain Code=4 \u0026ldquo;No \u0026ldquo;iOS App Development\u0026rdquo; profiles for team \u0026lsquo;*****\u0026rsquo; \u0026hellip;..\n 确保provisioning profile中填入的类型正确\n授权问题  \u0026ldquo;error: \u0026ldquo;Unity-iPhone\u0026rdquo; requires a provisioning profile. Select a provisioning profile in the Signing \u0026amp; Capabilities editor. (in target \u0026lsquo;Unity-iPhone\u0026rsquo; from project \u0026lsquo;Unity-iPhone\u0026rsquo;)\u0026rdquo;\n 一般是没有登录provisioning profile对应的开发者账号，或者是没有安装provisioning profile对应的Capabilities\n","ref":"/blog/publish/buildios/"},{"title":"UnityEvent引起的内存泄漏","date":"","description":"UnityEvent引起的内存泄漏","body":"一个由UnityEvent缓存机制引起的内存泄漏问题\n前言  笔者在开发项目时，发现在xLua Dispose时总是会有DelegateBridge没有移除的情况，而排查了一轮，发现就算是一个简单界面也会出现这种情况。 后来经过一轮排查，发现Button的点击事件触发了，就会出现无法移除DelegateBridgeBase，然后翻看了xLua的issue（xLua#139）发现很早就有这个问题，而且也有人提供了解决方案。\n 问题原因 首先这个问题归根到底是由UnityEvent的缓存机制导致：\n Unity在设计UnityEvent时，为其加了缓存机制，也就是上一次调用过的Calls会缓存起来，然后在增加/删除callback时，对缓存设置脏标记。然后在下一次触发事件时，在有变动时才会重新生成Calls。\n //这里截取Unity 2020.3.x版本UnityEvent.CS \u0026lt;InvokableCallList\u0026gt;类的片段 //与Issue中的版本代码有点差异，但机制大致相同 public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); m_NeedsUpdate = true; } ... public List\u0026lt;BaseInvokableCall\u0026gt; PrepareInvoke() { if (m_NeedsUpdate) { m_ExecutingCalls.Clear(); m_ExecutingCalls.AddRange(m_PersistentCalls); m_ExecutingCalls.AddRange(m_RuntimeCalls); m_NeedsUpdate = false; } return m_ExecutingCalls; } 那么问题就来，由于在每次触发（Invoke）事件前，才会重新生成Calls,就算之前已经对callback进行了Remove了，只要没有调用，缓存还会保留已经移除的函数。\n问题危害 正常流程 在xLua框架中，lua需要监听C#的事件，需要把function(lua)设置到LUA_REGISTRYINDEX，并且把引用给到C#，C#再生成Delegate，然后把Delegate和引用封装到DelegateBridge(C#)对象中。 这样，只要把此Delegate绑定到对应的事件中，当事件触发后，就会调用此Delegate，再由DelegateBridge根据引用获取并调用function(lua)。\n由于DelegateBridge只以弱引用的方式保存，所以当移除事件后，Delegate只与对应的DelegateBridge有引用关系，所以在下一轮GC即可销毁掉DelegateBridge，从而接触对应引用的function(lua)（将function从LUA_REGISTRYINDEX中释放掉）。\n这个时候，lua gc就可以把function以及对应upvalue销毁（假设没有任何其他对象引用）。\n泄漏情况 上述都是function(lua)与Delegate绑定和释放的正常流程。而在UnityEvent内存泄漏的情况下，又会变得怎样呢？\n这里我们加入比较常见的情景：\nlocal item = {} item.name = \u0026#34;name\u0026#34; item.button = .... --获取Button对象 item.button.onClick:AddListener(function () print(item.name) end) ...--一顿操作 item.button.onClick:RemoveAllListeners() 根据前文，如果我们在移除前触发了点击事件，那么UnityEvent就会缓存了Delegate，从而保留了DelegateBridge。这个时候唯一办法就是等button释放掉，顺带把UnityEvent也释放，这样DelegateBridge才能给GC回收。\n但是，我们button却给lua的table对象引用了，而这个table又是闭包函数的upvalue值，而最糟糕的是，这个闭包函数却给DelegateBridge引用了（通过LUA_REGISTRYINDEX）。所以，这个table以及button(userdata)都无法给GC回收。\n那么现在就形成了一个死结，而这个死结只要有任何一处解开就可以完全解开了，但现在处处都无法解开。\n解决方案 调用Invoke 根据xLua#139，可以在RemoveAllListener之后，手动调用一次Invoke，这样就可以清除掉Calls。\n 但此方法有个问题，假设Button在Inspector界面上绑定了持久化事件，就会多触发一次事件，可能会有意想不到的bug出现。所以不建议使用\n 反射 根据xLua#139，其实可以通过反射去释放掉UnityEvent中的缓存。\nprivate static MethodInfo prepareInvoke; public static void ReleaseUnusedListeners(this UnityEventBase unityEventBase) { if (prepareInvoke == null) { BindingFlags flag = BindingFlags.Instance | BindingFlags.NonPublic; Type type = unityEventBase.GetType(); prepareInvoke = type.GetMethod(\u0026#34;PrepareInvoke\u0026#34;, flag); } prepareInvoke.Invoke(unityEventBase, null); } ... item.button.onClick:RemoveAllListeners() item.button.onClick:ReleaseUnusedListeners()  笔者在issue基础上进行了优化。 此方案副作用小，只要不忘记调用，就可以释放掉对应事件。笔者也是采用这套方案。 这里要注意的是，如果是采用Generate的方式，需要增加ButtonClickedEvent等参数的接口，不然xlua会找不到方法。\n 升级版本 UnityEvent这个内存泄漏的问题，在Unity 2021.2.x版本就已经修复了（吐槽：这个bug在2017年前就已经存在了）。\n Scripting: Fixed a memory leak happening when removing listeners from a UnityEvent that is never raised afterwards. (1303095) 所以可以通过升级版进行修复。\n public void RemoveListener(object targetObj, MethodInfo method) { var toRemove = new List\u0026lt;BaseInvokableCall\u0026gt;(); for (int index = 0; index \u0026lt; m_RuntimeCalls.Count; index++) { if (m_RuntimeCalls[index].Find(targetObj, method)) toRemove.Add(m_RuntimeCalls[index]); } m_RuntimeCalls.RemoveAll(toRemove.Contains); // removals are done synchronously to avoid leaks  var newExecutingCalls = new List\u0026lt;BaseInvokableCall\u0026gt;(m_PersistentCalls.Count + m_RuntimeCalls.Count); newExecutingCalls.AddRange(m_PersistentCalls); newExecutingCalls.AddRange(m_RuntimeCalls); m_ExecutingCalls = newExecutingCalls; m_NeedsUpdate = false; } ","ref":"/blog/unity3d/unityeventmemoryleak/"},{"title":"xLua-性能优化","date":"","description":"对xLua的性能进行优化","body":"对xLua的性能进行优化\n优化初始化性能 问题排查    问题堆栈 问题原因 堆内存（MB） 耗时（ms）     CodeEmit.initBlackList() Utils.GetAllTypes() 3.5    CodeEmit.initBlackList() RuntimeType.GetFields() 3.2    ObjectTranslator.initCSharpCallLua() Utils.GetAllTypes() 1.7    ObjectTranslator.initCSharpCallLua() RuntimeType.GetFields() 0.6    ObjectTranslator.CreateArrayMetatable() Utils.GetAllTypes() 1.7    ObjectTranslator.CreateArrayMetatable() RuntimeType.GetFields() 0.5     优化思路  综合上述排查结果，问题主要集中在两个函数：Utils.GetAllTypes()和RuntimeType.GetFields()\n  Utils.GetAllTypes()：主要是获取所有符合的类型。  由于结果没有复用，因此产生了大量的重复堆内存申请。 使用了Linq，产生了临时堆内存。   RuntimeType.GetFields()：主要集中在遍历获取所有属性字段的类型  遍历规模较大   ","ref":"/blog/xlua/optimization/"},{"title":"xLua-数据结构","date":"","description":"阐述xLua的数据结构设计","body":"阐述xLua中的数据结构设计\n整体  先来看一下整体的结构图\n  Class table  C#的静态函数接口在Lua中的结构是怎样一种方式存储？下面的结构图能够很好的表示。\n C#类的静态函数接口（包括静态字段/静态属性/构造函数等warp的）是以table（Class table）的形式存储在_G[\u0026quot;CS\u0026quot;]表中。\n静态属性/字段 当调用静态属性/字段时，根据属性/字段名在对应的Class table中获取对应warp的Function并调用。\n构造函数 对类的table调用()时，自动调用其元表中的__call函数，而这就是C#函数中的__CreateInstance。\n Object metatable  C#的对象在Lua中的结构是怎样一种方式存储？下面的结构图能够很好的表示。\n C#对象的函数接口（包括字段/属性等warp的）是以metatable（Object metatable）的形式存储在REGISTRYINDEX表中。 在初始化对象时，先根据完全类名获取到相应Class的table，然后通过其metatable的__call函数实例化一个C#对象。 接着创建对象对应的userdata，然后将对应的Object metatable设置给对象的userdata。\n生命周期 C# Struct  普通Struct（不使用GCOptimize）的，创建时是直接调用ObjectTranslator.Push方法把Struct放进ObjectTranslator.objects里，并得到objects中的索引，然后再调用LuaAPI.xlua_pushcsobj，在C侧创建userdata，把index作为userdata的值。 在调用Struct字段时，会通过userdata的index值，在ObjectTranslator.objects中把Struct获取出来。\n  这种方式有比较大的缺点，通过ObjectTranslator.objects保存/获取会导致Struct存在装箱拆箱。\n C# Class C# Delegate C# NoGC Struct  Vector3、Enum等创建时会在C侧创建CSharpStruct(userdata)，然后把里面浮点数字段赋值到CSharpStruct.data中，然后在设置对应的warp作为它的metatable。\n  以Vector3为例，在Lua侧获取字段时，如果使用v.x，则会调用对应warp的方法，然后调用CopyByValue.UnPack方法把struct拷贝回C#侧再进行pushnumber。 如果使用v[0]的方式获取字段，则直接是使用CSharpStruct.data的数据，不用经过C#侧的处理。\n  以Vector3为例，如果是对xxx.position=v的行为，会有两种操作，一种v是userdata，则会获取userdata，CopyByValue.UnPack拷贝数据到一个Vector3。 另外一种是table，可以在Lua侧使用{x=0,y=0,z=0}的方式新建Vector3，然后把这个table传到C#侧，进行CopyByValue.UnPack，把CopyByValue.UnPack拷贝数据到一个Vector3。 无论是哪种CopyByValue.Pack/UnPack，实际上都是通过虚拟栈传输float。\n  以上的做法好处是，C#侧不需要保存Struct，Struct只会在使用的时候才会转成Struct。\n Lua Table","ref":"/blog/xlua/datastructure/"},{"title":"C#知识点-反射","date":"","description":"收纳一些常用的C#知识点","body":"收纳归总一些常用的C#技巧或者知识点\nType.IsByRef  当参数的类型为引用传递时，IsByRef为True。此时要获得最终类型需要调用GetElementType()。\n private class CustomTypeClass { //Console：type name:Int32 isByRef:False  public void Fun(int value) { } //Console：type name:Int32\u0026amp; isByRef:True elementType:Int32  public void Fun(ref int value) { } //Console：type name:Object isByRef:False  public void Fun(object obj) { } //Console：type name:Object\u0026amp; isByRef:True elementType:Object  public void Fun(ref object obj) { } //Console：type name:Int32[] isByRef:False  public void Fun(int[] intarray) { } //Console：type name:Int32[]\u0026amp; isByRef:True elementType:Int32[]  public void Fun(ref int[] intarray) { } } static void Main(string[] args) { MethodInfo[] methodInfos = typeof(CustomTypeClass).GetMethods(); foreach (var methodInfo in methodInfos) { ParameterInfo[] parameters = methodInfo.GetParameters(); foreach (var parameter in parameters) { var parameterType = parameter.ParameterType; Debug.WriteLine(string.Format(\u0026#34;method name:{0}\u0026#34;, methodInfo.Name)); LogType(parameterType); } } } private static void LogType(Type type) { if (type.IsByRef) { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1} elementType:{2}\u0026#34;, type.Name, type.IsByRef, type.GetElementType().Name)); } else { Debug.WriteLine(string.Format(\u0026#34;type name:{0} isByRef:{1}\u0026#34;, type.Name, type.IsByRef)); } } ","ref":"/blog/csharp/reflection/"},{"title":"About","date":"","description":"希望这里的教程能给大家提供灵感","body":"Unity主程、游戏迷、胶佬、垃圾佬\u0026hellip;\n这里主要是想把自己日常开发所遇到的问题、感悟的见解全写出来，为大家提供一些思路和灵感。\n同时也提供一个交流的平台。\n","ref":"/about/"},{"title":"Github Action自动化部署Hugo","date":"","description":"教你如何使用Github Action自动化部署Hugo静态页面","body":"每次用Hugo写完Blog，都要重新编译，然后提交到对应的仓库，重复并且繁琐。所以，这里就教大家如何使用Github的自动化构建工具-Action，自动编译部署到Github Pages上。\n由于本文只是教如何使用Github Action，因此，Hugo的调试和部署，不额外拓展。\nRepositorie  创建两个仓库用于后续Action使用\n Source Repositorie  创建一个{xxxxx}.github.source   P.S.{xxxxx}为自己的域名。\n  Source仓库，是用来放置Hugo源码的。  Page Repositorie  创建一个{xxxxx}.github.io   P.S.{xxxxx}为自己的域名。如果使用Github Pages的域名，请与Github账号名一致\n  Page仓库用于放置生成后的Html页面  Github Action  使用Action自动化部署到Pages\n Create ssh-keygen // 使用命令生成公钥和密钥 // {email}为你的邮箱地址 // 注意：不要输入密码，直接回车即可，因为有密码的话，Action运行时会卡在输入密码的步骤 ssh-keygen -t rsa -b 4096 -C \u0026quot;{email}\u0026quot; 这样，本地就会产生一个公钥和一个密钥\n 记住，一定要生成4096以上，不然后续Action时无法正常连接Pages仓库\n Source Repositorie  进入\u0026quot;Settings/secrets/Actions\u0026rdquo; 点击\u0026quot;New repository secret\u0026rdquo; Title填写\u0026quot;ACTIONS_DEPLOY_KEY\u0026rdquo; Value填写私钥文件的内容 确定  Pages Repositorie  进入\u0026quot;Settings/Deploy keys\u0026rdquo; 点击\u0026quot;Add deploy key\u0026rdquo; Title填写\u0026quot;Public of ACTIONS_DEPLOY_KEY\u0026rdquo; Key填写.pub文件（公钥）的内容 勾选\u0026quot;Allow write access\u0026rdquo; 确定  Add Action  在源码仓库的\u0026rdquo;.github/workflows\u0026quot;下已经有\u0026quot;gh-pages.yml\u0026quot;用于生成Pages\n  如果没有，请完整阅读\u0026quot;Create Action\u0026rdquo;。\n Create Action  参考actions-hugo\n name: github pages on: push: branches: - master # Set a branch to deploy jobs: deploy: runs-on: ubuntu-18.04 steps: - uses: actions/checkout@v2 with: submodules: true # Fetch Hugo themes (true OR recursive) fetch-depth: 0 # Fetch all history for .GitInfo and .Lastmod - name: Setup Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: '0.74.2' extended: true - name: Setup Node uses: actions/setup-node@v1 with: node-version: '12.x' - name: Cache dependencies uses: actions/cache@v1 with: path: ~/.npm key: ${{ runner.os }}-node-${{ hashFiles('**/package-lock.json') }} restore-keys: | ${{ runner.os }}-node- - run: npm ci - name: Build run: hugo --minify - name: Deploy uses: peaceiris/actions-gh-pages@v3 with: deploy_key: ${{ secrets.ACTIONS_DEPLOY_KEY }} external_repository: publish_dir: ./public publish_branch: master # deploying cname: Change Action  hugo-version为Hugo版本，尽量改成与自己调试的环境一直版本 修改deploy_key为\u0026quot;${{ secrets.ACTIONS_DEPLOY_KEY }}\u0026rdquo;   ACTIONS_DEPLOY_KEY为刚才添加的密钥\n  修改external_repository为放置Pages的Repositorie地址 修改publish_branch为Page仓库的主干，例如master或者main 增加cname为你的域名，用于域名解析。P.S.如果没有，则注释或者删除此行  Deploy  当你在Source Repositorie提交修改时，“github pages”这个action就会自动启动，然后初始化环境、编译、部署，实现完全的自动化。而你，只需要在提交文章几分钟后，刷新一下页面。\n ","ref":"/blog/git/githubaction-hugo/"},{"title":"","date":"","description":"","body":"","ref":"/blog/lua/hotreload/"},{"title":"联络","date":"","description":"","body":"","ref":"/contact/"}]