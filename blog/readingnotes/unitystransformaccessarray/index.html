<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>【翻译】Unity的TransformAccessArray —— 内部机制与最佳实践 - L-Lawliet's Blog</title>
<meta name=viewport content="width=device-width,initial-scale=1"><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/markmap-toolbar@0.15.4/dist/style.css><script src=https://cdn.jsdelivr.net/npm/markmap-autoloader@0.15.4/dist/index.js></script><meta name=generator content="Hugo 0.123.0"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="【翻译】Unity的TransformAccessArray —— 内部机制与最佳实践"><meta property="og:description" content="<Unity’s TransformAccessArray — internals and best practices>文章的翻译"><meta property="description" content="<Unity’s TransformAccessArray — internals and best practices>文章的翻译"><meta property="og:url" content="https://l-lawliet.github.io/blog/readingnotes/unitystransformaccessarray/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.3f52c9f6ea16c0e2fe1ad716c9c0916180f27ec381c64f770a3061d312801376.css integrity="sha256-P1LJ9uoWwOL+GtcWycCRYYDyfsOBxk93CjBh0xKAE3Y="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class='fa fa-home'></i> Home</a>
<a href=/about class="nav link"><i class='far fa-id-card'></i> About</a>
<a href=/blog class="nav link"><i class='far fa-newspaper'></i> Blog</a>
<a href=/categories class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
<a href=/fantasyfactor class="nav link"><i class='fa fa-tools'></i> Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu><a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu><menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;title=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;title=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;description=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/readingnotes/unitystransformaccessarray/>【翻译】Unity的TransformAccessArray —— 内部机制与最佳实践</a></h2><p>&lt;Unity’s TransformAccessArray — internals and best practices>文章的翻译</p></div><div class=meta><time datetime="0001-01-01 00:00:00 +0000 UTC">January 1, 0001</time><p>Lawliet</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;title=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;title=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f&amp;description=%e3%80%90%e7%bf%bb%e8%af%91%e3%80%91Unity%e7%9a%84TransformAccessArray%20%e2%80%94%e2%80%94%20%e5%86%85%e9%83%a8%e6%9c%ba%e5%88%b6%e4%b8%8e%e6%9c%80%e4%bd%b3%e5%ae%9e%e8%b7%b5" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2funitystransformaccessarray%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/readingnotes/unitystransformaccessarray/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>&ldquo;Unity’s TransformAccessArray — internals and best practices"文章的翻译</p><h2 id=声明>声明</h2><blockquote><p>原文地址：https://medium.com/toca-boca-tech-blog/unitys-transformaccessarray-internals-and-best-practices-2923546e0b41<br>本文翻译如有侵权，请及时联系笔者。</p></blockquote><hr><p>我最近接手了一位转组同事留下的渲染代码，这些代码大量使用了 Unity 的 <code>TransformAccessArray</code> 和 Unity Jobs。我之前听说过 <code>TransformAccessArray</code>，也见过它的使用，但从未有机会深入了解它的工作原理。</p><p>要搞懂它确实有点吃力，因为相关资料非常少，<a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccessArray.html>Unity官方文档</a>也很简略。截至目前，最有用的文档页面是<a href=https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransform.html>IJobParallelForTransform</a>和<a href=https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransformExtensions.html>IJobParallelForTransformExtensions</a>的子页面，但即使是这些页面，内容也不够详尽。</p><p>因此，这次正好是一个机会，让我深入研究 Unity Job System 的一些内部机制，以更好地理解 <code>TransformAccessArray</code> 和 <code>IJobParallelForTransform</code> 的工作原理，特别是它们与主线程上的“常规” Transform 访问之间的交互。我发现了一些非常有趣的结果，想在这篇文章中分享给大家。</p><p>接下来，我将介绍<a href=/#TransformAccessArray的内部机制>TransformAccessArray的一些内部机制</a>、一个用于<a href=/#TransformAccessArray测试脚本>测试的Job脚本</a>、几种Job使用模式的分析:<a href=/#具有Job依赖的TransformAccessArrayJob>具有Job依赖的TransformAccessArrayJob</a>、<a href=/#多次只读Transform访问>多次只读Transform访问</a>、<a href=/#单个Transform根节点>单个Transform根节点</a>，以及基于这些观察得出的<a href=/#TransformAccessArray-Job-性能最佳实践>最佳实践</a>。文章最后还有一个简短的<a href=/#unity-job-system性能优化愿望清单>Unity性能优化愿望清单</a>，希望能推动Job System的性能提升。</p><p>让我们开始吧！</p><hr><h2 id=transformaccessarray的内部机制>TransformAccessArray的内部机制</h2><p>Unity的<a href=https://docs.unity3d.com/Manual/job-system-overview.html>Job System</a>只能使用<a href=https://learn.microsoft.com/en-us/dotnet/framework/interop/blittable-and-non-blittable-types>blittable</a>的数据类型，这意味着 Job 无法访问托管类型（如 <code>Transform</code> 和 <code>MeshRenderer</code>）。从安全性角度来看，这种限制可以防止数据竞争：即一个工作线程在写入某块内存时，另一个线程或主线程也在访问该内存地址。</p><p><code>TransformAccessArray</code> 提供了一种绕过这一限制的方法，使得 Job 可以读取或写入 Transform 数据。其核心功能依赖于 Unity 内部的 C++ 类 <code>TransformHierarchy</code>。在<a href="https://www.youtube.com/watch?v=W45-fsnPhJY&t=796s">Unite Berlin 2018 — Unity’s Evolving Best Practices</a>演讲的 13:14 处，有一段关于该类的讨论，至今仍然非常相关。以下这句话非常关键，有助于理解 <code>TransformAccessArray</code> 的工作原理：</p><blockquote><p>场景中的每个transform root都有一个对应的transform hierarchy。</p></blockquote><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:640/format:webp/1*Q94ikOiSPiAYQgOs5F1wng.png><img src=https://miro.medium.com/v2/resize:fit:640/format:webp/1*Q94ikOiSPiAYQgOs5F1wng.png alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>场景层级中的transform root</div></p><p>从此处开始，我将交替使用“transform hierarchy（transform层级结构）”和“transform root（transform根节点）”这两个术语。</p><p>如果将上述内容与这段在<a href=https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransformExtensions.Schedule.html>IJobParallelForTransform.Schedule</a>文档中的片段结合起来，我们可以初步感受到两者之间的联系：</p><blockquote><p>该方法对不同层级结构中的Transform进行并行访问。共享同一个根对象的 Transform总是在同一个线程上处理。</p></blockquote><p>而<a href=https://docs.unity3d.com/ScriptReference/Jobs.IJobParallelForTransformExtensions.ScheduleReadOnly.html>ScheduleReadOnly</a>方法则放宽了调度限制：</p><blockquote><p>该方法提供了更好的并行性，因为它可以并行读取所有 Transform，而不仅仅是不同层级结构之间的并行。</p></blockquote><p>当你使用一个 Transform 数组创建 <code>TransformAccessArray</code> 实例时，Unity 会在内部对其进行重排序，以提高访问效率。Transform 首先会按根节点进行分组，然后共享同一个根节点的 Transform 会被排序在一起，以便根据其内部的层级结构优化迭代速度。</p><p>当 Unity 执行 <code>IJobParallelForTransform</code> Job 时，它调用 <code>Execute</code> 方法的顺序可能与 <code>TransformAccessArray</code> 中 Transform 数组的原始顺序完全不同。这时，<code>index</code> 参数就派上用场了。它允许你将某次 <code>Execute</code> 调用映射回原始 Transform 数组中的对应元素。如果你注意到内部方法 <code>TransformAccessArray.GetSortedToUserIndex</code> 并好奇它的作用，这就是答案。</p><p>重要的是，<code>TransformAccessArray</code> 不会为了读取或写入 Transform 数据而复制任何数据。除非你以其他方式实现，否则不会有缓冲区或临时存储。这种直接访问是使用它的主要好处。</p><p>但这也意味着，在我们具体了解这一切如何协同工作之前，还有一段理论需要掌握。</p><hr><h3 id=transform-层级访问的同步机制>Transform 层级访问的同步机制</h3><p>如前文所述，Unity 的Job System对Job中可以访问的数据有非常严格的限制。对于 <code>TransformAccessArray</code> 及其隐式提供的 <code>TransformHierarchy</code> 实例，这意味着 Unity 必须有一些机制来避免并发修改 Transform 或读取过期值。其数据<a href=https://en.wikipedia.org/wiki/Synchronization_(computer_science)>同步</a>方法（内部称为 fence）可防止主线程和工作线程同时访问同一 Transform 时发生<a href=https://en.wikipedia.org/wiki/Race_condition>竞争条件</a>。</p><p>Unity 保护 Transform 访问的颗粒度是 Transform 层级结构。换句话说，所有共享同一个 Transform 根节点的 Transform 也共享同一个 fence。当一个使用 <code>TransformAccessArray</code> 的 Job 被调度时，Unity 会延迟所有对该 Job 所涉及的 Transform 层级结构中任何 Transform 的访问，直到该 Job 完成。这意味着，任何与该 <code>TransformAccessArray</code> 中任意 Transform 共享同一个根节点的 Transform，都会被阻塞。让我们用一个例子来说明：</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:640/format:webp/1*rKw25Q3GlFgpQiiZPZgTlg.png><img src=https://miro.medium.com/v2/resize:fit:640/format:webp/1*rKw25Q3GlFgpQiiZPZgTlg.png alt=image></a><figcaption></figcaption></figure></p><div style=text-align:center>两个操作同一 Transform 层级结构的 Job</div><p>上图展示了两个 Job，即使它们访问的不是同一个 Transform，只要它们共享一个 Transform 层级结构，就会发生阻塞。如果 <strong>Job A</strong> 在 <strong>Job B</strong> 之前被调度，那么 <strong>Job B</strong> 必须等到 <strong>Job A</strong> 完成后才能开始。即使 <strong>Job A</strong> 剩余的任务只涉及其他层级结构，它也必须完全完成。这种阻塞行为会影响以下场景：</p><ul><li>其他 <code>IJobParallelForTransform</code> Job，即使是只读 Job。</li><li>主线程对 Transform 的读取或写入，例如在 <code>MonoBehaviour</code> 脚本中。</li><li>任何其他对 Transform 的访问，例如动画和蒙皮网格渲染器。</li></ul><p>当 Job 被阻塞时，它们会留在 Job 执行队列中。当主线程被阻塞时（例如调用<a href=https://docs.unity3d.com/ScriptReference/Unity.Jobs.JobHandle.Complete.html>JobHandle.Complete</a> 或尝试访问一个尚未完成的 Job 正在使用的 Transform），它可能会空闲下来，或者可能的情况下<a href=https://en.wikipedia.org/wiki/Work_stealing>窃取工作</a>。而工作窃取意味着主线程会拿起一个准备执行的 Job 并执行它。其背后的逻辑是：主线程做点事总比闲着好。但这会带来一些重要后果，后文会讨论。</p><hr><h2 id=transformaccessarray测试脚本>TransformAccessArray测试脚本</h2><p>我写了以下测试脚本，用于验证我前面提到的很多信息，并在不同的人造Job场景（译注：表明这些场景都是特意制造出来的）中验证我对 <code>TransformAccessArray</code> 的理解。没有哪个游戏会真的按这个顺序执行这些操作，但它仍然是模拟各种真实场景的好方法。</p><p>（代码已针对 Medium 的窄屏宽度优化显示）</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-csharp data-lang=csharp><span style=display:flex><span><span style=color:#66d9ef>using</span> System.Threading;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Jobs;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> Unity.Profiling;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine;
</span></span><span style=display:flex><span><span style=color:#66d9ef>using</span> UnityEngine.Jobs;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>class</span> <span style=color:#a6e22e>TransformAccessArrayTest</span> : MonoBehaviour
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> [Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>)] <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>uint</span> hierarchyRootsCount = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [Tooltip(&#34;Transform count in each transform hierarchy root&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> [Range(<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>)] <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>uint</span> hierarchyDepth = <span style=color:#ae81ff>4</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [Tooltip(&#34;How long to delay the start of the TransformJob&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> delayJobStartMs;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [Tooltip(&#34;Per-Transform job time&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> jobRuntimeMs = <span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>  
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> [Range(-<span style=color:#ae81ff>1</span>, <span style=color:#ae81ff>100</span>)] <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> desiredJobCount = -<span style=color:#ae81ff>1</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> scheduleAsReadOnlyJob;
</span></span><span style=display:flex><span><span style=color:#a6e22e>  
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [Tooltip(&#34;Schedule a second read-only IJobParallelForTransform job&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> addParallelReadOnlyJob;
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [Tooltip(&#34;Applies to read-only jobs only&#34;)]</span>
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [Range(1, 100)]</span> [SerializeField] <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>int</span> readonlyJobBatchSize = <span style=color:#ae81ff>2</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>  
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> readTransformsAfterJob = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span><span style=color:#a6e22e>   [SerializeField]</span> <span style=color:#66d9ef>private</span> <span style=color:#66d9ef>bool</span> writeTransformsAfterJob;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   GameObject[] generatedGameObjects;
</span></span><span style=display:flex><span>   TransformAccessArray accessArray;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> ProfilerMarker markerBefore = <span style=color:#66d9ef>new</span>(<span style=color:#e6db74>&#34;BeforeJobScheduled&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> ProfilerMarker markerReadAfter = <span style=color:#66d9ef>new</span>(<span style=color:#e6db74>&#34;ReadAfterJobScheduled&#34;</span>);
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> ProfilerMarker markerWriteAfter = <span style=color:#66d9ef>new</span>(<span style=color:#e6db74>&#34;WriteAfterJobScheduled&#34;</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>void</span> OnValidate() =&gt; Cleanup();
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>void</span> OnDestroy() =&gt; Cleanup();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>void</span> Cleanup()
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (generatedGameObjects != <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = generatedGameObjects.Length - <span style=color:#ae81ff>1</span>; i &gt;= <span style=color:#ae81ff>0</span>; i--)
</span></span><span style=display:flex><span>               Destroy(generatedGameObjects[i]);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>           generatedGameObjects = <span style=color:#66d9ef>null</span>;
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>if</span> (accessArray.isCreated)
</span></span><span style=display:flex><span>               accessArray.Dispose();
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>void</span> Update()
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Support dynamically changing parameters in the Editor</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (!accessArray.isCreated)
</span></span><span style=display:flex><span>           CreateTransformArray();
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Write to the transforms from the main thread</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>using</span> (markerBefore.Auto())
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> go <span style=color:#66d9ef>in</span> generatedGameObjects)
</span></span><span style=display:flex><span>               go.transform.position += <span style=color:#66d9ef>new</span> Vector3(<span style=color:#ae81ff>0.000001f</span>,<span style=color:#ae81ff>0</span>, <span style=color:#ae81ff>0</span>);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>var</span> delayJobHandle = delayJobStartMs &lt;= <span style=color:#ae81ff>0</span> ? <span style=color:#66d9ef>default</span> :
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>new</span> DelayJob() { DelayMs = delayJobStartMs }.Schedule();
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>var</span> transformJob = <span style=color:#66d9ef>new</span> TransformJob() { JobRuntimeMs = jobRuntimeMs };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Set the optional DelayJob as a job dependency of TransformJob</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (scheduleAsReadOnlyJob)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           transformJob.ScheduleReadOnly(accessArray, readonlyJobBatchSize, delayJobHandle);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           transformJob.Schedule(accessArray, delayJobHandle);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Schedule a second read-only job</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (addParallelReadOnlyJob)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>new</span> ReadOnlyJob() { JobRuntimeMs = jobRuntimeMs }
</span></span><span style=display:flex><span>               .ScheduleReadOnly(accessArray, readonlyJobBatchSize, delayJobHandle);
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       <span style=color:#75715e>// Fake some work so the loops below can&#39;t be removed as no-ops</span>
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>var</span> position = Vector3.zero;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (readTransformsAfterJob)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>using</span> var _ = markerReadAfter.Auto();
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> go <span style=color:#66d9ef>in</span> generatedGameObjects)
</span></span><span style=display:flex><span>               position += go.transform.position;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>      
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>if</span> (writeTransformsAfterJob)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>using</span> var _ = markerWriteAfter.Auto();
</span></span><span style=display:flex><span>           position = Vector3.Min(position * <span style=color:#ae81ff>0.0000001f</span>, Vector3.one * <span style=color:#ae81ff>0.1f</span>);
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>foreach</span> (<span style=color:#66d9ef>var</span> go <span style=color:#66d9ef>in</span> generatedGameObjects)
</span></span><span style=display:flex><span>               go.transform.position = position;
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>void</span> CreateTransformArray()
</span></span><span style=display:flex><span>   {
</span></span><span style=display:flex><span>       generatedGameObjects = <span style=color:#66d9ef>new</span> GameObject[hierarchyRootsCount * hierarchyDepth];
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>var</span> transforms = <span style=color:#66d9ef>new</span> Transform[hierarchyRootsCount * hierarchyDepth];
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>var</span> transformsIndex = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>       <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; hierarchyRootsCount; i++)
</span></span><span style=display:flex><span>       {
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>var</span> parent = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>$&#34;generated_{i}&#34;</span>);
</span></span><span style=display:flex><span>           generatedGameObjects[transformsIndex] = parent;
</span></span><span style=display:flex><span>           transforms[transformsIndex++] = parent.transform;
</span></span><span style=display:flex><span>          
</span></span><span style=display:flex><span>           <span style=color:#75715e>// Not technically a depth, but it has the same impact</span>
</span></span><span style=display:flex><span>           <span style=color:#75715e>// for Unity&#39;s job scheduling</span>
</span></span><span style=display:flex><span>           <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> j = <span style=color:#ae81ff>0</span>; j &lt; hierarchyDepth - <span style=color:#ae81ff>1</span>; j++)
</span></span><span style=display:flex><span>           {
</span></span><span style=display:flex><span>               <span style=color:#66d9ef>var</span> child = <span style=color:#66d9ef>new</span> GameObject(<span style=color:#e6db74>$&#34;{parent.name}_{j}&#34;</span>);
</span></span><span style=display:flex><span>               child.transform.SetParent(parent.transform);
</span></span><span style=display:flex><span>               generatedGameObjects[transformsIndex] = child;
</span></span><span style=display:flex><span>               transforms[transformsIndex++] = child.transform;
</span></span><span style=display:flex><span>           }
</span></span><span style=display:flex><span>       }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>       accessArray = <span style=color:#66d9ef>new</span> TransformAccessArray(transforms, desiredJobCount);
</span></span><span style=display:flex><span>   }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>DelayJob</span> : IJob
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> DelayMs;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute() =&gt; Thread.Sleep(DelayMs);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>TransformJob</span> : IJobParallelForTransform
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> JobRuntimeMs;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess t) =&gt; Thread.Sleep(JobRuntimeMs);
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>  
</span></span><span style=display:flex><span><span style=color:#75715e>// Use a second type to easily identify it in the profiler</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>ReadOnlyJob</span> : IJobParallelForTransform
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>int</span> JobRuntimeMs;
</span></span><span style=display:flex><span>   <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i, TransformAccess t) =&gt; Thread.Sleep(JobRuntimeMs);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>脚本启动时，会根据 <strong>Hierarchy Roots Count</strong> 和 <strong>Hierarchy Depth</strong> 属性生成一个游戏对象层级结构。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:720/format:webp/1*yr4JZgZ6XiWgg62PW15xpw.png><img src=https://miro.medium.com/v2/resize:fit:720/format:webp/1*yr4JZgZ6XiWgg62PW15xpw.png alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>脚本属性与生成的场景游戏对象</div></p><p>下面的序列图展示了 <code>Update</code> 方法的执行流程，黄色框展示了某些属性的影响。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:720/format:webp/0*G7LbHOpOnjPvncc7><img src=https://miro.medium.com/v2/resize:fit:720/format:webp/0*G7LbHOpOnjPvncc7 alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>Job与行为的序列图</div></p><p>如果启用 <strong>Add Parallel Read Only Job</strong> 属性，脚本会在序列图的第二步之后立即调度第二个 <code>IJobParallelForTransform</code> Job，即 <strong>ReadOnlyJob</strong>。为了简化脚本，该 Job 访问的是同一个 <code>TransformAccessArray</code>，但即使它们使用不同的 <code>TransformAccessArray</code> 实例，只要访问的是同一个 Transform 层级结构，结果也是一样的。</p><p><strong>DelayJob</strong> 是一个可选的 Job 依赖项，它允许我们模拟某些 Job 依赖其他 Job 输出的场景（尽管本脚本中并没有实际输出）。</p><p>我们使用 <code>-job-worker-count 4</code> 命令行参数（译注：Unity Hub可以在工程项添加）将 Unity 配置为使用 4 个工作线程，来分析几种场景。</p><hr><h3 id=具有job依赖的transformaccessarrayjob>具有Job依赖的TransformAccessArrayJob</h3><p>本场景使用 2 个 Transform 根节点，每个根节点下有 4 个 Transform。测试脚本调度了一个 <strong>DelayJob</strong>，它是 <strong>TransformJob</strong> 和 <strong>ReadOnlyJob</strong> 的依赖项。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:720/format:webp/0*jbR6utd1Fs3yXQcH><img src=https://miro.medium.com/v2/resize:fit:720/format:webp/0*jbR6utd1Fs3yXQcH alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>带 Job 依赖的 TransformAccessArray Job 设置</div></p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*1i4HqVLfC98K7x-x><img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*1i4HqVLfC98K7x-x alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>带 Job 依赖的 TransformAccessArray Job的Profiler截图</div></p><p>从 Profiler 截图中我们可以观察到几点：</p><p>主线程在 <strong>ReadAfterJobScheduled</strong> 中被阻塞，因为它试图读取 <strong>TransformJob</strong> 和 <strong>ReadOnlyJob</strong> 正在使用的 Transform。注意，主线程是在 <strong>DelayJob</strong> 执行期间被阻塞的，而 <strong>DelayJob</strong> 并不是 <code>IJobParallelForTransform</code>。这是因为 <strong>TransformJob</strong> 已经被调度执行，此时它已经将自身设置为该 Transform 层级结构同步 fence 的依赖项。</p><p>当主线程被阻塞时，Profiler 截图展示了上述两种行为：主线程先“偷取”并执行了 <strong>DelayJob</strong>，然后在其他 Job 执行期间处于空闲状态。这种行为是非确定性的，在不同帧之间可能会有所不同。</p><p>尽管 <strong>Desired Job Count</strong> 设置为 8，而总共有 8 个 Transform 可供处理，但 <strong>TransformJob</strong> 只分成了 2 个批次。这是因为非只读 Job 不会在同一 Transform 层级结构上并行执行。而 <strong>ReadOnlyJob</strong> 可以在同一层级结构上并行访问 Transform，因此被分成了 4 个批次（因为 <strong>Read Only Batch Size</strong> 设置为 2）。</p><hr><h3 id=多次只读transformaccesses>多次只读TransformAccesses</h3><p>本场景使用相同的 Transform 配置，但 <strong>TransformJob</strong> 和 <strong>ReadOnlyJob</strong> 都是只读 Job，并且没有 <strong>DelayJob</strong>（下一节会解释原因）。换句话说，在 <strong>BeforeJobScheduled</strong> 标记的写入访问之后，脚本只通过只读方式访问 Transform。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:720/format:webp/0*v57hkDi_sGsXQW6n><img src=https://miro.medium.com/v2/resize:fit:720/format:webp/0*v57hkDi_sGsXQW6n alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>多次只读 transform accesses的设置</div></p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*Z0hY9dVTews161IA><img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*Z0hY9dVTews161IA alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>多次只读 transform accesses的Profiler截图</div><br>_</p><p>主线程再次在 <strong>ReadAfterJobScheduled</strong> 中被阻塞，因为它试图读取正在由 Job 使用的 Transform。我对这种阻塞行为感到惊讶，因为这些访问都是只读的，而且 Unity 可以通过 API 调用清楚地知道这一点。</p><p>这是 Unity 错过的一个优化机会：允许多个只读用户并行访问共享资源。理论上，Unity 可以让主线程无阻塞地读取 Transform 数据，并与其他只读 Job 并行运行，而不是让线程空闲。</p><hr><h3 id=死锁警告>死锁警告！</h3><p>截至目前，以下问题影响 Unity 版本 2022.3.31f1 至 2022.3.52f1，以及 6000.0.3f1 及以上版本。</p><p>如果你在上一场景中设置 <strong>Delay Job Start</strong> 为非零值，Unity 将会卡死无响应。<strong>ReadAfterJobScheduled</strong> 中的 Transform 读取访问永远不会完成，陷入死锁。</p><p>导致死锁的最小事件顺序如下：</p><ol><li>调度任意 Job A。</li><li>使用 <code>ScheduleReadOnly</code> 方法调度一个 <code>IJobParallelForTransform</code> 的Job B，它依赖于 Job A。</li><li>从主线程读取包含在 Job B 的 <code>TransformAccessArray</code> 中的某个 Transform 的位置。</li></ol><p>这是一个常见的 Job 使用模式，但由于依赖于具体的执行时机，这个 Bug 可能是间歇性的，难以在实际项目中诊断。</p><p>在我们分析《Toca Boca Days》游戏的“应用无响应”（ANR）问题时，最常见的调用栈就出现在访问 Transform 的代码中。由于我们大量使用了 <code>IJobParallelForTransform.ScheduleReadOnly</code>，我怀疑我在研究 <code>TransformAccessArray</code> 时，偶然发现了这些卡死的根本原因。 意外收获！</p><p>相关 Unity 工单：<a href=https://issuetracker.unity3d.com/issues/the-editor-freezes-when-schedulereadonly-of-ijobparallelfortransform-with-dependency-is-used>UUM-86782</a>。</p><hr><h3 id=单个transform根节点>单个Transform根节点</h3><p>我们再来看一个场景：只有一个根 Transform，但有很多子对象。我们将 <strong>Desired Job Count</strong> 设置为 -1，让 Unity 自己选择默认值。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:720/format:webp/0*R_dghwtvGHFewS_0><img src=https://miro.medium.com/v2/resize:fit:720/format:webp/0*R_dghwtvGHFewS_0 alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>单个根 Transform 的设置</div></p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*T58DTzZoRhQDCHeW><img src=https://miro.medium.com/v2/resize:fit:1100/format:webp/0*T58DTzZoRhQDCHeW alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>单个根 Transform 的Profiler截图</div><br>__</p><p>如前所述，主线程在 <strong>ReadAfterJobScheduled</strong> 中被阻塞。</p><p>由于 <strong>TransformJob</strong> 不是以只读方式调度的，而且整个 <code>TransformAccessArray</code> 只有一个 Transform 层级结构，Unity 不会将该 Job 分发到多个工作线程，导致 Job 执行时间非常长。</p><p>而 <strong>ReadOnlyJob</strong> 不受层级结构数量限制，被分成了 4 个较小的单元。不过，在某些帧中，<strong>ReadOnlyJob</strong> 会同时有 4 个或 5 个任务在执行。这种差异是因为 <code>TransformParallelForLoopStruct.Execute</code> 方法（这是每个线程在 C# 中的 Job 起始点）会<a href=https://github.com/Unity-Technologies/UnityCsReference/blob/2022.3/Runtime/Jobs/Managed/IJobParallelForTransform.cs>调用</a> <code>JobsUtility.GetWorkStealingRange</code> 来“偷取”其他线程的任务批次，直到所有任务完成。由于线程到达该代码的顺序是非确定性的，理论上我们可能会看到 1 到 5 个线程在执行该 Job。</p><hr><h2 id=transformaccessarray-job-性能最佳实践>TransformAccessArray Job 性能最佳实践</h2><p>以下是基于我的研究和分析得出的建议，适用于 Unity 2022.3.52f1 和 6000.0.26f1 版本。这些建议可以帮助你更好地利用 <code>TransformAccessArray</code> Job。</p><p>关于 Job System 的一般性最佳实践还有很多内容，但本文重点聚焦于访问 Transform 的 Job。我还是要给出一条通用建议：尽量使用<a href=https://docs.unity3d.com/Manual/com.unity.burst.html>Burst 编译器</a>。我的示例代码中没有使用它，因为它与我的研究无关，但在实际项目中你几乎总是应该使用它。</p><hr><h3 id=1-使用-schedulereadonly-调度只读-job>1. 使用 <code>ScheduleReadOnly</code> 调度只读 Job</h3><p>如果一个 Job 只需要读取 Transform 数据（即不写入），请务必使用 <code>IJobParallelForTransform.ScheduleReadOnly</code> 方法来调度它。这样可以获得更好的并行性。不过，请务必阅读前面的“死锁警告！”部分，因为当前 Unity 版本中存在一个严重的 Bug。</p><hr><h3 id=2-避免深层次的-transform-层级结构>2. 避免深层次的 Transform 层级结构</h3><p>尽可能将深层次的 Transform 层级结构拆分为多个根 Transform。务必避免“文件夹”式层级结构（即大量游戏对象挂在一个根节点下）。这条建议对 Unity 的许多系统和性能都有显著影响。对于使用 <code>TransformAccessArray</code> 的 Job，具体好处包括：</p><ul><li>为非只读 Job 提供更多并行化机会。Job System 不会将这类 Job 分发到更多（超过Transform 根节点数量）的工作线程上。【注：有n个根节点，那么最多只能分发到n个工作线程并行处理】</li><li>降低 Job 无意中阻塞主线程或产生“隐式” Job 依赖的可能性。记住，只要一个 Job 访问了某个 Transform 层级结构，而另一个 Job 也访问了同一个层级结构，那么后者必须等前者完成，即便它是只读的。</li></ul><hr><h3 id=3-在真机上分析-job-行为>3. 在真机上分析 Job 行为</h3><p>在目标硬件或代表性设备上，使用 Profiler 分析游戏中 Job 的行为。不同平台和构建配置下的性能瓶颈可能完全不同。如果你发现某些帧中，<code>TransformAccessArray</code> Job 的工作线程数量少于预期，请检查是否有限制并行性的因素，并审查你使用的 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccessArray-ctor.html>desiredJobCount</a> 和 <a href=https://docs.unity3d.com/ScriptReference/Unity.Jobs.LowLevel.Unsafe.JobsUtility.ScheduleParallelForTransformReadOnly.html>innerloopBatchCount</a> 参数。你应设置足够小的值以保持所有工作线程忙碌，但又不能太小，以免线程频繁地抓取或偷取任务。这里没有放之四海而皆准的值。作为参考，Unity 默认为非只读 Job 设置的最小 Transform 数量为 32，而所有并行 Job 的最大任务批次数量为 16。</p><hr><h3 id=4-优先使用局部空间数据>4. 优先使用局部空间数据</h3><p>尽可能使用局部空间的 Transform 数据，例如 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccess-localPosition.html>localPosition</a> 和 <a href=http://getlocalpositionandrotation/>GetLocalPositionAndRotation</a>，而不是世界空间数据，如 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccess-position.html>position</a> 和 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccess-localToWorldMatrix.html>localToWorldMatrix</a>。这条建议适用于所有与 Transform 交互的场景，而不仅仅是 Job。Transform 层级结构存储的是局部空间的变换矩阵，因此局部空间值可以直接访问。而世界空间值需要 Unity 递归地乘以所有父节点的局部矩阵，每次访问时都会重新计算。这个过程比直接访问局部空间值慢得多，且随着父节点数量增加而变得更慢。如果必须使用世界空间值，请尽量减少调用次数，并使用 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccess.GetPositionAndRotation.html>GetPositionAndRotation</a> 和 <a href=https://docs.unity3d.com/ScriptReference/Jobs.TransformAccess.SetPositionAndRotation.html>SetPositionAndRotation</a>。</p><hr><h3 id=5-重用-transformaccessarray-实例>5. 重用 <code>TransformAccessArray</code> 实例</h3><p>在帧之间重用 <code>TransformAccessArray</code> 实例，不要无谓地重新创建。每次创建新实例时，Unity 都会分配内存、准备状态并对 Transform 进行排序，这些都会耗时。例如，如果你需要从数组中移除一个 Transform，请使用 <a href=https://docs.unity3d.com/2022.3/Documentation/ScriptReference/Jobs.TransformAccessArray.RemoveAtSwapBack.html>TransformAccessArray.RemoveAtSwapBack</a> 方法，而不是重新创建数组。不过，这里有一个关于 fence 的注意事项：当你修改一个已有的 <code>TransformAccessArray</code> 时，Unity 会触发一个同步点，等待所有之前使用该数组的 Job 完成。因此，也不要为了重用数组而引入隐式的 Job 依赖。</p><hr><h3 id=6-不要用-transform-存储中间数据>6. 不要用 Transform 存储中间数据</h3><p>不要使用 <code>TransformAccessArray</code> 中的 Transform 来存储 Job 之间的中间数据。与其他方式相比，Job 中访问 Transform 的速度相对较慢，且有阻塞主线程的风险，并行化机会也更少。理想情况下，Job 中只应在需要最新值时读取 Transform 数据，并且每帧最多写入一次 Transform。考虑专用的 <code>TransformAccessArray</code> Job 仅用于提取和输出 Transform 值，并使用临时的 <a href=https://docs.unity3d.com/ScriptReference/Unity.Collections.NativeArray_1.html>NativeArray</a> 存储中间数据。这种策略可以显著提升 Job 的并行性。</p><hr><h3 id=7-注意-transform-访问模式以避免阻塞>7. 注意 Transform 访问模式以避免阻塞</h3><p>这条建议可能是最难诊断和实施的，但影响可能非常明显。主线程通常是帧的<a href=https://en.wikipedia.org/wiki/Analysis_of_parallel_algorithms>critical path</a>，因此了解 <code>TransformAccessArray</code> Job 访问了哪些 Transform 层级结构，以及主线程何时访问这些层级结构，是非常重要的。如前面的场景所示，最坏的情况是：主线程在调度了一个访问某 Transform 层级结构的 Job 后不久，又试图访问同一个层级结构，从而导致阻塞。具体的解决方案因项目而异，但一个通用策略是：仔细规划主线程在帧中访问 Transform 的时机，并调整 Transform 层级结构以更好地匹配 Job 的执行图。</p><hr><h2 id=unity-job-system性能优化愿望清单>Unity Job System性能优化愿望清单</h2><p>在撰写本文的过程中，我发现了一些 Unity 的限制，我认为这些限制可以在不更改或极少更改 API 的情况下得到改进。如果实现，这些改进可以在一些常见场景中为用户带来性能提升。如果有 Unity Job System 的工程师看到，欢迎交流！</p><hr><h3 id=1-允许主线程与-job-并行只读访问-transform-层级结构>1. 允许主线程与 Job 并行只读访问 Transform 层级结构</h3><p>我相信 Unity 应该允许主线程与 Job 同时只读访问同一个 Transform 层级结构。我确信目前不这么做是有原因的，但在并行编程中，只读访问共享资源是非常常见的模式，而且在大多数环境中，只读访问比读写访问更高效。理论上，Unity 可以在不更改 API 的情况下实现这一改进，因为只读语义已经存在。</p><hr><h3 id=2-打破-transformaccessarray-job-对-transform-层级结构的整体依赖>2. 打破 <code>TransformAccessArray</code> Job 对 Transform 层级结构的“整体”依赖</h3><p>目前，一个 Job 必须等待所有之前访问过<strong>任何</strong>一个它所依赖的 Transform 层级结构的 Job 完成后才能开始。</p><p><figure><a data-fancybox=gallery href=https://miro.medium.com/v2/resize:fit:640/format:webp/1*mVoeXY42lSdFkDSGQU_7lQ.png><img src=https://miro.medium.com/v2/resize:fit:640/format:webp/1*mVoeXY42lSdFkDSGQU_7lQ.png alt=image></a><figcaption></figcaption></figure><br><div style=text-align:center>两个共享 Transform 层级结构的 Job</div></p><p>在上图中，<strong>Job A</strong> 访问了一个 Transform 层级结构，<strong>Job B</strong> 访问了同一个层级结构以及其他几个。由于这一个层级结构的重叠，<strong>Job B</strong> 必须等 <strong>Job A</strong> 完成后才能开始，即使 <strong>Job A</strong> 并不是 <strong>Job B</strong> 的显式依赖。</p><p>当然，在这个简单的例子中，可以将 <strong>Job B</strong> 拆成两部分：一部分受 <strong>Job A</strong> 阻塞，访问共同的层级结构；另一部分不受阻塞，访问其余层级结构。但在复杂场景中，这种做法很快就会变得难以管理。</p><p>Unity 可以为用户无缝处理这种复杂性。由于 <code>TransformAccessArray</code> 实例已经按 Transform 根节点对 Transform 进行了分组，Unity 应该可以在后台将 Job 拆分成多个部分，每个部分对应一个 Transform 层级结构。每个部分可以在其对应的层级结构 fence 解除阻塞后立即开始执行。虽然这可能会带来一些关于任务批次大小的微妙差异，但潜在的性能提升是值得的。</p><hr><h3 id=3-缓存-localtoworldmatrix-的计算结果>3. 缓存 <code>localToWorldMatrix</code> 的计算结果</h3><p>我还没有深入研究具体的实现，但也许 Transform 层级结构应该缓存最近一次计算的 <code>localToWorldMatrix</code> 值，这是所有其他世界空间 Transform 值的基础。在大多数访问世界空间值的 <code>TransformAccessArray</code> Job 中，这个值可能会被反复计算，而且随着层级结构加深，成本会越来越高。</p><hr><h2 id=结论>结论</h2><p>并行编程总是复杂的，而 Unity 又增加了一些“曲折”，了解这些细节对于榨干 Job System 的性能至关重要。本文中的不同场景模拟了你在实际游戏中可能遇到的情况，尽管真实项目中的复杂性更高。</p><p>有趣的是，我的研究还揭示了 Job System 中一个潜在的死锁问题，我认为这个问题在实际项目中可能相当普遍。我工作的《Toca Boca Days》游戏很可能就遇到了这个问题。希望我的 Bug 报告能成为 Unity 的一个修复，惠及整个 Unity 社区。</p><p>最后，再次强调：在你进行复杂的优化之前，<strong>请先分析你的游戏，找出真正的性能瓶颈</strong>！</p><p>Thanks to Fredrik Bergljung for your support and to an anonymous tech reviewer!</p></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/dots/>DOTS</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/unity/>Unity</a></li><li><a class=article-terms-link href=/tags/dots/>DOTS</a></li><li><a class=article-terms-link href=/tags/job-system/>Job System</a></li><li><a class=article-terms-link href=/tags/transformaccessarray/>TransformAccessArray</a></li></ul></div></footer></div></article><div class=pagination><a href=/blog/lua/hotreload/ class="button left"><span></span></a></div><div class=toc><div class=toc-title><i class="fas fa-bars fa-2x"></i></div><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#声明>声明</a></li><li><a href=#transformaccessarray的内部机制>TransformAccessArray的内部机制</a><ul><li><a href=#transform-层级访问的同步机制>Transform 层级访问的同步机制</a></li></ul></li><li><a href=#transformaccessarray测试脚本>TransformAccessArray测试脚本</a><ul><li><a href=#具有job依赖的transformaccessarrayjob>具有Job依赖的TransformAccessArrayJob</a></li><li><a href=#多次只读transformaccesses>多次只读TransformAccesses</a></li><li><a href=#死锁警告>死锁警告！</a></li><li><a href=#单个transform根节点>单个Transform根节点</a></li></ul></li><li><a href=#transformaccessarray-job-性能最佳实践>TransformAccessArray Job 性能最佳实践</a><ul><li><a href=#1-使用-schedulereadonly-调度只读-job>1. 使用 <code>ScheduleReadOnly</code> 调度只读 Job</a></li><li><a href=#2-避免深层次的-transform-层级结构>2. 避免深层次的 Transform 层级结构</a></li><li><a href=#3-在真机上分析-job-行为>3. 在真机上分析 Job 行为</a></li><li><a href=#4-优先使用局部空间数据>4. 优先使用局部空间数据</a></li><li><a href=#5-重用-transformaccessarray-实例>5. 重用 <code>TransformAccessArray</code> 实例</a></li><li><a href=#6-不要用-transform-存储中间数据>6. 不要用 Transform 存储中间数据</a></li><li><a href=#7-注意-transform-访问模式以避免阻塞>7. 注意 Transform 访问模式以避免阻塞</a></li></ul></li><li><a href=#unity-job-system性能优化愿望清单>Unity Job System性能优化愿望清单</a><ul><li><a href=#1-允许主线程与-job-并行只读访问-transform-层级结构>1. 允许主线程与 Job 并行只读访问 Transform 层级结构</a></li><li><a href=#2-打破-transformaccessarray-job-对-transform-层级结构的整体依赖>2. 打破 <code>TransformAccessArray</code> Job 对 Transform 层级结构的“整体”依赖</a></li><li><a href=#3-缓存-localtoworldmatrix-的计算结果>3. 缓存 <code>localToWorldMatrix</code> 的计算结果</a></li></ul></li><li><a href=#结论>结论</a></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><time class=published datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time></header></article><article class=mini-post><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><time class=published datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/optimization/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/optimization/>Unity性能优化技巧汇总</a></h2><time class=published datetime="2025-06-13 00:00:00 +0000 UTC">June 13, 2025</time></header></article><article class=mini-post><a href=/blog/urp/optimize/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/optimize/>Unity URP 优化技巧</a></h2><time class=published datetime="2025-02-20 00:00:00 +0000 UTC">February 20, 2025</time></header></article><article class=mini-post><a href=/blog/urp/postprocess_bloom/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/postprocess_bloom/>URP Bloom效果</a></h2><time class=published datetime="2024-03-13 00:00:00 +0000 UTC">March 13, 2024</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>4</span></a><li><a href=/categories/srp/>srp<span class=count>3</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>3</span></a><li><a href=/categories/urp/>urp<span class=count>3</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/dots/>dots<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/lua/>lua<span class=count>1</span></a><li><a href=/categories/optimize/>optimize<span class=count>1</span></a><li><a href=/categories/pathfinding/>pathfinding<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/unity/>unity<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2025 Lawliet<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.123.0>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.eb0ea17a4e466aecb46ab7eb91629704a76af4561dc6b12f55bf4a0ce072ee3d.js integrity="sha256-6w6hek5Gauy0arfrkWKXBKdq9FYdxrEvVb9KDOBy7j0="></script><script src=/js/add-on.js></script></div></body></html>