<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>【阅读笔记】HowToRTS - L-Lawliet's Blog</title>
<meta name=viewport content="width=device-width,initial-scale=1"><script>MathJax={tex:{inlineMath:[["$","$"]]},displayMath:[["$$","$$"],["[[","]]"]],svg:{fontCache:"global"}}</script><script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script><script id=MathJax-script async src=https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js></script><meta name=generator content="Hugo 0.123.0"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="【阅读笔记】HowToRTS"><meta property="og:description" content="阅读“HowToRTS”教程的研究笔记"><meta property="description" content="阅读“HowToRTS”教程的研究笔记"><meta property="og:url" content="https://l-lawliet.github.io/blog/readingnotes/howtorts/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.9e134d9a3da09f2b306d683d24be385b78bef43c5cadeed78b6b270ece12ee95.css integrity="sha256-nhNNmj2gnyswbWg9JL44W3i+9Dxcre7Xi2snDs4S7pU="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class='fa fa-home'></i> Home</a>
<a href=/about class="nav link"><i class='far fa-id-card'></i> About</a>
<a href=/blog class="nav link"><i class='far fa-newspaper'></i> Blog</a>
<a href=/categories class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
<a href=/fantasyfactor class="nav link"><i class='fa fa-tools'></i> Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu><a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu><menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;title=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;title=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;description=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><p>阅读“HowToRTS”教程的研究笔记</p></div><div class=meta><time datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time><p>Lawliet</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;title=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;title=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f&amp;description=%e3%80%90%e9%98%85%e8%af%bb%e7%ac%94%e8%ae%b0%e3%80%91HowToRTS" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2freadingnotes%2fhowtorts%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>阅读“flow-field-pathfinding”源码的研究笔记</p><h2 id=简介>简介</h2><p>教程地址：<a href=https://howtorts.github.io/>https://howtorts.github.io/</a></p><hr><h2 id=常用结构>常用结构</h2><h3 id=vector2>Vector2</h3><p>构造函数和静态属性</p><table><thead><tr><th>名称</th><th>类型</th><th>作用</th></tr></thead><tbody><tr><td><code>Vector2(x, y)</code></td><td>构造函数</td><td>创建一个二维向量对象，包含x和y坐标</td></tr><tr><td><code>Vector2.zero</code></td><td>静态属性</td><td>预定义的零向量 (0, 0)</td></tr><tr><td><code>Vector2.one</code></td><td>静态属性</td><td>预定义的单位向量 (1, 1)</td></tr></tbody></table><p>Vector2实例方法</p><table><thead><tr><th>方法名</th><th>参数</th><th>返回值</th><th>作用</th></tr></thead><tbody><tr><td><code>length()</code></td><td>无</td><td>Number</td><td>计算向量的长度（模长），等于到原点的距离</td></tr><tr><td><code>distanceTo(target)</code></td><td>Vector2</td><td>Number</td><td>计算当前向量到目标向量的欧几里得距离</td></tr><tr><td><code>normalize()</code></td><td>无</td><td>Vector2</td><td>返回当前向量的单位向量（方向相同，长度为1）</td></tr><tr><td><code>round()</code></td><td>无</td><td>Vector2</td><td>返回坐标四舍五入后的新向量</td></tr><tr><td><code>floor()</code></td><td>无</td><td>Vector2</td><td>返回坐标向下取整后的新向量</td></tr><tr><td><code>minus(other)</code></td><td>Vector2</td><td>Vector2</td><td>向量减法，返回两向量相减的结果</td></tr><tr><td><code>plus(other)</code></td><td>Vector2</td><td>Vector2</td><td>向量加法，返回两向量相加的结果</td></tr><tr><td><code>mul(scalar)</code></td><td>Number</td><td>Vector2</td><td>向量数乘，返回向量与标量相乘的结果</td></tr><tr><td><code>div(scalar)</code></td><td>Number</td><td>Vector2</td><td>向量除法，返回向量除以标量的结果</td></tr><tr><td><code>angle()</code></td><td>无</td><td>Number</td><td>返回向量的角度（以度为单位，相对于Y轴正方向）</td></tr></tbody></table><p>工厂函数</p><table><thead><tr><th>函数名</th><th>参数</th><th>返回值</th><th>作用</th></tr></thead><tbody><tr><td><code>vector2(x, y)</code></td><td>Array/Vector2</td><td>Vector2</td><td>工厂方法，可接受数组或Vector2对象，返回Vector2实例</td></tr></tbody></table><p>相关辅助类</p><table><thead><tr><th>类名</th><th>构造参数</th><th>主要方法</th><th>作用</th></tr></thead><tbody><tr><td><code>LineSegment</code></td><td>start, end</td><td><code>interpolatedPoint(percent)</code></td><td>表示线段，可进行插值计算</td></tr><tr><td><code>LineString</code></td><td>points数组</td><td>无</td><td>表示由多个点组成的折线，包含多个线段</td></tr></tbody></table><p><strong>注意</strong>：所有返回Vector2的方法都会创建新的向量对象，不会修改原向量（不可变性设计）。</p><h3 id=agent>Agent</h3><p>构造函数</p><table><thead><tr><th>名称</th><th>参数</th><th>作用</th></tr></thead><tbody><tr><td><code>Agent(pos)</code></td><td>pos (Vector2)</td><td>创建一个智能体对象，设置初始位置</td></tr></tbody></table><p>Agent属性</p><table><thead><tr><th>属性名</th><th>类型</th><th>默认值</th><th>作用</th></tr></thead><tbody><tr><td><code>position</code></td><td>Vector2</td><td>构造参数pos</td><td>智能体当前位置坐标</td></tr><tr><td><code>rotation</code></td><td>Number</td><td>0</td><td>智能体当前旋转角度</td></tr><tr><td><code>velocity</code></td><td>Vector2</td><td>Vector2.zero</td><td>智能体当前速度向量</td></tr><tr><td><code>maxForce</code></td><td>Number</td><td>5</td><td>最大加速度（这里假设单位质量为1，因此用力表示）</td></tr><tr><td><code>maxSpeed</code></td><td>Number</td><td>4</td><td>最大速度限制（网格单位/秒）</td></tr></tbody></table><hr><h2 id=follow-a-path>follow a path</h2><blockquote><p><a href=https://howtorts.github.io/2013/12/22/following-a-path.html>教程</a><br><a href=https://github.com/HowToRts/HowToRts.github.io/tree/master/examples/1-follow-a-path>源码</a></p></blockquote><p>这个用例比较简单，主要是讲述角色沿着固定路径移动。</p><pre tabindex=0><code>//game tick
//敌人移动
for (var i = enemies.length - 1; i &gt;= 0; i--) {
  var e = enemies[i];

  var distanceToMove = dt * e.speed; // 计算在当前时间间隔内敌人应移动的距离
  var vectorToTarget = path[e.pathIndex].minus(e.position); // 计算到下一个路径点的向量
  var distanceToTarget = vectorToTarget.length(); // 计算到下一个路径点的距离

  // 如果敌人在当前时间间隔内可以到达下一个路径点
  if (distanceToTarget &lt; distanceToMove) {
    e.position = path[e.pathIndex]; // 将敌人移动到下一个路径点
    e.pathIndex++; // 更新路径索引

    // 如果敌人到达路径终点
    if (e.pathIndex == path.length) {
      enemies.splice(i, 1); // 从敌人数组中移除该敌人
      continue;
    }

    // 重新计算到下一个路径点的移动距离和向量
    distanceToMove -= distanceToTarget;
    vectorToTarget = path[e.pathIndex].minus(e.position);
    distanceToTarget = vectorToTarget.length();
  }

  // 更新敌人的位置和旋转角度
  e.position = e.position.plus(vectorToTarget.normalize().mul(distanceToMove));
  e.rotation = vectorToTarget.angle();
}
</code></pre><hr><h2 id=generating-a-path-with-dijkstra>Generating a path with Dijkstra</h2><blockquote><p><a href=https://howtorts.github.io/2013/12/31/generating-a-path-dijkstra.html>教程</a><br><a href=https://github.com/HowToRts/HowToRts.github.io/tree/master/examples/2-dijkstra-path-building>源码</a></p></blockquote><p>这个教程主要讲述如何使用Dijkstra生成路径：</p><ol><li>先使用广度优先搜索（BFS）来生成Dijkstra网格</li><li>然后根据Dijkstra从起点开始生成移动路径</li><li>最后再使用上一篇文章的路径移动方案来控制敌人移动</li></ol><p>生成Dijkstra网格:</p><ol><li>将所有网格的权重改为空，表示未访问。</li><li>再将所有塔的网格权重改为Number最大值，表示为不可达。</li><li>将终点权重设置为0，然后放入到待访问列表。</li><li>每次从待访问列表里拿出节点（教程用了列表，BFS常见还是用队列比较好）。</li><li>遍历节点的四个方向邻居。</li><li>如果邻居节点未访问过，则设置其权重值为当前节点权重+1，并将邻居节点放入待访问列表。</li><li>重复执行4、5、6，直到待访问列表为空。</li></ol><blockquote><p>权重值就是节点到终点的曼哈顿距离。</p></blockquote><p>最后可得到整个网格所有节点到终点的距离（权重）。以下为教程源码：</p><pre tabindex=0><code>function generateDijkstraGrid() {
	// 生成一个空网格，所有位置的权重设置为 null（表示未访问）
	dijkstraGrid = new Array(gridWidth);
	for (var x = 0; x &lt; gridWidth; x++) {
		var arr = new Array(gridHeight);
		for (var y = 0; y &lt; gridHeight; y++) {
			arr[y] = null;
		}
		dijkstraGrid[x] = arr;
	}

	// 将塔的位置设置为权重 MAXINT（表示无法通过）
	for (var i = 0; i &lt; towers.length; i++) {
		var t = towers[i];
		dijkstraGrid[t.x][t.y] = Number.MAX_VALUE;
	}

	// 从终点开始进行洪水填充
	pathEnd.distance = 0;
	dijkstraGrid[pathEnd.x][pathEnd.y] = 0;

	var toVisit = [pathEnd]; // 待访问节点队列

	// 遍历待访问节点
	for (i = 0; i &lt; toVisit.length; i++) {
		var neighbours = neighboursOf(toVisit[i]); // 获取当前节点的邻居

		// 遍历邻居节点
		for (var j = 0; j &lt; neighbours.length; j++) {
			var n = neighbours[j];

			// 如果邻居节点未访问过
			if (dijkstraGrid[n.x][n.y] === null) {
				n.distance = toVisit[i].distance + 1; // 设置权重
				dijkstraGrid[n.x][n.y] = n.distance;
				toVisit.push(n); // 加入待访问队列
			}
		}
	}
}
</code></pre><p>根据Dijkstra生成移动路径：</p><ol><li>判断起点是否为未访问或者不可达，如果是则直接返回。</li><li>将起点放入到路径列表中，并将起点作为当前节点。</li><li>获取当前节点的四个方向邻居节点。</li><li>然后将最小权重的邻居节点放入路径列表中，并且作为下一个待访问节点。</li><li>重复步骤3、4，知道当前节点等于终点。</li></ol><p>最后可得到起点到终点的移动路径。以下为教程源码：</p><pre tabindex=0><code>while (at.x != pathEnd.x || at.y != pathEnd.y) {
	currentWeight = dijkstraGrid[at.x][at.y];

	var neighbours = neighboursOf(at); // 获取当前位置的所有邻居节点
	var next = null; // 用于存储下一个要移动到的节点
	var nextWeight = currentWeight; // 初始化下一个节点的权重为当前权重

	// 遍历所有邻居节点
	for (var i = 0; i &lt; neighbours.length; i++) {
		var neighbour = neighbours[i];
		var neighbourWeight = dijkstraGrid[neighbour.x][neighbour.y];

		// 如果邻居节点的权重小于当前权重
		if (neighbourWeight &lt; nextWeight) {
			next = neighbour; // 更新下一个节点
			nextWeight = neighbourWeight; // 更新下一个节点的权重
		}
	}

	path.push(next); // 将下一个节点加入路径
	at = next; // 更新当前位置为下一个节点
}
</code></pre><hr><h2 id=steering-behaviours-introduction>Steering Behaviours Introduction</h2><blockquote><p>教程：<a href=https://howtorts.github.io/2014/01/02/steering-introduction.html>Steering Behaviours Introduction</a><br>源码：<a href=hhttps://github.com/HowToRts/HowToRts.github.io/tree/master/examples/3-1-steering-behaviours-seek>3-1-steering-behaviours-seek</a><br>参考：<a href=https://gdcvault.com/play/1018262/The-Next-Vector-Improvements-in>The-Next-Vector-Improvements-in</a></p></blockquote><p>RTS游戏有以下的特点，单位不会互相穿透，可以避开障碍，并且像一个群体一样移动。因此这里使用到Steering Behaviours（转向行为）</p><p>常见行为：</p><ul><li>Seek（寻找）：向固定点移动</li><li>Flee（逃离）：远离固定点</li><li>Pursue（追击）：预测实体的未来位置并寻求拦截它</li><li>Evade（躲避）：预测实体的未来位置并逃跑避开它</li><li>Avoidance（回避）：避免撞到东西</li></ul><p>Seek转向行为：</p><pre tabindex=0><code>function steeringBehaviourSeek(agent) {
  // 使用终点减智能体当前坐标，得出指向向量（desired）
  var desired = destination.minus(agent.position);

  // 最大速度除以
  desired = desired.mul(agent.maxSpeed / desired.length());

  // 期望速度 - 当前速度 = 需要改变的“速度差”
  var force = desired.minus(agent.velocity);

  // 把速度差转换成实际可施加的力（按最大推力比例缩放）
  return force.mul(agent.maxForce / agent.maxSpeed);
}
</code></pre><p>Seek公式：</p>$$
\begin{aligned}
\vec{d} &= P_{dest} - P_{agent} \\\\
\vec{v}_{desired} &= \frac{\vec{d}}{|\vec{d}|} \cdot v_{max} \\\\
\vec{F} &= (\vec{v}_{desired} - \vec{v}_{agent}) \cdot \frac{F_{max}}{v_{max}} \\\\
\end{aligned}
$$<p>其中</p><ul><li>$P_{dest}$：目标位置</li><li>$P_{agent}$：智能体当前位置</li><li>$\vec{d}$：智能体当前位置指向终点的向量。</li><li>$v_{max}$：最大允许速度(量)</li><li>$F_{max}$：最大允许推力(量)</li></ul><p>最终返回的 $\vec{F}$ 就是施加在智能体上的转向力。</p><blockquote><p><strong>这里的公式与代码有一些差别：变量命名和公式顺序</strong><br>首先就是desired，在代码里面是一个变量，但在公式里面分别是<strong>指向终点的向量</strong>：$\vec{d}$ 和<strong>指向终点的速度</strong>：$v_{max}$。<br>代码为了优化是先计算$\frac{v_{max}}{|\vec{d}|}$，实际上这里是先求$\vec{d}$单位向量，然后再乘最大速度来求期望速度。</p></blockquote><blockquote><p>最后一条公式比较晦涩，因为<strong>力除以速度没有任何物理意义</strong>。如果加上质量就很清晰了：</p></blockquote>$$
\vec{F} = \vec{v}_{desired} - \vec{v}_{agent}
$$
$$
\begin{aligned}
F = ma \quad a = \frac{\Delta v}{\Delta t} \\\\
F = m\frac{\Delta v}{\Delta t} \\\\
\text{两边同除以} \Delta v\quad \frac{F}{\Delta v} = \frac{m}{\Delta t} \\\\
\end{aligned}
$$
$$
\begin{aligned}
\vec{F} &= (\vec{v}_{desired} - \vec{v}_{agent}) \cdot \frac{F_{max}}{v_{max}} \\\\
&= (\vec{v}_{desired} - \vec{v}_{agent}) \cdot \frac{m}{t} \\\\
&= \frac{\vec{v}_{desired} - \vec{v}_{agent}}{t} \cdot m
\end{aligned}
$$<blockquote><p>这样就可以理解为<strong>最大推力使物体达到最大速度所使用的时间，让物体转向到期望速度所需要的推力</strong>。</p></blockquote><p>移动智能体：</p><pre tabindex=0><code>// game tick
// 遍历并移动所有智能体（从后向前，便于动态增删）
for (var i = agents.length - 1; i &gt;= 0; i--) {
  var agent = agents[i];

  // 计算当前智能体的“寻找”行为力
  var seek = steeringBehaviourSeek(agent);

  // 将力施加到速度上（加速度积分）
  agent.velocity = agent.velocity.plus(seek.mul(dt));

  // 如果速度超过最大速度，则进行限速
  var speed = agent.velocity.length();
  if (speed &gt; agent.maxSpeed) {
      agent.velocity = agent.velocity.mul(agent.maxSpeed / speed);
  }

  // 根据速度方向更新朝向角度
  agent.rotation = agent.velocity.angle();

  // 根据当前速度移动位置
  agent.position = agent.position.plus(agent.velocity.mul(dt));
}
</code></pre><blockquote><p>这里获取到的seek其实就是seek返回的推力，由于忽略了质量（假设为1），因此后续计算直接乘以时间来获得推力方向的速度，最后再叠加到智能体当前速度，然后将最终速度限制在最大速度。</p></blockquote><hr><h2 id=steering-behaviours-flocking>Steering Behaviours: Flocking</h2><blockquote><p>教程：<a href=https://howtorts.github.io/2014/01/03/steering-flocking.html>Steering Behaviours: Flocking</a><br>源码：<a href=https://github.com/HowToRts/HowToRts.github.io/tree/master/examples/3-2-steering-behaviours-flock>3-2-steering-behaviours-flock</a></p></blockquote><p>群集行为是转向行为的一个子集，根据相邻智能体调整</p><p>群集行为：</p><ul><li>Separation（分离）：远离太过亲近的实体</li><li>Cohesion（凝聚）：靠近那些我们靠近但不够近的实体</li><li>Alignment（结盟）：改变方向，更加贴近邻居</li></ul><h3 id=separation分离>Separation（分离）</h3><p>实现代码：</p><pre tabindex=0><code>function steeringBehaviourSeparation(agent) {
	var totalForce = Vector2.zero;
	var neighboursCount = 0;

	for (var i = 0; i &lt; agents.length; i++) {
		var a = agents[i];
		if (a != agent) {
			var distance = agent.position.distanceTo(a.position);
			if (distance &lt; agent.neighbourRadius &amp;&amp; distance &gt; 0) {
				//Vector to other agent
				var pushForce = agent.position.minus(a.position);
				//Inverse scaled force (bigger the nearer we are)
				pushForce = pushForce.normalize().mul(1 - (pushForce.length() / agent.neighbourRadius)); 
				totalForce = totalForce.plus(pushForce);
				neighboursCount++;
			}
		}
	}

	if (neighboursCount == 0) {
		return Vector2.zero;
	}

	totalForce = totalForce.div(neighboursCount);
	return totalForce.mul(agent.maxForce);
}
</code></pre><blockquote><p>遍历所有智能体，然后挑选在生效半径内的邻居，求对应的分离力，最后将分离力求和。<br>最后需要除以生效邻居的数量进行平均，最后再乘以力的最大值得到最后的分离力。</p></blockquote><p>Separation公式：</p>$$
\begin{aligned}
\vec{d} &= \vec{p}_{\text{agent}} - \vec{p}_{\text{neighbour}} \\
{scale} &= 1 - \frac{|\vec{d}|}{r_\text{neighbour}} \\
\vec{F}_{\text{push}} &= \frac{\vec{d}}{|\vec{d}|} \cdot {scale} \\
\vec{F}_{\text{total}} &= \vec{F}_{\text{total}} + \vec{F}_{\text{push}}
\end{aligned}
$$<p>其中：</p><ul><li>$P_{agent}$：智能体当前位置</li><li>$P_{neighbour}$：邻居当前位置</li><li>$r_{neighbour}$：分离力的生效半径（内）</li><li>$\vec{d}$：邻居指向智能体的向量。</li><li>$scale$：根据距离计算的缩放量，距离越近，值越大</li><li>$F_{push}$：当前邻居所产生的分离力</li><li>$F_{total}$：所有邻居（在生效半径内）所产生的分离力</li></ul><blockquote><p>使用智能体和邻居获取分离力的单位方向，然后再根据距离和生效半径求分离力的比例来得到当前邻居产生的分离力。<br>后面就是平均分离力，然后再乘以$F_{max}$来得到最终的分离力</p></blockquote><blockquote><p><strong>这里单个scale不会超过1的，所有的分离力平均下来也不会超过1，因此最终的分离力不会超过$F_{max}$</strong></p></blockquote><h3 id=cohesion凝聚>Cohesion（凝聚）</h3><p>实现代码：</p><pre tabindex=0><code>function steeringBehaviourCohesion(agent) {
	//Start with just our position
	var centerOfMass = agent.position;
	var neighboursCount = 1;

	for (var i = 0; i &lt; agents.length; i++) {
		var a = agents[i];
		if (a != agent) {
			var distance = agent.position.distanceTo(a.position);
			if (distance &lt; agent.neighbourRadius) {
				//sum up the position of our neighbours
				centerOfMass = centerOfMass.plus(a.position);
				neighboursCount++;
			}
		}
	}

	if (neighboursCount == 1) {
		return Vector2.zero;
	}

	//Get the average position of ourself and our neighbours
	centerOfMass = centerOfMass.div(neighboursCount);

	//seek that position
	return steeringBehaviourSeek(agent, centerOfMass);
}
</code></pre><blockquote><p>遍历所有智能体，然后挑选在生效半径内的邻居，跟当前的智能体求一个平均的坐标位置作为聚集点，再使用之前提到的Seek对这个聚集点求吸引力。</p></blockquote><h3 id=alignment结盟>Alignment（结盟）</h3><p>结盟的运算跟凝聚类似，不过凝聚是智能体靠近邻居的平均位置。而结盟则是让智能体移动一致。</p><p>结盟代码：</p><pre tabindex=0><code>function steeringBehaviourAlignment(agent) {
	var averageHeading = Vector2.zero;
	var neighboursCount = 0;

	//for each of our neighbours (including ourself)
	for (var i = 0; i &lt; agents.length; i++) {
		var a = agents[i];
		var distance = agent.position.distanceTo(a.position);
		//That are within the max distance and are moving
		if (distance &lt; agent.neighbourRadius &amp;&amp; a.velocity.length() &gt; 0) {
			//Sum up our headings
			averageHeading = averageHeading.plus(a.velocity.normalize());
			neighboursCount++;
		}
	}

	if (neighboursCount == 0) {
		return Vector2.zero;
	}

	//Divide to get the average heading
	averageHeading = averageHeading.div(neighboursCount);

	//Steer towards that heading
	var desired = averageHeading.mul(agent.maxSpeed);
	var force = desired.minus(agent.velocity);
	return force.mul(agent.maxForce / agent.maxSpeed);
}
</code></pre><blockquote><p>遍历所有智能体，然后挑选在生效半径内的邻居，将邻居的速度方向想加求平均，得到一个结盟的期望速度方向，然后跟Seek一样，求出一个让智能体趋向于这个速度方向的推力。</p></blockquote><hr><h3 id=叠加所有力>叠加所有力</h3><p>前面分别做了Seek（寻找）、Separation（分离）、Cohesion（凝聚）、Alignment（结盟）四种作用力的计算，现在需要把它作用到智能体中，计算出最终的速度和位置。</p><p>首先要对作用力的计算和位移分开成两次循环，这是因为位移会影响到作用力的计算，确保每个智能体都是基于一致的情况来做出行为。</p><p>求作用力的代码：</p><pre tabindex=0><code>// game tick
// 遍历所有智能体

//Work out our behaviours
var seek = steeringBehaviourSeek(agent, destination);
var separation = steeringBehaviourSeparation(agent);
var cohesion = steeringBehaviourCohesion(agent);
var alignment = steeringBehaviourAlignment(agent);

//Combine them to come up with a total force to apply
agent.forceToApply = seek.plus(separation.mul(2)).plus(cohesion.mul(0.2)).plus(alignment.mul(0.5));

//Cap the force if required
if (agent.forceToApply.length() &gt; agent.maxForce) {
  agent.forceToApply = agent.forceToApply.normalize().mul(agent.maxForce);
}
</code></pre><blockquote><p>作者并没有把所有的力直接相加，这是因为这些作用力是有优先级的：<strong>例如凝聚中靠前面的智能体会有一个凝聚力向后拉扯，有可能导致它或者队伍没法达到最高速度。这种情况下，凝聚力的作用反而产生负面影响，所以作者的做法是对不同作用力加权相加，像凝聚力只需要少量，让队伍不至于分散就行。</strong></p></blockquote><p>接下来的循环跟之前一样，计算作用力产生的加速度，然后计算出智能体最新的位置、旋转即可。</p><hr><h3 id=优化>优化</h3><p>作者谈到几个问题和优化的方向：</p><ul><li>凝聚和结盟会让不同终点的单位互相拉扯，导致没法正确最快到达终点。可以只对相似终点的单位进行凝聚和结盟。（<strong>作者使用了相似，但这个相似是相对的，离终点越近，相似的阈值应该越低，这个参数并不好调</strong>）</li><li>重复遍历了智能体多次，时间复杂度较高，可以使用四叉树等空间搜索方法来优化。（<strong>这是常见的降时间复杂度方案了</strong>）</li><li>另外就是从频次入手去减少遍历智能体的耗时，某些转向行为重要性并不是特别高，所以实时性也可以相应降低，可以通过分帧处理来优化，没有计算的帧使用之前缓存。</li></ul><p>除了上述所说的，其实还有其他一些优化方向：</p><ul><li>上述的群聚行为，其实都是基于相同范围内的邻居，那其实可以预计算出邻居列表，然后再分发到每个转向行为进行计算。</li><li>作者的部分公式实现没有进一步优化，例如不直接用distanceTo计算距离来进行对比，变成计算距离的平方进行对比，这样少开一次根号了，后续也能直接使用向量。</li><li>计算分离力时，用的是线性函数。这里换成二次函数一样也能达到目的（分离力会更强，需要在后续适当降低权重）。这样的好处也是减少开根号。</li></ul><hr></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/pathfinding/>Pathfinding</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/%e5%af%bb%e8%b7%af/>寻路</a></li><li><a class=article-terms-link href=/tags/pathfinding/>Pathfinding</a></li><li><a class=article-terms-link href=/tags/flowfield/>FlowField</a></li><li><a class=article-terms-link href=/tags/algorithm/>Algorithm</a></li><li><a class=article-terms-link href=/tags/rts/>RTS</a></li></ul></div></footer></div></article><div class=pagination><a href=/blog/unity3d/optimization/ class="button right"><span>Unity性能优化技巧汇总</span></a></div><div class=toc><div class=toc-title><i class="fas fa-bars fa-2x"></i></div><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#简介>简介</a></li><li><a href=#常用结构>常用结构</a><ul><li><a href=#vector2>Vector2</a></li><li><a href=#agent>Agent</a></li></ul></li><li><a href=#follow-a-path>follow a path</a></li><li><a href=#generating-a-path-with-dijkstra>Generating a path with Dijkstra</a></li><li><a href=#steering-behaviours-introduction>Steering Behaviours Introduction</a></li><li><a href=#steering-behaviours-flocking>Steering Behaviours: Flocking</a><ul><li><a href=#separation分离>Separation（分离）</a></li><li><a href=#cohesion凝聚>Cohesion（凝聚）</a></li><li><a href=#alignment结盟>Alignment（结盟）</a></li><li><a href=#叠加所有力>叠加所有力</a></li><li><a href=#优化>优化</a></li></ul></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><time class=published datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/optimization/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/optimization/>Unity性能优化技巧汇总</a></h2><time class=published datetime="2025-06-13 00:00:00 +0000 UTC">June 13, 2025</time></header></article><article class=mini-post><a href=/blog/urp/optimize/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/optimize/>Unity URP 优化技巧</a></h2><time class=published datetime="2025-02-20 00:00:00 +0000 UTC">February 20, 2025</time></header></article><article class=mini-post><a href=/blog/urp/postprocess_bloom/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/postprocess_bloom/>URP Bloom效果</a></h2><time class=published datetime="2024-03-13 00:00:00 +0000 UTC">March 13, 2024</time></header></article><article class=mini-post><a href=/blog/lua/fulluserdataexperiment/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/lua/fulluserdataexperiment/>lua fulluserdata代替table的尝试</a></h2><time class=published datetime="2024-02-29 00:00:00 +0000 UTC">February 29, 2024</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>4</span></a><li><a href=/categories/srp/>srp<span class=count>3</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>3</span></a><li><a href=/categories/urp/>urp<span class=count>3</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/lua/>lua<span class=count>1</span></a><li><a href=/categories/optimize/>optimize<span class=count>1</span></a><li><a href=/categories/pathfinding/>pathfinding<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/unity/>unity<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2025 Lawliet<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.123.0>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.eb0ea17a4e466aecb46ab7eb91629704a76af4561dc6b12f55bf4a0ce072ee3d.js integrity="sha256-6w6hek5Gauy0arfrkWKXBKdq9FYdxrEvVb9KDOBy7j0="></script><script src=/js/add-on.js></script></div></body></html>