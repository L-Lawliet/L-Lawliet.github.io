<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Unity DOTS(Jobs) - L-Lawliet's Blog</title>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.123.0"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="Unity DOTS(Jobs)"><meta property="og:description" content="Unity DOTS(Jobs)"><meta property="description" content="Unity DOTS(Jobs)"><meta property="og:url" content="https://l-lawliet.github.io/blog/unity3d/dotsjobs/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.3f52c9f6ea16c0e2fe1ad716c9c0916180f27ec381c64f770a3061d312801376.css integrity="sha256-P1LJ9uoWwOL+GtcWycCRYYDyfsOBxk93CjBh0xKAE3Y="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class='fa fa-home'></i> Home</a>
<a href=/about class="nav link"><i class='far fa-id-card'></i> About</a>
<a href=/blog class="nav link"><i class='far fa-newspaper'></i> Blog</a>
<a href=/categories class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
<a href=/fantasyfactor class="nav link"><i class='fa fa-tools'></i> Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu><a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu><menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=Unity%20DOTS%28Jobs%29&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;description=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><p>Unity DOTS(Jobs)</p></div><div class=meta><time datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time><p>Lawliet</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=Unity%20DOTS%28Jobs%29&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;description=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>详细介绍Unity DOTS-Jobs的入门和技巧</p><h2 id=安装>安装</h2><ul><li>Unity版本：<strong>2020.3</strong></li><li>Jobs版本：<strong>0.50.1</strong></li><li>地址：<a href=https://docs.unity3d.com/Packages/com.unity.jobs@0.50/manual/index.html>Unity Jobs Package</a></li></ul><blockquote><p>打开<code>Package Manager</code>，使用<code>Add package from git URL</code>添加<code>com.unity.jobs</code>。<br>这样就能把想相关依赖包也加入。</p></blockquote><hr><h2 id=nativecontainer>NativeContainer</h2><blockquote><p>简单来说，Unity针对Jobs和Entities定义了一种可以在C#上安全访问原生内存的数据类型。它包含了一个指向非托管分配内存的指针，在Jobs环境下，Job可以通过NativeContainer安全的访问主线程共享（不是拷贝数据）的数据，提高了访问效率。<br><strong>注意：NativeContainer虽然包含了指向非托管分配内存的指针，但它自己是托管对象。</strong></p></blockquote><p>NativeContainer实际上是符合NativeContainer安全的数据结构统称，包括以下几种：</p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>NativeArray</td><td>Array的NativeContainer形式</td></tr><tr><td>NativeList</td><td>List的NativeContainer形式</td></tr><tr><td>NativeHashMap</td><td>HashMap的NativeContainer形式</td></tr><tr><td>NativeMultiHashMap</td><td>一对多HashMap的NativeContainer形式</td></tr><tr><td>NativeQueue</td><td>Queue的NativeContainer形式</td></tr></tbody></table><h3 id=分配器allocator>分配器（Allocator）</h3><p>当创建一个NativeContainer时，你必须指定你需要的内存分配类型。分配的类型由jobs运行的时间来决定。这种情况下你可以在每一种情况下使分配器达到可能的最好性能。</p><p>这里对于NativeContainer的内存分配有三个分配器类型。当你初始化你的NativeContainer时你需要指定一个合适的分配器。</p><ul><li><strong>Allocator.Temp</strong>：是<code>最快的分配类型</code>。它适用于分配一个生命周期只有一帧或更短时间的操作。你不应当把一个分配器为Temp类型分配的NativeContainer传递给jobs使用。你同时需要在函数返回之前调用Dispose方法(例如MonoBehaviour.Update，或者其他从原生到托管代码的调用)</li><li><strong>Allocator.TempJob</strong>：是<code>速度介乎与Temp与Persistent之间的分配类型</code>。这是一个生命周期为四帧的内存分配而且它是线程安全的。如果你在四帧之内没有调用Dispose，控制台会打印一个由原生代码生成的警告信息。绝大部分小jobs使用这种类型的NativeContainer分配器。</li><li><strong>Allocator.Persistent</strong>：是最慢的分配类型，但它可以持续存在到你需要的时间，如果必要的话可以贯穿应用程序的整个生命周期。它是直接调用malloc的一个封装。长时间的jobs可以使用这种分配类型。当性能比较紧张的时候你不应当使用Persistent。</li></ul><h3 id=安全性系统>安全性系统</h3><p>安全性系统内置于所有NativeContainer类型，它会追踪所有关于任何NaiveContainer的读写。</p><blockquote><p>注意：<strong>所有安全性检查只在Unity编辑器下可用</strong>。</p></blockquote><p>安全性系统是由DisposeSentinel和AtomicSafetyHandle组成：</p><ul><li><p><strong>DisposeSentinel</strong>：内存泄漏检测，不过只会在内存泄漏的发生很久之后触发错误。</p></li><li><p><strong>AtomicSafetyHandle</strong>：原子安全检测，对写入冲突进行检查，如果两个及以上的Jobs同时对同一个NaiveContainer写入数据，就会抛出异常。需要等上一个job写入完成后，下一个才能安全写入。读取则不受限制，可以并行读取。</p></li></ul><blockquote><p>默认情况下，job声明了NaiveContainer之后就拥有读写权限，这样会降低读写访问性能。如果job不用写入操作可以添加<code>[ReadOnly]</code>特性。</p></blockquote><pre tabindex=0><code class=language-Charp data-lang=Charp>[ReadOnly]
public NativeArray&lt;int&gt; input;
</code></pre><p>注意：这边没有针对从一个job中访问静态数据的保护。访问静态数据可以绕过所有的安全性系统并可能导致Unity奔溃。</p><h3 id=自定义nativecontainer>自定义NativeContainer</h3><blockquote><p>根据<a href=https://docs.unity3d.com/2020.3/Documentation/Manual/job-system-custom-nativecontainer-example.html>官方案例</a>做了一些调整（修改/屏蔽了2020.3缺少的API接口）：</p></blockquote><ul><li><code>UnsafeUtility.MallocTracked</code>改为<code>UnsafeUtility.Malloc</code>，去掉最后一个参数。</li><li><code>UnsafeUtility.FreeTracked</code>改为<code>UnsafeUtility.Free</code>，去掉最后一个参数。</li><li>屏蔽<code>UnsafeUtility.IsNativeContainerType&lt;T></code>调用</li><li>屏蔽<code>AtomicSafetyHandle.SetNestedContainer</code>调用</li></ul><blockquote><p>首先是定义NativeContainer结构，有以下条件：</p></blockquote><ul><li>struct类型</li><li>有unsafe标签</li><li>需要标记<code>[NativeContainer]</code>特性，告诉JobSystem这是拥有AtomicSafetyHandle的容器</li><li>由于需要手动管理、释放内存，因此需要实现<code>IDisposable</code>接口</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#a6e22e>[NativeContainer]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>NativeAppendOnlyList</span>&lt;T&gt; : IDisposable <span style=color:#66d9ef>where</span> T : unmanaged
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>定义基础属性：</p></blockquote><ul><li>m_Buffer：容器的内存块指针，使用<code>[NativeDisableUnsafePtrRestriction]</code>特性解除了原生指针的限制</li><li>m_AllocatorLabel：<a href=/#分配器allocator>分配器</a></li><li>m_Safety：<a href=/#安全性系统>原子安全句柄</a></li><li>s_staticSafetyId：原子安全句柄的ID</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#a6e22e>    [NativeDisableUnsafePtrRestriction]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>void</span>* m_Buffer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>int</span> m_Length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> Allocator m_AllocatorLabel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> ENABLE_UNITY_COLLECTIONS_CHECKS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> AtomicSafetyHandle m_Safety;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> s_staticSafetyId = AtomicSafetyHandle.NewStaticSafetyId&lt;NativeAppendOnlyList&lt;T&gt;&gt;();
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><blockquote><p>申请内存/释放内存：<br>NativeContainer由于是采用非托管内存来管理数据，所以需要使用<code>UnsafeUtility.Malloc</code>和<code>UnsafeUtility.Free</code>来分配和释放。<br>为了确保内存块大小正确，还需要使用<code>UnsafeUtility.SizeOf&lt;T>()</code>来计算类型的内存大小。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>//申请内存</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> totalSize = UnsafeUtility.SizeOf&lt;T&gt;() * m_Length;
</span></span><span style=display:flex><span>m_Buffer = UnsafeUtility.Malloc(totalSize, UnsafeUtility.AlignOf&lt;T&gt;(), m_AllocatorLabel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//释放内存</span>
</span></span><span style=display:flex><span>UnsafeUtility.Free(m_Buffer, m_AllocatorLabel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//写入元素到指针的偏移位置</span>
</span></span><span style=display:flex><span>UnsafeUtility.WriteArrayElement(m_Buffer, m_Length++, <span style=color:#66d9ef>value</span>);
</span></span></code></pre></div><blockquote><p>原子安全句柄操作：<br>注意：涉及到AtomicSafetyHandle的需要包含在<code>ENABLE_UNITY_COLLECTIONS_CHECKS</code>里。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> ENABLE_UNITY_COLLECTIONS_CHECKS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//创建原子安全句柄</span>
</span></span><span style=display:flex><span>m_Safety = AtomicSafetyHandle.Create();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//设置ID</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.SetStaticSafetyId(<span style=color:#66d9ef>ref</span> m_Safety, s_staticSafetyId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//每次写入时，自动升级版本号</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.SetBumpSecondaryVersionOnScheduleWrite(m_Safety, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查读取权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckReadAndThrow(m_Safety)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查写入权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查解除释放权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckDeallocateAndThrow(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//释放句柄</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.Release(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><hr><h2 id=jobs>Jobs</h2><p>以上图片描述了整个Jobs的调度流程。</p><h3 id=job>Job</h3><p>常用的接口如下：</p><table><thead><tr><th>接口名称</th><th>作业数</th><th>线程</th><th>跨批次写入权限</th><th>说明</th></tr></thead><tbody><tr><td>IJob</td><td>单个</td><td>单个Worker线程</td><td>所有数据</td><td>与其他Job和主线程并行的单个作业</td></tr><tr><td>IJobParallelFor</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>将任务拆分成多个Job，在多个线程并行执行</td></tr><tr><td>IJobFor</td><td>多个</td><td>Run(Main线程)、<br>Schedule(单个Worker线程)<br>多个工作线程同时</td><td>当前index</td><td>可以理解为执行模式更灵活的IJobParallelFor</td></tr><tr><td>IJobParallelForBatch</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>[index, index + count)</td><td>可以理解为数据访问更灵活的IJobParallelFor。<br>每个Job可以处理多个索引的数据，而不只是当前索引的数据。</td></tr><tr><td>IJobParallelForDefer</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>可以理解为遍历次数能够动态调整的IJobParallelFor。<br>迭代长度可以为指针，在Schedule后可修改。</td></tr><tr><td>IJobParallelForFilter</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>用于过滤数据后对List元素进行删除或者添加。</td></tr><tr><td>IJobParallelForTransform</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>可以在Job访问Transform。</td></tr></tbody></table><blockquote><p>创建Job有以下几点要注意的：</p></blockquote><ul><li>Job一定是<code>struct</code></li><li>Job里使用的成员变量只能为<code>Blittable</code>类型或<code>NativeContainer</code>类型</li><li>使用的成员变量不能是引用对象（托管堆内存）</li><li>不能调用静态对象</li><li>只能在主线程调用的Unity接口无法使用</li></ul><blockquote><p>Jobs为了解决在多线程出现的数据竞争条件，会为每个Job发送一份数它需要操作的数据副本，而不是主线程中数据的引用，这有效隔离了数据。<br>由于复制数据是在原生环境操作，所以Job只能访问<code>Blittable</code>类型或<code>NativeContainer</code>类型。前者在托管环境和非托管环境传递不需要转换，而后者则直接使用UnsafeUtility.Malloc申请非托管内存。</p></blockquote><h3 id=ijob>IJob</h3><blockquote><p>根据示例，可以实现IJob接口，然后实现<code>Execute</code>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AddJob</span> : IJob
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> number;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i = <span style=color:#ae81ff>0</span>; i &lt; position.Length; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      result[i] = number + i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=schedule>Schedule</h3><blockquote><p>调度一个Job，此时会把Job放入（Job）队列，然后JobSystem会在这个Job的依赖（前置）Job完成之后（如果有依赖项）开始调用这个Job。<br>注意：只能在主线程调用<code>Schedule</code>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span>NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; result = <span style=color:#66d9ef>new</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt;(<span style=color:#ae81ff>10</span>, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AddJob job = <span style=color:#66d9ef>new</span> AddJob();
</span></span><span style=display:flex><span>job.number = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>job.result = result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对Job进行调度，然后拿到调度的句柄</span>
</span></span><span style=display:flex><span>JobHandle handle = jobData.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 等待Job完成</span>
</span></span><span style=display:flex><span>handle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Debug.Log(result[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>//Log: 100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 需要在最后手动释放NativeContainer</span>
</span></span><span style=display:flex><span>result.Dispose();
</span></span></code></pre></div><h3 id=jobhandle>JobHandle</h3><blockquote><p>当你调用<strong>Schedule</strong>方法时会返回一个JobHandle。它可以用来阻塞主线程等待完成，或者用来作为其他Job的前置依赖。<br>下面代码就展示了<strong>JobHandle</strong>的几种用法：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>// 调度Job a</span>
</span></span><span style=display:flex><span>JobHandle aJobHandle = aJob.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调度Job b，但需要依赖Job a（等待Job a完成）</span>
</span></span><span style=display:flex><span>JobHandle bJobHandle = bJob.Schedule(a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>JobHandle cJobHandle = cJob.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 可以将多个JobHandle合并成单个，然后作为其他Job的前置依赖（需要等待多个Job完成）</span>
</span></span><span style=display:flex><span>JobHandle bcJobHandle = JobHandle.CombineDependencies(bJobHandle, cJobHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>JobHandle dJobHandle = dJob.Schedule(bcJobHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 阻塞主线程，等待完成</span>
</span></span><span style=display:flex><span>dJobHandle.Complete();
</span></span></code></pre></div><blockquote><p>P.S. Job在调度时不会立刻开始执行，如果需要在主线程等待作业，并需要访问作业所使用的NativeContainer数据，可以调用Complete方法刷新内存缓存中的Job并开始执行，才可以确保后续逻辑运行时Job已经执行完成，才能在主线程安全的访问Job中的NativeContainer。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h3 id=ijobparallelfor>IJobParallelFor</h3><p>IJobParallelFor是并行Job的其中一个实现接口（后面版本还有IJobParallelForTransform等），它主要是把相同任务拆分成多个Job来同时执行。<br>在讲解IJobParallelFor前，首先要根据下图理解一些概念：</p><ul><li>Execute(n)：单个可执行的任务</li><li>Batch：多个任务（Execute(n)）集合</li><li>Batches：多个Batch的集合</li><li>Native Job：放置在Job Queue的原生作业，里面包含了一个Batches</li></ul><p><figure><a data-fancybox=gallery href=/img/Unity3D/DOTSJobs/400.svg><img src=/img/Unity3D/DOTSJobs/400.svg alt=Jobs></a><figcaption></figcaption></figure></p><p>根据官方图示，IJobParallelFor的执行流程如下：</p><ol><li>Main Thread：</li><li>在主线程创建的并行Job</li><li>根据ParallelFor Job的数据源长度，创建可执行的任务（Execute(n)），放入Data Source。</li><li>C# Job System<ol><li>将任务划分成多个Batch块，每个Batch有batchSize（innerloopBatchCount）个任务。</li></ol></li><li>Job Queue<ol><li>创建Native Job，放入Batch块</li><li>将Native Job放入到Job Queue</li></ol></li><li>Native Job System<ol><li>从Job Queue弹出Native Job，放入工作线程并执行其Batches</li><li>存储结果到Native内存（可以理解为Native Container）</li></ol></li></ol><blockquote><p>在调度IJobParallelFor时，需要设定数据源长度，这可以告诉Job System需要创建多少个任务（Execute方法），因为Job System无法知道哪个NativeContainer是数据源，也不知道数据源长度和任务数的关系。<br>举个例子就是：NativeArray每三个数据表示为一个三位坐标x、y、z，需要一起处理，那么创建的任务数就是<strong>NativeArray.Length/3</strong>，并不是<strong>NativeArray.Length</strong>。<br><strong>这里有一个限制，只要是[WriteOnly]的NativeArray/NativeList，写入index以外位置都会抛出异常。而[ReadOnly]没有这个限制。如果需要跨批次写入可以使用IJobParallelForBatch。</strong></p></blockquote><blockquote><p>在调度时还需要设置batchSize（innerloopBatchCount），这是告诉Job System单个batch的任务颗粒度是多少（也就是有多少个Execute方法）。由于一个Native Job在执行完之后会窃取其他的Native Job的剩余批次（一次只能窃取剩余批次的一半，以确保缓存局部性<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>）。<br>batchSize可以控制Job的数量，以及线程之间重新分配工作的细化程度。值设置的较小（例如1）可以使线程之间的工作分布更均匀，但也会带来一些开销，所以需要根据实际情况来设置这个值，如果单个任务较为简单，可以将值设置较大，如果单个任务较为复杂耗时，可以将值设置更小。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>//调度一个IJobParallelFor，将array作为数据源，将array.Length作为数据源长度。batchSize设置为64</span>
</span></span><span style=display:flex><span>parallelForJob.Schedule(array.Length, <span style=color:#ae81ff>64</span>);
</span></span></code></pre></div><h3 id=ijobfor>IJobFor</h3><p>IJobFor可以理解为执行模式更灵活的IJobParallelFor。他提供了三种调用方法：</p><ul><li>Run：直接在主线程顺序执行。还是会根据数据源长度来创建多个任务（Execute）</li><li>Schedule：可以在单个工作线程（或主线程）顺序执行。如果调用JobHandle.Complete方法会直接在主线程执行。</li><li>ScheduleParallel：根据官网描述跟IJobParallelFor.Schedule一样。</li></ul><blockquote><p>看起来IJobFor的用途并不广泛，所以篇章较少。</p></blockquote><hr><h3 id=ijobparallelforbatch>IJobParallelForBatch</h3><p>IJobParallelForBatch数据访问更灵活的IJobParallelFor。IJobParallelFor是无法在[WriteOnly]的NativeArray/NativeList中写入Index以外的数据。而有些情况下，需要写入到其他位置。<br>IJobParallelForBatch可以把数据以n为一组分配到一个Job，然后这个Job就可以处理[index, index + n]之间的数据。</p><p>通俗差异如下<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup>：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#66d9ef>void</span> IJobParallelFor.Schedule(<span style=color:#66d9ef>int</span> arrayLength, <span style=color:#66d9ef>int</span> innerloopBatchCount)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arrayLength; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Job.Execute(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>​</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> IJobParallelForBatch.Schedule(<span style=color:#66d9ef>int</span> arrayLength, <span style=color:#66d9ef>int</span> innerloopBatchCount)
</span></span><span style=display:flex><span>{        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; (arrayLength/innerloopBatchCount); i++)
</span></span><span style=display:flex><span>    {           
</span></span><span style=display:flex><span>        Job.Execute(i, innerloopBatchCount);            
</span></span><span style=display:flex><span>    }        
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h2 id=内存管理>内存管理</h2><h3 id=structlayout>StructLayout</h3><p>StructLayout是一个控制数据字段物理内存布局的特性，他可以添加到Class或者Struct中。</p><ul><li>LayoutKind：指定如何排列类或结构。使用<code>LayoutKind</code>的枚举值。</li><li>Pack：控制类或结构的数据字段在内存中的对齐方式。</li><li>Size：指示类或结构的绝对大小。</li><li>CharSet：指示在默认情况下是否应将类中的字符串数据字段作为LPWSTR或LPSTR进行封送处理。</li></ul><p>先来说一下LayoutKind：</p><ul><li>Auto：由运行库自动决定对象在内存中的布局方式，因为这是运行库内部规则根据不同运行环境决定的字段顺序和对齐方式，无法确保在非托管代码中的内存布局一致，因此对象无法传给托管代码以外使用。</li><li>Sequential：Class或者Struct中的字段会按其（声明）顺序在内存排列，编译器插入填充字节满足对齐要求。<ul><li>Sequential对于<code>blittable类型</code>，托管代码和非托管代码的内存布局一致，可以互相传递。</li><li>Sequential对于<code>非blittable类型</code>，托管代码不受影响，运行时会自动插入填充字节或调整字段顺序。而非托管代码则会按照声明顺序排序。与托管代码的内存布局可能不同，因此不能直接传递。</li></ul></li><li>Explicit：显式指定字段偏移量。<ul><li>Explicit对于<code>blittable类型</code>，托管代码和非托管代码的内存布局一致，都是根据字段偏移量来确定内存布局，可以互相传递。</li><li>Explicit对于<code>非blittable类型</code>，托管代码不受影响，运行时会自动插入填充字节或调整字段顺序。而非托管代码则会按照字段偏移量来确定内存布局。与托管代码的内存布局可能不同，因此不能直接传递。</li></ul></li></ul><p>默认值：</p><ul><li>Struct默认为Sequential，但拥有引用类型字段时，默认会变成LayoutKind.Auto。</li><li>Class默认为LayoutKind.Auto。</li></ul><h3 id=blittable>Blittable</h3><p>上文提及到Job的成员变量需要使用Blittable类型或者NativeContainer类型，这里说的<strong>Blittable</strong>是指那些在托管代码和非托管代码中为相同内存布局的类型总称，特点就是托管和非托管互相传递时不需要进行特殊转换。</p><ul><li>常见的Blittable：</li></ul><table><thead><tr><th style=text-align:center>类型名</th><th style=text-align:center>字段大小</th></tr></thead><tbody><tr><td style=text-align:center><code>System.Byte</code></td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><code>System.SByte</code></td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><code>System.Int16</code></td><td style=text-align:center>2</td></tr><tr><td style=text-align:center><code>System.UInt16</code></td><td style=text-align:center>2</td></tr><tr><td style=text-align:center><code>System.Int32</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.UInt32</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.Single</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.Int64</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.UInt64</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.Double</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.IntPtr</code></td><td style=text-align:center>4(32位) 或 8(64位)</td></tr><tr><td style=text-align:center><code>System.UIntPtr</code></td><td style=text-align:center>4(32位) 或 8(64位)</td></tr></tbody></table><ul><li><p>常见的Blittable复杂类型：</p><ul><li>Blittable基元类型的一维数组，如整数数组。但是，包含基元类型一维数组字段的类型并不是Blittable。</li><li>所有字段为<code>Blittable</code>的类型，并且使用<strong>LayoutKind.Sequential</strong>或<strong>LayoutKind.Explicit</strong>布局的Struct也是Blittable</li></ul></li><li><p>不是Blittable的情况：</p><ul><li>bool这个最容易理解错，true在不同平台可能会有不同值，对应的字节数可能是1、2或者4。</li><li>char涉及不同的编码。</li><li>对象引用不是Blittable类型，这包括本身是Blittable对象的引用数组。</li></ul></li><li><p>有疑问的情况：</p><ul><li>int[][]使用UnsafeUtility.IsBlittable判定为Blittable，这个跟官网描述不一致。</li><li>非Blittable的struct对象，其数组也判定为Blittable，这个也能笔者疑惑。</li></ul></li></ul><blockquote><p><strong>注意：有疑问的情况列举的是基于Unity的UnsafeUtility.IsBlittable接口返回结果，实际上.Net的官网描述跟Unity判定笔者是觉得有出入。</strong></p></blockquote><h3 id=原生内存分配>原生内存分配</h3><p>上文分别提到NativeContainer，分别使用了UnsafeUtility.SizeOf和UnsafeUtility.AlignOf两个接口，这两个接口都是分配原生内存时需要使用的接口。</p><ul><li><strong>UnsafeUtility.SizeOf</strong>是返回指定结构类型的总字节数，其中包括因为字段对齐而填充的字节。</li><li><strong>UnsafeUtility.AlignOf</strong>是指定结构类型在内存中所需的最小对齐大小。在分配内存时需要把结果告诉内存分配，从而确保数据结构正确对齐，提高访问速度。</li></ul><blockquote><p>SizeOf和AlignOf都跟StructLayout相关，AlignOf实际上是根据结构体最大字段字节和StructLayout.Pack取最小值得出来的，表示这个结构体的最小对齐大小。而SizeOf则是根据结构体的对齐内存和填充内字节后的实际字节数得到的。<sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup> <sup id=fnref:5><a href=#fn:5 class=footnote-ref role=doc-noteref>5</a></sup></p></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>JobSystemJobDependencies, <a href=https://docs.unity3d.com/cn/2020.3/Manual/JobSystemJobDependencies.html>https://docs.unity3d.com/cn/2020.3/Manual/JobSystemJobDependencies.html</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Why does cache locality matter for array performance?, <a href=https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance>https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>JobSystem API讲解, <a href=https://zhuanlan.zhihu.com/p/390598758>https://zhuanlan.zhihu.com/p/390598758</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>理解.NET结构体字段的内存布局, <a href=https://www.cnblogs.com/eventhorizon/p/18913041>https://www.cnblogs.com/eventhorizon/p/18913041</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:5><p>aligned_malloc实现内存对齐, <a href=https://blog.csdn.net/jin739738709/article/details/122992753>https://blog.csdn.net/jin739738709/article/details/122992753</a>&#160;<a href=#fnref:5 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/unity3d/>Unity3D</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/unity3d/>Unity3D</a></li><li><a class=article-terms-link href=/tags/dots/>DOTS</a></li><li><a class=article-terms-link href=/tags/entities/>Entities</a></li><li><a class=article-terms-link href=/tags/jobs/>Jobs</a></li><li><a class=article-terms-link href=/tags/burst/>Burst</a></li></ul></div></footer></div></article><div class=pagination><a href=/blog/readingnotes/howtorts/ class="button right"><span>【阅读笔记】HowToRTS</span></a></div><div class=toc><div class=toc-title><i class="fas fa-bars fa-2x"></i></div><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#安装>安装</a></li><li><a href=#nativecontainer>NativeContainer</a><ul><li><a href=#分配器allocator>分配器（Allocator）</a></li><li><a href=#安全性系统>安全性系统</a></li><li><a href=#自定义nativecontainer>自定义NativeContainer</a></li></ul></li><li><a href=#jobs>Jobs</a><ul><li><a href=#job>Job</a></li><li><a href=#ijob>IJob</a></li><li><a href=#schedule>Schedule</a></li><li><a href=#jobhandle>JobHandle</a></li><li><a href=#ijobparallelfor>IJobParallelFor</a></li><li><a href=#ijobfor>IJobFor</a></li><li><a href=#ijobparallelforbatch>IJobParallelForBatch</a></li></ul></li><li><a href=#内存管理>内存管理</a><ul><li><a href=#structlayout>StructLayout</a></li><li><a href=#blittable>Blittable</a></li><li><a href=#原生内存分配>原生内存分配</a></li></ul></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><time class=published datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time></header></article><article class=mini-post><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><time class=published datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/optimization/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/optimization/>Unity性能优化技巧汇总</a></h2><time class=published datetime="2025-06-13 00:00:00 +0000 UTC">June 13, 2025</time></header></article><article class=mini-post><a href=/blog/urp/optimize/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/optimize/>Unity URP 优化技巧</a></h2><time class=published datetime="2025-02-20 00:00:00 +0000 UTC">February 20, 2025</time></header></article><article class=mini-post><a href=/blog/urp/postprocess_bloom/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/postprocess_bloom/>URP Bloom效果</a></h2><time class=published datetime="2024-03-13 00:00:00 +0000 UTC">March 13, 2024</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>4</span></a><li><a href=/categories/srp/>srp<span class=count>3</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>3</span></a><li><a href=/categories/urp/>urp<span class=count>3</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/lua/>lua<span class=count>1</span></a><li><a href=/categories/optimize/>optimize<span class=count>1</span></a><li><a href=/categories/pathfinding/>pathfinding<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/unity/>unity<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2025 Lawliet<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.123.0>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.eb0ea17a4e466aecb46ab7eb91629704a76af4561dc6b12f55bf4a0ce072ee3d.js integrity="sha256-6w6hek5Gauy0arfrkWKXBKdq9FYdxrEvVb9KDOBy7j0="></script><script src=/js/add-on.js></script></div></body></html>