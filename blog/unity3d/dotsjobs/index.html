<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>Unity DOTS(Jobs) - L-Lawliet's Blog</title>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.123.0"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="Unity DOTS(Jobs)"><meta property="og:description" content="Unity DOTS(Jobs)"><meta property="description" content="Unity DOTS(Jobs)"><meta property="og:url" content="https://l-lawliet.github.io/blog/unity3d/dotsjobs/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.3f52c9f6ea16c0e2fe1ad716c9c0916180f27ec381c64f770a3061d312801376.css integrity="sha256-P1LJ9uoWwOL+GtcWycCRYYDyfsOBxk93CjBh0xKAE3Y="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class='fa fa-home'></i> Home</a>
<a href=/about class="nav link"><i class='far fa-id-card'></i> About</a>
<a href=/blog class="nav link"><i class='far fa-newspaper'></i> Blog</a>
<a href=/categories class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
<a href=/fantasyfactor class="nav link"><i class='fa fa-tools'></i> Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu><a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu><menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=Unity%20DOTS%28Jobs%29&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;description=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><p>Unity DOTS(Jobs)</p></div><div class=meta><time datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time><p>Lawliet</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=Unity%20DOTS%28Jobs%29&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;title=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f&amp;description=Unity%20DOTS%28Jobs%29" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2fdotsjobs%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>详细介绍Unity DOTS-Jobs的入门和技巧</p><h2 id=安装>安装</h2><ul><li>Unity版本：<strong>2020.3</strong></li><li>Jobs版本：<strong>0.50.1</strong></li><li>地址：<a href=https://docs.unity3d.com/Packages/com.unity.jobs@0.50/manual/index.html>Unity Jobs Package</a></li></ul><blockquote><p>打开<code>Package Manager</code>，使用<code>Add package from git URL</code>添加<code>com.unity.jobs</code>。<br>这样就能把想相关依赖包也加入。</p></blockquote><hr><h2 id=nativecontainer>NativeContainer</h2><blockquote><p>简单来说，Unity针对Jobs和Entities定义了一种可以在C#上安全访问原生内存的数据类型。它包含了一个指向非托管分配内存的指针，在Jobs环境下，Job可以通过NativeContainer安全的访问主线程共享（不是拷贝数据）的数据，提高了访问效率。<br><strong>注意：NativeContainer虽然包含了指向非托管分配内存的指针，但它自己是托管对象。</strong></p></blockquote><p>NativeContainer实际上是符合NativeContainer安全的数据结构统称，包括以下几种：</p><table><thead><tr><th>名称</th><th>介绍</th></tr></thead><tbody><tr><td>NativeArray</td><td>Array的NativeContainer形式</td></tr><tr><td>NativeList</td><td>List的NativeContainer形式</td></tr><tr><td>NativeHashMap</td><td>HashMap的NativeContainer形式</td></tr><tr><td>NativeMultiHashMap</td><td>一对多HashMap的NativeContainer形式</td></tr><tr><td>NativeQueue</td><td>Queue的NativeContainer形式</td></tr></tbody></table><h3 id=分配器allocator>分配器（Allocator）</h3><p>当创建一个NativeContainer时，你必须指定你需要的内存分配类型。分配的类型由jobs运行的时间来决定。这种情况下你可以在每一种情况下使分配器达到可能的最好性能。</p><p>这里对于NativeContainer的内存分配有三个分配器类型。当你初始化你的NativeContainer时你需要指定一个合适的分配器。</p><ul><li><strong>Allocator.Temp</strong>：是<code>最快的分配类型</code>。它适用于分配一个生命周期只有一帧或更短时间的操作。你不应当把一个分配器为Temp类型分配的NativeContainer传递给jobs使用。你同时需要在函数返回之前调用Dispose方法(例如MonoBehaviour.Update，或者其他从原生到托管代码的调用)</li><li><strong>Allocator.TempJob</strong>：是<code>速度介乎与Temp与Persistent之间的分配类型</code>。这是一个生命周期为四帧的内存分配而且它是线程安全的。如果你在四帧之内没有调用Dispose，控制台会打印一个由原生代码生成的警告信息。绝大部分小jobs使用这种类型的NativeContainer分配器。</li><li><strong>Allocator.Persistent</strong>：是最慢的分配类型，但它可以持续存在到你需要的时间，如果必要的话可以贯穿应用程序的整个生命周期。它是直接调用malloc的一个封装。长时间的jobs可以使用这种分配类型。当性能比较紧张的时候你不应当使用Persistent。</li></ul><h3 id=安全性系统>安全性系统</h3><p>安全性系统内置于所有NativeContainer类型，它会追踪所有关于任何NaiveContainer的读写。</p><blockquote><p>注意：<strong>所有安全性检查只在Unity编辑器下可用</strong>。</p></blockquote><p>安全性系统是由DisposeSentinel和AtomicSafetyHandle组成：</p><ul><li><p><strong>DisposeSentinel</strong>：内存泄漏检测，不过只会在内存泄漏的发生很久之后触发错误。</p></li><li><p><strong>AtomicSafetyHandle</strong>：原子安全检测，对写入冲突进行检查，如果两个及以上的Jobs同时对同一个NaiveContainer写入数据，就会抛出异常。需要等上一个job写入完成后，下一个才能安全写入。读取则不受限制，可以并行读取。</p></li></ul><blockquote><p>默认情况下，job声明了NaiveContainer之后就拥有读写权限，这样会降低读写访问性能。如果job不用写入操作可以添加<code>[ReadOnly]</code>特性。</p></blockquote><pre tabindex=0><code class=language-Charp data-lang=Charp>[ReadOnly]
public NativeArray&lt;int&gt; input;
</code></pre><p>注意：这边没有针对从一个job中访问静态数据的保护。访问静态数据可以绕过所有的安全性系统并可能导致Unity奔溃。</p><h3 id=自定义nativecontainer>自定义NativeContainer</h3><blockquote><p>根据<a href=https://docs.unity3d.com/2020.3/Documentation/Manual/job-system-custom-nativecontainer-example.html>官方案例</a>做了一些调整（修改/屏蔽了2020.3缺少的API接口）：</p></blockquote><ul><li><code>UnsafeUtility.MallocTracked</code>改为<code>UnsafeUtility.Malloc</code>，去掉最后一个参数。</li><li><code>UnsafeUtility.FreeTracked</code>改为<code>UnsafeUtility.Free</code>，去掉最后一个参数。</li><li>屏蔽<code>UnsafeUtility.IsNativeContainerType&lt;T></code>调用</li><li>屏蔽<code>AtomicSafetyHandle.SetNestedContainer</code>调用</li></ul><blockquote><p>首先是定义NativeContainer结构，有以下条件：</p></blockquote><ul><li>struct类型</li><li>有unsafe标签</li><li>需要标记<code>[NativeContainer]</code>特性，告诉JobSystem这是拥有AtomicSafetyHandle的容器</li><li>由于需要手动管理、释放内存，因此需要实现<code>IDisposable</code>接口</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#a6e22e>[NativeContainer]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>unsafe</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>NativeAppendOnlyList</span>&lt;T&gt; : IDisposable <span style=color:#66d9ef>where</span> T : unmanaged
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>定义基础属性：</p></blockquote><ul><li>m_Buffer：容器的内存块指针，使用<code>[NativeDisableUnsafePtrRestriction]</code>特性解除了原生指针的限制</li><li>m_AllocatorLabel：<a href=/#分配器allocator>分配器</a></li><li>m_Safety：<a href=/#安全性系统>原子安全句柄</a></li><li>s_staticSafetyId：原子安全句柄的ID</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#a6e22e>    [NativeDisableUnsafePtrRestriction]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>void</span>* m_Buffer;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>int</span> m_Length;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> Allocator m_AllocatorLabel;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> ENABLE_UNITY_COLLECTIONS_CHECKS
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> AtomicSafetyHandle m_Safety;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>internal</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>readonly</span> <span style=color:#66d9ef>int</span> s_staticSafetyId = AtomicSafetyHandle.NewStaticSafetyId&lt;NativeAppendOnlyList&lt;T&gt;&gt;();
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><blockquote><p>申请内存/释放内存：<br>NativeContainer由于是采用非托管内存来管理数据，所以需要使用<code>UnsafeUtility.Malloc</code>和<code>UnsafeUtility.Free</code>来分配和释放。<br>为了确保内存块大小正确，还需要使用<code>UnsafeUtility.SizeOf&lt;T>()</code>来计算类型的内存大小。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>//申请内存</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span> totalSize = UnsafeUtility.SizeOf&lt;T&gt;() * m_Length;
</span></span><span style=display:flex><span>m_Buffer = UnsafeUtility.Malloc(totalSize, UnsafeUtility.AlignOf&lt;T&gt;(), m_AllocatorLabel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//释放内存</span>
</span></span><span style=display:flex><span>UnsafeUtility.Free(m_Buffer, m_AllocatorLabel);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//写入元素到指针的偏移位置</span>
</span></span><span style=display:flex><span>UnsafeUtility.WriteArrayElement(m_Buffer, m_Length++, <span style=color:#66d9ef>value</span>);
</span></span></code></pre></div><blockquote><p>原子安全句柄操作：<br>注意：涉及到AtomicSafetyHandle的需要包含在<code>ENABLE_UNITY_COLLECTIONS_CHECKS</code>里。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#if</span> ENABLE_UNITY_COLLECTIONS_CHECKS
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//创建原子安全句柄</span>
</span></span><span style=display:flex><span>m_Safety = AtomicSafetyHandle.Create();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//设置ID</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.SetStaticSafetyId(<span style=color:#66d9ef>ref</span> m_Safety, s_staticSafetyId);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//每次写入时，自动升级版本号</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.SetBumpSecondaryVersionOnScheduleWrite(m_Safety, <span style=color:#66d9ef>true</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查读取权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckReadAndThrow(m_Safety)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查写入权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckWriteAndThrow(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//检查解除释放权限</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.CheckDeallocateAndThrow(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//释放句柄</span>
</span></span><span style=display:flex><span>AtomicSafetyHandle.Release(m_Safety);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>#endif</span>
</span></span></code></pre></div><hr><h2 id=jobs>Jobs</h2><p>以上图片描述了整个Jobs的调度流程。</p><h3 id=job>Job</h3><p>常用的接口如下：</p><table><thead><tr><th>接口名称</th><th>作业数</th><th>线程</th><th>跨批次写入权限</th><th>说明</th></tr></thead><tbody><tr><td>IJob</td><td>单个</td><td>单个Worker线程</td><td>所有数据</td><td>与其他Job和主线程并行的单个作业</td></tr><tr><td>IJobParallelFor</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>将任务拆分成多个Job，在多个线程并行执行</td></tr><tr><td>IJobFor</td><td>多个</td><td>Run(Main线程)、<br>Schedule(单个Worker线程)<br>多个工作线程同时</td><td>当前index</td><td>可以理解为执行模式更灵活的IJobParallelFor</td></tr><tr><td>IJobParallelForBatch</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>[index, index + count)</td><td>可以理解为数据访问更灵活的IJobParallelFor。<br>每个Job可以处理多个索引的数据，而不只是当前索引的数据。</td></tr><tr><td>IJobParallelForDefer</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>可以理解为遍历次数能够动态调整的IJobParallelFor。<br>可以传入NativeList，直到真正调度时才决定长度。</td></tr><tr><td>IJobParallelForFilter</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>用于过滤数据后对List元素进行删除或者添加。<strong>(未来版本已去掉)</strong></td></tr><tr><td>IJobParallelForTransform</td><td>多个</td><td>多个线程（Main/Worker）并行</td><td>当前index</td><td>可以在Job访问Transform。</td></tr></tbody></table><blockquote><p>创建Job有以下几点要注意的：</p></blockquote><ul><li>Job一定是<code>struct</code></li><li>Job里使用的成员变量只能为<code>Blittable</code>类型或<code>NativeContainer</code>类型</li><li>使用的成员变量不能是引用对象（托管堆内存）</li><li>不能调用静态对象</li><li>只能在主线程调用的Unity接口无法使用</li></ul><blockquote><p>Jobs为了解决在多线程出现的数据竞争条件，会为每个Job发送一份数它需要操作的数据副本，而不是主线程中数据的引用，这有效隔离了数据。<br>由于复制数据是在原生环境操作，所以Job只能访问<code>Blittable</code>类型或<code>NativeContainer</code>类型。前者在托管环境和非托管环境传递不需要转换，而后者则直接使用UnsafeUtility.Malloc申请非托管内存。</p></blockquote><h3 id=ijob>IJob</h3><blockquote><p>根据示例，可以实现IJob接口，然后实现<code>Execute</code>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AddJob</span> : IJob
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>float</span> number;
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>  <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute()
</span></span><span style=display:flex><span>  {
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>var</span> i = <span style=color:#ae81ff>0</span>; i &lt; position.Length; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>      result[i] = number + i;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>  }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><h3 id=schedule>Schedule</h3><blockquote><p>调度一个Job，此时会把Job放入（Job）队列，然后JobSystem会在这个Job的依赖（前置）Job完成之后（如果有依赖项）开始调用这个Job。<br>注意：只能在主线程调用<code>Schedule</code>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span>NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; result = <span style=color:#66d9ef>new</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt;(<span style=color:#ae81ff>10</span>, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>AddJob job = <span style=color:#66d9ef>new</span> AddJob();
</span></span><span style=display:flex><span>job.number = <span style=color:#ae81ff>100</span>;
</span></span><span style=display:flex><span>job.result = result;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 对Job进行调度，然后拿到调度的句柄</span>
</span></span><span style=display:flex><span>JobHandle handle = jobData.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 等待Job完成</span>
</span></span><span style=display:flex><span>handle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>Debug.Log(result[<span style=color:#ae81ff>0</span>]); <span style=color:#75715e>//Log: 100</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 需要在最后手动释放NativeContainer</span>
</span></span><span style=display:flex><span>result.Dispose();
</span></span></code></pre></div><h3 id=jobhandle>JobHandle</h3><blockquote><p>当你调用<strong>Schedule</strong>方法时会返回一个JobHandle。它可以用来阻塞主线程等待完成，或者用来作为其他Job的前置依赖。<br>下面代码就展示了<strong>JobHandle</strong>的几种用法：</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>// 调度Job a</span>
</span></span><span style=display:flex><span>JobHandle aJobHandle = aJob.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 调度Job b，但需要依赖Job a（等待Job a完成）</span>
</span></span><span style=display:flex><span>JobHandle bJobHandle = bJob.Schedule(a);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>JobHandle cJobHandle = cJob.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 可以将多个JobHandle合并成单个，然后作为其他Job的前置依赖（需要等待多个Job完成）</span>
</span></span><span style=display:flex><span>JobHandle bcJobHandle = JobHandle.CombineDependencies(bJobHandle, cJobHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>JobHandle dJobHandle = dJob.Schedule(bcJobHandle);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 阻塞主线程，等待完成</span>
</span></span><span style=display:flex><span>dJobHandle.Complete();
</span></span></code></pre></div><blockquote><p>P.S. Job在调度时不会立刻开始执行，如果需要在主线程等待作业，并需要访问作业所使用的NativeContainer数据，可以调用Complete方法刷新内存缓存中的Job并开始执行，才可以确保后续逻辑运行时Job已经执行完成，才能在主线程安全的访问Job中的NativeContainer。<sup id=fnref:1><a href=#fn:1 class=footnote-ref role=doc-noteref>1</a></sup></p></blockquote><h3 id=ijobparallelfor>IJobParallelFor</h3><p>IJobParallelFor是并行Job的其中一个实现接口（后面版本还有IJobParallelForTransform等），它主要是把相同任务拆分成多个Job来同时执行。<br>在讲解IJobParallelFor前，首先要根据下图理解一些概念：</p><ul><li>Execute(n)：单个可执行的任务</li><li>Batch：多个任务（Execute(n)）集合</li><li>Batches：多个Batch的集合</li><li>Native Job：放置在Job Queue的原生作业，里面包含了一个Batches</li></ul><p><figure><a data-fancybox=gallery href=/img/Unity3D/DOTSJobs/400.svg><img src=/img/Unity3D/DOTSJobs/400.svg alt=Jobs></a><figcaption></figcaption></figure></p><p>根据官方图示，IJobParallelFor的执行流程如下：</p><ol><li>Main Thread：</li><li>在主线程创建的并行Job</li><li>根据ParallelFor Job的数据源长度，创建可执行的任务（Execute(n)），放入Data Source。</li><li>C# Job System<ol><li>将任务划分成多个Batch块，每个Batch有batchSize（innerloopBatchCount）个任务。</li></ol></li><li>Job Queue<ol><li>创建Native Job，放入Batch块</li><li>将Native Job放入到Job Queue</li></ol></li><li>Native Job System<ol><li>从Job Queue弹出Native Job，放入工作线程并执行其Batches</li><li>存储结果到Native内存（可以理解为Native Container）</li></ol></li></ol><blockquote><p>在调度IJobParallelFor时，需要设定数据源长度，这可以告诉Job System需要创建多少个任务（Execute方法），因为Job System无法知道哪个NativeContainer是数据源，也不知道数据源长度和任务数的关系。<br>举个例子就是：NativeArray每三个数据表示为一个三位坐标x、y、z，需要一起处理，那么创建的任务数就是<strong>NativeArray.Length/3</strong>，并不是<strong>NativeArray.Length</strong>。<br><strong>这里有一个限制，只要是[WriteOnly]的NativeArray/NativeList，写入index以外位置都会抛出异常。而[ReadOnly]没有这个限制。如果需要跨批次写入可以使用IJobParallelForBatch。</strong></p></blockquote><blockquote><p>在调度时还需要设置batchSize（innerloopBatchCount），这是告诉Job System单个batch的任务颗粒度是多少（也就是有多少个Execute方法）。由于一个Native Job在执行完之后会窃取其他的Native Job的剩余批次（一次只能窃取剩余批次的一半，以确保缓存局部性<sup id=fnref:2><a href=#fn:2 class=footnote-ref role=doc-noteref>2</a></sup>）。<br>batchSize可以控制Job的数量，以及线程之间重新分配工作的细化程度。值设置的较小（例如1）可以使线程之间的工作分布更均匀，但也会带来一些开销，所以需要根据实际情况来设置这个值，如果单个任务较为简单，可以将值设置较大，如果单个任务较为复杂耗时，可以将值设置更小。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>//调度一个IJobParallelFor，将array作为数据源，将array.Length作为数据源长度。batchSize设置为64</span>
</span></span><span style=display:flex><span>parallelForJob.Schedule(array.Length, <span style=color:#ae81ff>64</span>);
</span></span></code></pre></div><h3 id=ijobfor>IJobFor</h3><p>IJobFor可以理解为执行模式更灵活的IJobParallelFor。他提供了三种调用方法：</p><ul><li>Run：直接在主线程顺序执行。还是会根据数据源长度来创建多个任务（Execute）</li><li>Schedule：可以在单个工作线程（或主线程）顺序执行。如果调用JobHandle.Complete方法会直接在主线程执行。</li><li>ScheduleParallel：根据官网描述跟IJobParallelFor.Schedule一样。</li></ul><blockquote><p>看起来IJobFor的用途并不广泛，所以篇章较少。</p></blockquote><hr><h3 id=ijobparallelforbatch>IJobParallelForBatch</h3><p>IJobParallelForBatch是数据访问更灵活的IJobParallelFor。IJobParallelFor是无法在[WriteOnly]的NativeArray/NativeList中写入Index以外的数据。而有些情况下，需要写入到其他位置。<br>IJobParallelForBatch可以把数据以n为一组分配到一个Job，然后这个Job就可以处理[index, index + n]之间的数据。</p><p>相当于如下差异：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span><span style=color:#75715e>//IJobParallelFor</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Schedule(<span style=color:#66d9ef>int</span> arrayLength, <span style=color:#66d9ef>int</span> innerloopBatchCount)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arrayLength; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        Job.Execute(i);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#960050;background-color:#1e0010>​</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//IJobParallelForBatch</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> ScheduleBatch(<span style=color:#66d9ef>int</span> arrayLength, <span style=color:#66d9ef>int</span> innerloopBatchCount)
</span></span><span style=display:flex><span>{        
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; arrayLength; i+=innerloopBatchCount)
</span></span><span style=display:flex><span>    {           
</span></span><span style=display:flex><span>        Job.Execute(i, innerloopBatchCount);            
</span></span><span style=display:flex><span>    }        
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p><strong>IJobParallelForBatch在后续版本迁移到<a href=https://docs.unity3d.com/Packages/com.unity.collections>com.unity.collections</a>里。</strong></p></blockquote><hr><h3 id=ijobparallelfordefer>IJobParallelForDefer</h3><p>IJobParallelForDefer跟IJobParallelFor的不同是，可以传入NativeList或长度的指针作为调度的参数，可以在真正调度时才确定迭代总次数。<br>这样的好处是，如果job是在中间（多线程下Schedule后不一定立刻调度）开始调度，他的长度就可以依赖前置的Job来决定。<br>而IJobParallelFor需要在一开始Schedule就确定了长度，是没法这样动态处理的。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 数据动态变化（可能是上一个Jobs决定的）</span>
</span></span><span style=display:flex><span>NativeList&lt;Instance&gt; instances; 
</span></span><span style=display:flex><span><span style=color:#75715e>// instances.Length在真正调度才确定</span>
</span></span><span style=display:flex><span>job.Schedule(instances, <span style=color:#ae81ff>64</span>); 
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>// 另外一种方式传入长度指针</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>int</span>* countRef = &amp;count
</span></span><span style=display:flex><span><span style=color:#75715e>// 调度时传入长度指针</span>
</span></span><span style=display:flex><span>job.Schedule(countRef, <span style=color:#ae81ff>64</span>); 
</span></span><span style=display:flex><span><span style=color:#75715e>// 之后更改长度</span>
</span></span><span style=display:flex><span>count = <span style=color:#ae81ff>128</span>;
</span></span></code></pre></div><blockquote><p>传入NativeList应该是比较常用的用法了，NativeList可能是基于前置IJobParallelForFilter输出的列表。<br>而传入指针的方式，笔者想象到实际的使用场景是把指针传入到前置job里面来修改，但应该不太常见。</p></blockquote><blockquote><p><strong>IJobParallelForDefer在后续版本迁移到<a href=https://docs.unity3d.com/Packages/com.unity.collections>com.unity.collections</a>里。</strong></p></blockquote><hr><h3 id=ijobparallelforfilter>IJobParallelForFilter</h3><p>IJobParallelForFilter用于过滤数据后对NativeList元素进行删除或者添加。他提供了两个常用方法，分别是：</p><ul><li>ScheduleFilter：传入NativeList&lt;T>，对NativeList进行迭代，判断NativeList&lt;T>[index]中的数据是否符合要求，不符合则进行删除。</li><li>ScheduleAppend：传入NativeList&lt;T>和总的迭代次数，判断对应索引的数据，然后对符合的索引进行添加。</li></ul><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>void</span> Filter()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; source = <span style=color:#66d9ef>new</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt;(count, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    NativeList&lt;<span style=color:#66d9ef>int</span>&gt; filters = <span style=color:#66d9ef>new</span> NativeList&lt;<span style=color:#66d9ef>int</span>&gt;(count, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    NativeList&lt;<span style=color:#66d9ef>int</span>&gt; appends = <span style=color:#66d9ef>new</span> NativeList&lt;<span style=color:#66d9ef>int</span>&gt;(<span style=color:#ae81ff>0</span>, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; count; i++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        source[i] = i + i / <span style=color:#ae81ff>10.0f</span>;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        filters.Add(i * <span style=color:#ae81ff>2</span>);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (filterOrAppend)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> filterJob = <span style=color:#66d9ef>new</span> FilterJob() { };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> filterHandle = filterJob.ScheduleFilter(filters, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        filterHandle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(filters.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; filters.Length; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(filters[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>else</span>
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> appendJob = <span style=color:#66d9ef>new</span> AppendJob() { source = source };
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>var</span> appendHandle = appendJob.ScheduleAppend(appends, count, <span style=color:#ae81ff>64</span>);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        appendHandle.Complete();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        Debug.Log(appends.Length);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; appends.Length; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            Debug.Log(appends[i]);
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    source.Dispose();
</span></span><span style=display:flex><span>    filters.Dispose();
</span></span><span style=display:flex><span>    appends.Dispose();
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[BurstCompile]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FilterJob</span> : IJobParallelForFilter
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#75715e>//在ScheduleFilter中，传入的index实际上NativeList&lt;T&gt;的值。这里是数据还是索引就取决于怎么使用。</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Execute(<span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(index &gt; <span style=color:#ae81ff>10</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[BurstCompile]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>AppendJob</span> : IJobParallelForFilter
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [ReadOnly]</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; source;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>bool</span> Execute(<span style=color:#66d9ef>int</span> index)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span>(source[index] &gt; <span style=color:#ae81ff>5</span>)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>return</span> <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>ScheduleFilter迭代的是NativeList中的元素，并不是根据NativeList长度来迭代。而迭代的元素是数据还是索引就取决于怎么使用，在例子里面就是数据。<br>ScheduleAppend的NativeList则不一样，添加的只能是迭代索引值，因为无法确认添加的内容是什么类型。<br>ScheduleAppend时的NativeList长度可以为0，这样可以减少内存占用，但随之带来的是在Job中扩容，性能会有一定影响。</p></blockquote><blockquote><p>另外要注意的：<strong>IJobParallelForFilter在后续版本迁移到<a href=https://docs.unity3d.com/Packages/com.unity.collections>com.unity.collections</a>里。最新版本将IJobParallelForFilter改名为IJobFilter</strong></p></blockquote><hr><h2 id=jobs进阶>Jobs进阶</h2><blockquote><p>展示Jobs的一些进阶用法。</p></blockquote><h3 id=nativelisttasparallelwriter>NativeList&lt;T>.AsParallelWriter()</h3><p>上述讲过的IJobParallelForFilter这个接口，它可以过滤数据，然后对符合的数据进行添加或者删除。实际上也可以使用NativeList&lt;T>.ParallelWriter()来满足添加元素的需求。</p><p>ParallelWriter提供了更自由的并行写入的方法，相对IJobParallelForFilter添加时只能添加索引，ParallelWriter能够添加任意内容。</p><p>AsParallelWriter()返回NativeList&lt;T>.ParallelWriter类型实例，然后我们将这个类传入到Job，然后在Job中使用ParallelWriter.AddNoResize添加元素。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span>NativeList&lt;<span style=color:#66d9ef>int</span>&gt; filterList = <span style=color:#66d9ef>new</span> NativeList&lt;<span style=color:#66d9ef>int</span>&gt;(expectedMax, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> filterJob = <span style=color:#66d9ef>new</span> FilterJob{ src = data, outIndex = filterList.AsParallelWriter() };
</span></span><span style=display:flex><span>filterJob.Schedule(data.Length, <span style=color:#ae81ff>64</span>).Complete();
</span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>
</span></span></span><span style=display:flex><span><span style=color:#a6e22e>[BurstCompile]</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>FilterJob</span> : IJobParallelFor
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [ReadOnly]</span> <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>float</span>&gt; src;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> NativeList&lt;<span style=color:#66d9ef>int</span>&gt;.ParallelWriter outIndex;   <span style=color:#75715e>// 并发写索引列表</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute(<span style=color:#66d9ef>int</span> i)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (src[i] &gt; <span style=color:#ae81ff>0.5f</span>)      <span style=color:#75715e>// 任意过滤条件</span>
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            outIndex.AddNoResize(i);
</span></span><span style=display:flex><span>        } 
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>AddNoResize()可以原子地把元素写到当前Length位置，然后把Length++。<br>注意：AddNoResize()不会进行扩容，因此需要在使用前预分配足够大的容量。<br>性能相对比Add要低，因为涉及到原子锁。</p></blockquote><hr><h3 id=nativelisttasdeferredjobarray>NativeList&lt;T>.AsDeferredJobArray()</h3><p>上述讲过的IJobParallelForDefer这个接口，它可以在正式调度时才确定长度。而Unity官方也提供了另外一种方式实现这个功能，那就是IJob + NativeList&lt;T>.AsDeferredJobArray()。（当然，这方案其实无法并行）</p><p>AsDeferredJobArray()主要作用是分配一个NativeArray&lt;T>实例，将数据指针指向原NativeList&lt;T>的数据。这样在IJob.Schedule()时，可以传入这个NativeArray，在实际调度时，才会确定具体长度。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-C# data-lang=C#><span style=display:flex><span>
</span></span><span style=display:flex><span>NativeList&lt;<span style=color:#66d9ef>int</span>&gt; filter = <span style=color:#66d9ef>new</span> NativeList&lt;<span style=color:#66d9ef>int</span>&gt;(maxCount, Allocator.TempJob);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//前面的Job对NativeList&lt;T&gt;进行数据过滤，例如IJobParallelForFilter的案例。</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//...</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#75715e>//使用</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>var</span> job = <span style=color:#66d9ef>new</span> SumJob{ indices = filter.AsDeferredJobArray(), data = data, sum = output };
</span></span><span style=display:flex><span>job.Schedule();
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>struct</span> <span style=color:#a6e22e>Sum</span> : IJob
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span><span style=color:#a6e22e>    [ReadOnly]</span> <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>int</span>&gt; indices;
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> NativeArray&lt;<span style=color:#66d9ef>int</span>&gt; data;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> Execute()
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        sum[<span style=color:#ae81ff>0</span>] = <span style=color:#ae81ff>0</span>;
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> i = <span style=color:#ae81ff>0</span>; i &lt; indices.Length; i++)
</span></span><span style=display:flex><span>        {
</span></span><span style=display:flex><span>            sum[<span style=color:#ae81ff>0</span>] += data[indices[i]];
</span></span><span style=display:flex><span>        }
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><blockquote><p>由于返回的NativeArray&lt;T>并不是NativeList&lt;T>的数据副本，因此不会出现多份内存，也不会增加拷贝的消耗。</p></blockquote><blockquote><p>特别注意的是：<strong>返回的NativeArray&lt;T>是别名，并不拥有数据内存，无需调用Dispose；等原NativeList&lt;T>销毁即可。</strong></p></blockquote><hr><h3 id=nativelisttasparallelreader>NativeList&lt;T>.AsParallelReader()</h3><p>AsParallelReader()可以快速的拿到NativeList&lt;T>的一个只读、无安全检查的只读NativeArray&lt;T>，跟AsDeferredJobArray()都不会产生拷贝或额外的内存分配。</p><p>它的长度在获取的那一刻就已经固定了，这点跟AsDeferredJobArray()有较大的差别，然后AsDeferredJobArray()可以写入，但AsParallelReader()是只读。</p><p>笔者能想到的一个作用就是传入GraphicBuffer时需要用NativeArray&lt;T>，无法使用NativeList&lt;T>，但Job很多时候需要使用NativeList&lt;T>来让内存更紧凑，例如传入的实例数据，这时候就可以使用AsParallelReader()方法。</p><blockquote><p>虽然这个只读NativeArray&lt;T>不能写入，但原NativeList&lt;T>修改数据（原长度部分的数据）时，由于是只读视图，所以仍然会影响到NativeArray&lt;T>的数据。</p></blockquote><blockquote><p>特别注意的是：<strong>返回的NativeArray&lt;T>是只读视图，并不拥有数据内存，无需调用Dispose；等原NativeList&lt;T>销毁即可。</strong></p></blockquote><blockquote><p><code>AsParallelReader()</code>在后续版本已更名为<code>AsReadOnly()</code>。</p></blockquote><hr><h2 id=内存管理>内存管理</h2><h3 id=structlayout>StructLayout</h3><p>StructLayout是一个控制数据字段物理内存布局的特性，他可以添加到Class或者Struct中。</p><ul><li>LayoutKind：指定如何排列类或结构。使用<code>LayoutKind</code>的枚举值。</li><li>Pack：控制类或结构的数据字段在内存中的对齐方式。</li><li>Size：指示类或结构的绝对大小。</li><li>CharSet：指示在默认情况下是否应将类中的字符串数据字段作为LPWSTR或LPSTR进行封送处理。</li></ul><p>先来说一下LayoutKind：</p><ul><li>Auto：由运行库自动决定对象在内存中的布局方式，因为这是运行库内部规则根据不同运行环境决定的字段顺序和对齐方式，无法确保在非托管代码中的内存布局一致，因此对象无法传给托管代码以外使用。</li><li>Sequential：Class或者Struct中的字段会按其（声明）顺序在内存排列，编译器插入填充字节满足对齐要求。<ul><li>Sequential对于<code>blittable类型</code>，托管代码和非托管代码的内存布局一致，可以互相传递。</li><li>Sequential对于<code>非blittable类型</code>，托管代码不受影响，运行时会自动插入填充字节或调整字段顺序。而非托管代码则会按照声明顺序排序。与托管代码的内存布局可能不同，因此不能直接传递。</li></ul></li><li>Explicit：显式指定字段偏移量。<ul><li>Explicit对于<code>blittable类型</code>，托管代码和非托管代码的内存布局一致，都是根据字段偏移量来确定内存布局，可以互相传递。</li><li>Explicit对于<code>非blittable类型</code>，托管代码不受影响，运行时会自动插入填充字节或调整字段顺序。而非托管代码则会按照字段偏移量来确定内存布局。与托管代码的内存布局可能不同，因此不能直接传递。</li></ul></li></ul><p>默认值：</p><ul><li>Struct默认为Sequential，但拥有引用类型字段时，默认会变成LayoutKind.Auto。</li><li>Class默认为LayoutKind.Auto。</li></ul><h3 id=blittable>Blittable</h3><p>上文提及到Job的成员变量需要使用Blittable类型或者NativeContainer类型，这里说的<strong>Blittable</strong>是指那些在托管代码和非托管代码中为相同内存布局的类型总称，特点就是托管和非托管互相传递时不需要进行特殊转换。</p><ul><li>常见的Blittable：</li></ul><table><thead><tr><th style=text-align:center>类型名</th><th style=text-align:center>字段大小</th></tr></thead><tbody><tr><td style=text-align:center><code>System.Byte</code></td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><code>System.SByte</code></td><td style=text-align:center>1</td></tr><tr><td style=text-align:center><code>System.Int16</code></td><td style=text-align:center>2</td></tr><tr><td style=text-align:center><code>System.UInt16</code></td><td style=text-align:center>2</td></tr><tr><td style=text-align:center><code>System.Int32</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.UInt32</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.Single</code></td><td style=text-align:center>4</td></tr><tr><td style=text-align:center><code>System.Int64</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.UInt64</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.Double</code></td><td style=text-align:center>8</td></tr><tr><td style=text-align:center><code>System.IntPtr</code></td><td style=text-align:center>4(32位) 或 8(64位)</td></tr><tr><td style=text-align:center><code>System.UIntPtr</code></td><td style=text-align:center>4(32位) 或 8(64位)</td></tr></tbody></table><ul><li><p>常见的Blittable复杂类型：</p><ul><li>Blittable基元类型的一维数组，如整数数组。但是，包含基元类型一维数组字段的类型并不是Blittable。</li><li>所有字段为<code>Blittable</code>的类型，并且使用<strong>LayoutKind.Sequential</strong>或<strong>LayoutKind.Explicit</strong>布局的Struct也是Blittable</li></ul></li><li><p>不是Blittable的情况：</p><ul><li>bool这个最容易理解错，true在不同平台可能会有不同值，对应的字节数可能是1、2或者4。</li><li>char涉及不同的编码。</li><li>对象引用不是Blittable类型，这包括本身是Blittable对象的引用数组。</li></ul></li><li><p>有疑问的情况：</p><ul><li>int[][]使用UnsafeUtility.IsBlittable判定为Blittable，这个跟官网描述不一致。</li><li>非Blittable的struct对象，其数组也判定为Blittable，这个也能笔者疑惑。</li></ul></li></ul><blockquote><p><strong>注意：有疑问的情况列举的是基于Unity的UnsafeUtility.IsBlittable接口返回结果，实际上.Net的官网描述跟Unity判定笔者是觉得有出入。</strong></p></blockquote><h3 id=原生内存分配>原生内存分配</h3><p>上文分别提到NativeContainer，分别使用了UnsafeUtility.SizeOf和UnsafeUtility.AlignOf两个接口，这两个接口都是分配原生内存时需要使用的接口。</p><ul><li><strong>UnsafeUtility.SizeOf</strong>是返回指定结构类型的总字节数，其中包括因为字段对齐而填充的字节。</li><li><strong>UnsafeUtility.AlignOf</strong>是指定结构类型在内存中所需的最小对齐大小。在分配内存时需要把结果告诉内存分配，从而确保数据结构正确对齐，提高访问速度。</li></ul><blockquote><p>SizeOf和AlignOf都跟StructLayout相关，AlignOf实际上是根据结构体最大字段字节和StructLayout.Pack取最小值得出来的，表示这个结构体的最小对齐大小。而SizeOf则是根据结构体的对齐内存和填充内字节后的实际字节数得到的。<sup id=fnref:3><a href=#fn:3 class=footnote-ref role=doc-noteref>3</a></sup> <sup id=fnref:4><a href=#fn:4 class=footnote-ref role=doc-noteref>4</a></sup></p></blockquote><div class=footnotes role=doc-endnotes><hr><ol><li id=fn:1><p>JobSystemJobDependencies, <a href=https://docs.unity3d.com/cn/2020.3/Manual/JobSystemJobDependencies.html>https://docs.unity3d.com/cn/2020.3/Manual/JobSystemJobDependencies.html</a>&#160;<a href=#fnref:1 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:2><p>Why does cache locality matter for array performance?, <a href=https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance>https://stackoverflow.com/questions/12065774/why-does-cache-locality-matter-for-array-performance</a>&#160;<a href=#fnref:2 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:3><p>理解.NET结构体字段的内存布局, <a href=https://www.cnblogs.com/eventhorizon/p/18913041>https://www.cnblogs.com/eventhorizon/p/18913041</a>&#160;<a href=#fnref:3 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li><li id=fn:4><p>aligned_malloc实现内存对齐, <a href=https://blog.csdn.net/jin739738709/article/details/122992753>https://blog.csdn.net/jin739738709/article/details/122992753</a>&#160;<a href=#fnref:4 class=footnote-backref role=doc-backlink>&#8617;&#xfe0e;</a></p></li></ol></div></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/unity3d/>Unity3D</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/unity3d/>Unity3D</a></li><li><a class=article-terms-link href=/tags/dots/>DOTS</a></li><li><a class=article-terms-link href=/tags/entities/>Entities</a></li><li><a class=article-terms-link href=/tags/jobs/>Jobs</a></li><li><a class=article-terms-link href=/tags/burst/>Burst</a></li></ul></div></footer></div></article><div class=pagination><a href=/blog/readingnotes/howtorts/ class="button right"><span>【阅读笔记】HowToRTS</span></a></div><div class=toc><div class=toc-title><i class="fas fa-bars fa-2x"></i></div><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#安装>安装</a></li><li><a href=#nativecontainer>NativeContainer</a><ul><li><a href=#分配器allocator>分配器（Allocator）</a></li><li><a href=#安全性系统>安全性系统</a></li><li><a href=#自定义nativecontainer>自定义NativeContainer</a></li></ul></li><li><a href=#jobs>Jobs</a><ul><li><a href=#job>Job</a></li><li><a href=#ijob>IJob</a></li><li><a href=#schedule>Schedule</a></li><li><a href=#jobhandle>JobHandle</a></li><li><a href=#ijobparallelfor>IJobParallelFor</a></li><li><a href=#ijobfor>IJobFor</a></li><li><a href=#ijobparallelforbatch>IJobParallelForBatch</a></li><li><a href=#ijobparallelfordefer>IJobParallelForDefer</a></li><li><a href=#ijobparallelforfilter>IJobParallelForFilter</a></li></ul></li><li><a href=#jobs进阶>Jobs进阶</a><ul><li><a href=#nativelisttasparallelwriter>NativeList&lt;T>.AsParallelWriter()</a></li><li><a href=#nativelisttasdeferredjobarray>NativeList&lt;T>.AsDeferredJobArray()</a></li><li><a href=#nativelisttasparallelreader>NativeList&lt;T>.AsParallelReader()</a></li></ul></li><li><a href=#内存管理>内存管理</a><ul><li><a href=#structlayout>StructLayout</a></li><li><a href=#blittable>Blittable</a></li><li><a href=#原生内存分配>原生内存分配</a></li></ul></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><time class=published datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time></header></article><article class=mini-post><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><time class=published datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/optimization/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/optimization/>Unity性能优化技巧汇总</a></h2><time class=published datetime="2025-06-13 00:00:00 +0000 UTC">June 13, 2025</time></header></article><article class=mini-post><a href=/blog/urp/optimize/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/optimize/>Unity URP 优化技巧</a></h2><time class=published datetime="2025-02-20 00:00:00 +0000 UTC">February 20, 2025</time></header></article><article class=mini-post><a href=/blog/urp/postprocess_bloom/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/postprocess_bloom/>URP Bloom效果</a></h2><time class=published datetime="2024-03-13 00:00:00 +0000 UTC">March 13, 2024</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>4</span></a><li><a href=/categories/srp/>srp<span class=count>3</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>3</span></a><li><a href=/categories/urp/>urp<span class=count>3</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/lua/>lua<span class=count>1</span></a><li><a href=/categories/optimize/>optimize<span class=count>1</span></a><li><a href=/categories/pathfinding/>pathfinding<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/unity/>unity<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2025 Lawliet<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.123.0>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.eb0ea17a4e466aecb46ab7eb91629704a76af4561dc6b12f55bf4a0ce072ee3d.js integrity="sha256-6w6hek5Gauy0arfrkWKXBKdq9FYdxrEvVb9KDOBy7j0="></script><script src=/js/add-on.js></script></div></body></html>