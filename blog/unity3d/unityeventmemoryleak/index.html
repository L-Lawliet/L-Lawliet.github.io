<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>UnityEvent引起的内存泄漏 - L-Lawliet's Blog</title>
<meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.123.0"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="UnityEvent引起的内存泄漏"><meta property="og:description" content="UnityEvent引起的内存泄漏"><meta property="description" content="UnityEvent引起的内存泄漏"><meta property="og:url" content="https://l-lawliet.github.io/blog/unity3d/unityeventmemoryleak/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.117c4e14c9b8daa31ad54ec336936771b908dcc3484aaa824ec5599ca02ee671.css integrity="sha256-EXxOFMm42qMa1U7DNpNncbkI3MNISqqCTsVZnKAu5nE="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class='fa fa-home'></i> Home</a>
<a href=/about class="nav link"><i class='far fa-id-card'></i> About</a>
<a href=/blog class="nav link"><i class='far fa-newspaper'></i> Blog</a>
<a href=/categories class="nav link"><i class='fas fa-sitemap'></i> Categories</a>
<a href=/fantasyfactor class="nav link"><i class='fa fa-tools'></i> Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu><a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu><menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;description=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/unity3d/unityeventmemoryleak/>UnityEvent引起的内存泄漏</a></h2><p>UnityEvent引起的内存泄漏</p></div><div class=meta><time datetime="2022-09-15 00:00:00 +0000 UTC">September 15, 2022</time><p>Lawliet</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f&amp;url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&amp;description=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&amp;body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/unity3d/unityeventmemoryleak/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>一个由UnityEvent缓存机制引起的内存泄漏问题</p><h2 id=前言>前言</h2><blockquote><p>笔者在开发项目时，发现在xLua Dispose时总是会有<code>DelegateBridge</code>没有移除的情况，而排查了一轮，发现就算是一个简单界面也会出现这种情况。<br>后来经过一轮排查，发现<code>Button</code>的点击事件触发了，就会出现无法移除<code>DelegateBridgeBase</code>，然后翻看了xLua的issue（<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>）发现很早就有这个问题，而且也有人提供了解决方案。</p></blockquote><h2 id=问题原因>问题原因</h2><p>首先这个问题归根到底是由<code>UnityEvent</code>的缓存机制导致：</p><blockquote><p>Unity在设计UnityEvent时，为其加了缓存机制，也就是上一次调用过的<code>Calls</code>会缓存起来，然后在<code>增加/删除</code>callback时，对缓存设置脏标记。然后在下一次触发事件时，在有变动时才会重新生成<code>Calls</code>。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#75715e>//这里截取Unity 2020.3.x版本UnityEvent.CS &lt;InvokableCallList&gt;类的片段</span>
</span></span><span style=display:flex><span><span style=color:#75715e>//与Issue中的版本代码有点差异，但机制大致相同</span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveListener(<span style=color:#66d9ef>object</span> targetObj, MethodInfo method)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toRemove = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>0</span>; index &lt; m_RuntimeCalls.Count; index++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m_RuntimeCalls[index].Find(targetObj, method))
</span></span><span style=display:flex><span>            toRemove.Add(m_RuntimeCalls[index]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    m_RuntimeCalls.RemoveAll(toRemove.Contains);
</span></span><span style=display:flex><span>    m_NeedsUpdate = <span style=color:#66d9ef>true</span>;
</span></span><span style=display:flex><span>}
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> List&lt;BaseInvokableCall&gt; PrepareInvoke()
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (m_NeedsUpdate)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        m_ExecutingCalls.Clear();
</span></span><span style=display:flex><span>        m_ExecutingCalls.AddRange(m_PersistentCalls);
</span></span><span style=display:flex><span>        m_ExecutingCalls.AddRange(m_RuntimeCalls);
</span></span><span style=display:flex><span>        m_NeedsUpdate = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>return</span> m_ExecutingCalls;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><p>那么问题就来，由于在每次<code>触发（Invoke）</code>事件前，才会重新生成<code>Calls</code>,就算之前已经对callback进行了<code>Remove</code>了，只要没有调用，缓存还会保留已经移除的函数。</p><h2 id=问题危害>问题危害</h2><h3 id=正常流程>正常流程</h3><p>在xLua框架中，lua需要监听C#的事件，需要把<code>function(lua)</code>设置到<code>LUA_REGISTRYINDEX</code>，并且把<code>引用</code>给到C#，C#再生成<code>Delegate</code>，然后把Delegate和引用封装到<code>DelegateBridge(C#)</code>对象中。<br>这样，只要把此Delegate绑定到对应的事件中，当事件触发后，就会调用此Delegate，再由<code>DelegateBridge</code>根据<code>引用</code>获取并调用<code>function(lua)</code>。</p><p>由于<code>DelegateBridge</code>只以弱引用的方式保存，所以当移除事件后，<code>Delegate</code>只与对应的<code>DelegateBridge</code>有引用关系，所以在下一轮GC即可销毁掉<code>DelegateBridge</code>，从而接触对应引用的<code>function(lua)</code>（将<code>function</code>从<code>LUA_REGISTRYINDEX</code>中释放掉）。</p><p>这个时候，lua gc就可以把<code>function</code>以及对应<code>upvalue</code>销毁（假设没有任何其他对象引用）。</p><h3 id=泄漏情况>泄漏情况</h3><p>上述都是<code>function(lua)</code>与<code>Delegate</code>绑定和释放的正常流程。而在<code>UnityEvent</code>内存泄漏的情况下，又会变得怎样呢？</p><p>这里我们加入比较常见的情景：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Lua data-lang=Lua><span style=display:flex><span><span style=color:#66d9ef>local</span> item <span style=color:#f92672>=</span> {}
</span></span><span style=display:flex><span>item.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>
</span></span><span style=display:flex><span>item.button <span style=color:#f92672>=</span> .... <span style=color:#75715e>--获取Button对象</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>item.button.onClick:AddListener(<span style=color:#66d9ef>function</span> ()
</span></span><span style=display:flex><span>    print(item.name)
</span></span><span style=display:flex><span><span style=color:#66d9ef>end</span>)
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>...<span style=color:#75715e>--一顿操作</span>
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>item.button.onClick:RemoveAllListeners()
</span></span></code></pre></div><p>根据前文，如果我们在移除前触发了点击事件，那么UnityEvent就会缓存了<code>Delegate</code>，从而保留了<code>DelegateBridge</code>。这个时候唯一办法就是等<code>button</code>释放掉，顺带把UnityEvent也释放，这样<code>DelegateBridge</code>才能给GC回收。</p><p>但是，我们<code>button</code>却给lua的table对象引用了，而这个table又是闭包函数的<code>upvalue</code>值，而最糟糕的是，这个闭包函数却给<code>DelegateBridge</code>引用了（通过<code>LUA_REGISTRYINDEX</code>）。所以，这个table以及<code>button(userdata)</code>都无法给GC回收。</p><p>那么现在就形成了一个死结，而这个死结只要有任何一处解开就可以完全解开了，但现在处处都无法解开。</p><h2 id=解决方案>解决方案</h2><h3 id=调用invoke>调用Invoke</h3><p>根据<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>，可以在RemoveAllListener之后，手动调用一次Invoke，这样就可以清除掉<code>Calls</code>。</p><blockquote><p>但此方法有个问题，假设<code>Button</code>在<code>Inspector</code>界面上绑定了持久化事件，就会多触发一次事件，可能会有意想不到的bug出现。<strong>所以不建议使用</strong></p></blockquote><h3 id=反射>反射</h3><p>根据<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>，其实可以通过反射去释放掉<code>UnityEvent</code>中的缓存。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> MethodInfo prepareInvoke;
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ReleaseUnusedListeners(<span style=color:#66d9ef>this</span> UnityEventBase unityEventBase)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>if</span> (prepareInvoke == <span style=color:#66d9ef>null</span>)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        BindingFlags flag = BindingFlags.Instance | BindingFlags.NonPublic;
</span></span><span style=display:flex><span>        Type type = unityEventBase.GetType();
</span></span><span style=display:flex><span>        prepareInvoke = type.GetMethod(<span style=color:#e6db74>&#34;PrepareInvoke&#34;</span>, flag);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    prepareInvoke.Invoke(unityEventBase, <span style=color:#66d9ef>null</span>);
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Lua data-lang=Lua><span style=display:flex><span>...
</span></span><span style=display:flex><span>item.button.onClick:RemoveAllListeners()
</span></span><span style=display:flex><span>item.button.onClick:ReleaseUnusedListeners()
</span></span></code></pre></div><blockquote><p>笔者在issue基础上进行了优化。<br>此方案副作用小，只要不忘记调用，就可以释放掉对应事件。笔者也是采用这套方案。<br>这里要注意的是，如果是采用<code>Generate</code>的方式，需要增加<code>ButtonClickedEvent</code>等参数的接口，不然xlua会找不到方法。</p></blockquote><h3 id=升级版本>升级版本</h3><p>UnityEvent这个内存泄漏的问题，在<code>Unity 2021.2.x</code>版本就已经修复了（吐槽：这个bug在2017年前就已经存在了）。</p><blockquote><p>Scripting: Fixed a memory leak happening when removing listeners from a UnityEvent that is never raised afterwards. <a href=https://issuetracker.unity3d.com/issues/memory-of-non-persistent-event-listeners-isnt-cleared-when-calling-unityeventbase-dot-removealllisteners>(1303095)</a><br>所以可以通过升级版进行修复。</p></blockquote><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=display:flex><span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveListener(<span style=color:#66d9ef>object</span> targetObj, MethodInfo method)
</span></span><span style=display:flex><span>{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> toRemove = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;();
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>0</span>; index &lt; m_RuntimeCalls.Count; index++)
</span></span><span style=display:flex><span>    {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>if</span> (m_RuntimeCalls[index].Find(targetObj, method))
</span></span><span style=display:flex><span>            toRemove.Add(m_RuntimeCalls[index]);
</span></span><span style=display:flex><span>    }
</span></span><span style=display:flex><span>    m_RuntimeCalls.RemoveAll(toRemove.Contains);
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    <span style=color:#75715e>// removals are done synchronously to avoid leaks</span>
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>var</span> newExecutingCalls = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;(m_PersistentCalls.Count + m_RuntimeCalls.Count);
</span></span><span style=display:flex><span>    newExecutingCalls.AddRange(m_PersistentCalls);
</span></span><span style=display:flex><span>    newExecutingCalls.AddRange(m_RuntimeCalls);
</span></span><span style=display:flex><span>    m_ExecutingCalls = newExecutingCalls;
</span></span><span style=display:flex><span>    m_NeedsUpdate = <span style=color:#66d9ef>false</span>;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/unity3d/>Unity3D</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/unity3d/>Unity3D</a></li><li><a class=article-terms-link href=/tags/xlua/>xLua</a></li><li><a class=article-terms-link href=/tags/unityevent/>UnityEvent</a></li><li><a class=article-terms-link href=/tags/%e7%96%91%e9%9a%be%e6%9d%82%e7%97%87/>疑难杂症</a></li></ul></div></footer></div></article><div class=pagination><a href=/blog/publish/buildios/ class="button left"><span>构建iOS包</span></a>
<a href=/blog/csharp/reflection/ class="button right"><span>C#知识点-反射</span></a></div><div class=toc><div class=toc-title><i class="fas fa-bars fa-2x"></i></div><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#问题原因>问题原因</a></li><li><a href=#问题危害>问题危害</a><ul><li><a href=#正常流程>正常流程</a></li><li><a href=#泄漏情况>泄漏情况</a></li></ul></li><li><a href=#解决方案>解决方案</a><ul><li><a href=#调用invoke>调用Invoke</a></li><li><a href=#反射>反射</a></li><li><a href=#升级版本>升级版本</a></li></ul></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/readingnotes/unitystransformaccessarray/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/unitystransformaccessarray/>【翻译】Unity的TransformAccessArray —— 内部机制与最佳实践</a></h2><time class=published datetime="2025-10-30 00:00:00 +0000 UTC">October 30, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/dotsjobs/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/dotsjobs/>Unity DOTS(Jobs)</a></h2><time class=published datetime="2025-09-02 00:00:00 +0000 UTC">September 2, 2025</time></header></article><article class=mini-post><a href=/blog/readingnotes/howtorts/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/readingnotes/howtorts/>【阅读笔记】HowToRTS</a></h2><time class=published datetime="2025-08-15 00:00:00 +0000 UTC">August 15, 2025</time></header></article><article class=mini-post><a href=/blog/unity3d/optimization/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/unity3d/optimization/>Unity性能优化技巧汇总</a></h2><time class=published datetime="2025-06-13 00:00:00 +0000 UTC">June 13, 2025</time></header></article><article class=mini-post><a href=/blog/urp/optimize/ class=image style="--bg-image:url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/optimize/>Unity URP 优化技巧</a></h2><time class=published datetime="2025-02-20 00:00:00 +0000 UTC">February 20, 2025</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>4</span></a><li><a href=/categories/srp/>srp<span class=count>3</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>3</span></a><li><a href=/categories/urp/>urp<span class=count>3</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/dots/>dots<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/lua/>lua<span class=count>1</span></a><li><a href=/categories/optimize/>optimize<span class=count>1</span></a><li><a href=/categories/pathfinding/>pathfinding<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/unity/>unity<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2025 Lawliet<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.123.0>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll()</script><script src=/js/bundle.min.df5169d5532373c6402852e9f977e2eca62d0fd6203b1476e8ab52e1f95115c3.js integrity="sha256-31Fp1VMjc8ZAKFLp+Xfi7KYtD9YgOxR26KtS4flRFcM="></script><script src=/js/add-on.js></script></div></body></html>