<!doctype html><html lang=zh-cn><head><meta charset=utf-8><title>UnityEvent引起的内存泄漏 - L-Lawliet's Blog</title><meta name=viewport content="width=device-width,initial-scale=1"><meta name=generator content="Hugo 0.74.2"><meta property="og:site_name" content="L-Lawliet's Blog"><meta property="og:title" content="UnityEvent引起的内存泄漏"><meta property="og:description" content="UnityEvent引起的内存泄漏"><meta property="description" content="UnityEvent引起的内存泄漏"><meta property="og:url" content="https://l-lawliet.github.io/blog/unity3d/unityeventmemoryleak/"><meta property="og:type" content="article"><meta property="og:image" content="https://l-lawliet.github.io/img/2021/09/title/01.jpg"><meta property="og:image:alt" content="Colourful"><link rel=stylesheet href=/css/bundle.min.4236f44c5bfc27f06f5bc069c012560137db73a0b6d71072cf8593e1948fc138.css integrity="sha256-Qjb0TFv8J/BvW8BpwBJWATfbc6C21xByz4WT4ZSPwTg="><link rel=stylesheet href=/css/add-on.css></head><body><header id=site-header><nav id=site-nav><h1 class=nav-title><a href=/ class=nav>博客</a></h1><menu id=site-nav-menu class="flyout-menu menu"><a href=/ class="nav link"><i class="fa fa-home"></i>Home</a>
<a href=/about class="nav link"><i class="far fa-id-card"></i>About</a>
<a href=/blog class="nav link"><i class="far fa-newspaper"></i>Blog</a>
<a href=/categories class="nav link"><i class="fas fa-sitemap"></i>Categories</a>
<a href=/fantasyfactor class="nav link"><i class="fa fa-tools"></i>Fantasy Factor</a>
<a href=#share-menu class="nav link share-toggle"><i class="fas fa-share-alt">&nbsp;</i>Share</a>
<a href=#search-input class="nav link search-toggle"><i class="fas fa-search">&nbsp;</i>Search</a></menu>
<a href=#search-input class="nav search-toggle"><i class="fas fa-search fa-2x">&nbsp;</i></a>
<a href=#share-menu class="nav share-toggle"><i class="fas fa-share-alt fa-2x">&nbsp;</i></a>
<a href=#lang-menu class="nav lang-toggle" lang=zh-cn>zh-cn</a>
<a href=#site-nav class="nav nav-toggle"><i class="fas fa-bars fa-2x"></i></a></nav><menu id=search class=menu><input id=search-input class="search-input menu"></input><div id=search-results class="search-results menu"></div></menu><menu id=lang-menu class="flyout-menu menu"><a href=# lang=zh-cn class="nav link active">中文 (zh-cn)</a>
<a href=/en lang=en class="nav no-lang link">English (en)</a></menu>
<menu id=share-menu class="flyout-menu menu"><h1>Share Post</h1><a href="//twitter.com/share?text=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f&url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&description=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></menu></header><div id=wrapper><section id=site-intro><a href=/><img src=https://l-lawliet.github.io/img/main/logo.jpg class=circle width=100 alt="Hugo Future Imperfect Slim"></a><header><h1>L-Lawliet's Blog</h1></header><main><p>记录游戏开发的点点滴滴</p></main><footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul></footer></section><main id=site-main><article><div class=post><header><div class=title><h2><a href=/blog/unity3d/unityeventmemoryleak/>UnityEvent引起的内存泄漏</a></h2><p>UnityEvent引起的内存泄漏</p></div><div class=meta><time datetime="2022-09-15 00:00:00 +0000 UTC">September 15, 2022</time><p>Lawliet</p><p>1 分钟</p></div></header><div id=socnet-share><a href="//twitter.com/share?text=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f&url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn twitter"><p>Twitter</p></a><a href="//www.facebook.com/sharer/sharer.php?u=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank rel=noopener class="nav share-btn facebook"><p>Facebook</p></a><a href="//www.reddit.com/submit?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn reddit"><p>Reddit</p></a><a href="//www.linkedin.com/shareArticle?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&title=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn linkedin"><p>LinkedIn</p></a><a href="//www.pinterest.com/pin/create/button/?url=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f&description=UnityEvent%e5%bc%95%e8%b5%b7%e7%9a%84%e5%86%85%e5%ad%98%e6%b3%84%e6%bc%8f" target=_blank rel=noopener class="nav share-btn pinterest"><p>Pinterest</p></a><a href="mailto:?subject=%e6%9f%a5%e7%9c%8b%e6%9c%ac%e6%96%87%e7%9a%84%e4%bd%9c%e8%80%85 Lawliet&body=https%3a%2f%2fl-lawliet.github.io%2fblog%2funity3d%2funityeventmemoryleak%2f" target=_blank class="nav share-btn email" data-proofer-ignore><p>Email</p></a></div><div class=content><a href=/blog/unity3d/unityeventmemoryleak/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><p>一个由UnityEvent缓存机制引起的内存泄漏问题</p><h2 id=前言>前言</h2><blockquote><p>笔者在开发项目时，发现在xLua Dispose时总是会有<code>DelegateBridge</code>没有移除的情况，而排查了一轮，发现就算是一个简单界面也会出现这种情况。
后来经过一轮排查，发现<code>Button</code>的点击事件触发了，就会出现无法移除<code>DelegateBridgeBase</code>，然后翻看了xLua的issue（<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>）发现很早就有这个问题，而且也有人提供了解决方案。</p></blockquote><h2 id=问题原因>问题原因</h2><p>首先这个问题归根到底是由<code>UnityEvent</code>的缓存机制导致：</p><blockquote><p>Unity在设计UnityEvent时，为其加了缓存机制，也就是上一次调用过的<code>Calls</code>会缓存起来，然后在<code>增加/删除</code>callback时，对缓存设置脏标记。然后在下一次触发事件时，在有变动时才会重新生成<code>Calls</code>。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=color:#75715e>//这里截取Unity 2020.3.x版本UnityEvent.CS &lt;InvokableCallList&gt;类的片段
</span><span style=color:#75715e>//与Issue中的版本代码有点差异，但机制大致相同
</span><span style=color:#75715e></span><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveListener(<span style=color:#66d9ef>object</span> targetObj, MethodInfo method)
{
    <span style=color:#66d9ef>var</span> toRemove = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;();
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>0</span>; index &lt; m_RuntimeCalls.Count; index++)
    {
        <span style=color:#66d9ef>if</span> (m_RuntimeCalls[index].Find(targetObj, method))
            toRemove.Add(m_RuntimeCalls[index]);
    }
    m_RuntimeCalls.RemoveAll(toRemove.Contains);
    m_NeedsUpdate = <span style=color:#66d9ef>true</span>;
}

...
<span style=color:#66d9ef>public</span> List&lt;BaseInvokableCall&gt; PrepareInvoke()
{
    <span style=color:#66d9ef>if</span> (m_NeedsUpdate)
    {
        m_ExecutingCalls.Clear();
        m_ExecutingCalls.AddRange(m_PersistentCalls);
        m_ExecutingCalls.AddRange(m_RuntimeCalls);
        m_NeedsUpdate = <span style=color:#66d9ef>false</span>;
    }

    <span style=color:#66d9ef>return</span> m_ExecutingCalls;
}
</code></pre></div><p>那么问题就来，由于在每次<code>触发（Invoke）</code>事件前，才会重新生成<code>Calls</code>,就算之前已经对callback进行了<code>Remove</code>了，只要没有调用，缓存还会保留已经移除的函数。</p><h2 id=问题危害>问题危害</h2><h3 id=正常流程>正常流程</h3><p>在xLua框架中，lua需要监听C#的事件，需要把<code>function(lua)</code>设置到<code>LUA_REGISTRYINDEX</code>，并且把<code>引用</code>给到C#，C#再生成<code>Delegate</code>，然后把Delegate和引用封装到<code>DelegateBridge(C#)</code>对象中。
这样，只要把此Delegate绑定到对应的事件中，当事件触发后，就会调用此Delegate，再由<code>DelegateBridge</code>根据<code>引用</code>获取并调用<code>function(lua)</code>。</p><p>由于<code>DelegateBridge</code>只以弱引用的方式保存，所以当移除事件后，<code>Delegate</code>只与对应的<code>DelegateBridge</code>有引用关系，所以在下一轮GC即可销毁掉<code>DelegateBridge</code>，从而接触对应引用的<code>function(lua)</code>（将<code>function</code>从<code>LUA_REGISTRYINDEX</code>中释放掉）。</p><p>这个时候，lua gc就可以把<code>function</code>以及对应<code>upvalue</code>销毁（假设没有任何其他对象引用）。</p><h3 id=泄漏情况>泄漏情况</h3><p>上述都是<code>function(lua)</code>与<code>Delegate</code>绑定和释放的正常流程。而在<code>UnityEvent</code>内存泄漏的情况下，又会变得怎样呢？</p><p>这里我们加入比较常见的情景：</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Lua data-lang=Lua><span style=color:#66d9ef>local</span> item <span style=color:#f92672>=</span> {}
item.name <span style=color:#f92672>=</span> <span style=color:#e6db74>&#34;name&#34;</span>
item.button <span style=color:#f92672>=</span> .... <span style=color:#75715e>--获取Button对象</span>

item.button.onClick:AddListener(<span style=color:#66d9ef>function</span> ()
    print(item.name)
<span style=color:#66d9ef>end</span>)

...<span style=color:#75715e>--一顿操作</span>

item.button.onClick:RemoveAllListeners()
</code></pre></div><p>根据前文，如果我们在移除前触发了点击事件，那么UnityEvent就会缓存了<code>Delegate</code>，从而保留了<code>DelegateBridge</code>。这个时候唯一办法就是等<code>button</code>释放掉，顺带把UnityEvent也释放，这样<code>DelegateBridge</code>才能给GC回收。</p><p>但是，我们<code>button</code>却给lua的table对象引用了，而这个table又是闭包函数的<code>upvalue</code>值，而最糟糕的是，这个闭包函数却给<code>DelegateBridge</code>引用了（通过<code>LUA_REGISTRYINDEX</code>）。所以，这个table以及<code>button(userdata)</code>都无法给GC回收。</p><p>那么现在就形成了一个死结，而这个死结只要有任何一处解开就可以完全解开了，但现在处处都无法解开。</p><h2 id=解决方案>解决方案</h2><h3 id=调用invoke>调用Invoke</h3><p>根据<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>，可以在RemoveAllListener之后，手动调用一次Invoke，这样就可以清除掉<code>Calls</code>。</p><blockquote><p>但此方法有个问题，假设<code>Button</code>在<code>Inspector</code>界面上绑定了持久化事件，就会多触发一次事件，可能会有意想不到的bug出现。<strong>所以不建议使用</strong></p></blockquote><h3 id=反射>反射</h3><p>根据<a href=https://github.com/Tencent/xLua/issues/139>xLua#139</a>，其实可以通过反射去释放掉<code>UnityEvent</code>中的缓存。</p><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp>
<span style=color:#66d9ef>private</span> <span style=color:#66d9ef>static</span> MethodInfo prepareInvoke;

<span style=color:#66d9ef>public</span> <span style=color:#66d9ef>static</span> <span style=color:#66d9ef>void</span> ReleaseUnusedListeners(<span style=color:#66d9ef>this</span> UnityEventBase unityEventBase)
{
    <span style=color:#66d9ef>if</span> (prepareInvoke == <span style=color:#66d9ef>null</span>)
    {
        BindingFlags flag = BindingFlags.Instance | BindingFlags.NonPublic;
        Type type = unityEventBase.GetType();
        prepareInvoke = type.GetMethod(<span style=color:#e6db74>&#34;PrepareInvoke&#34;</span>, flag);
    }

    prepareInvoke.Invoke(unityEventBase, <span style=color:#66d9ef>null</span>);
}

</code></pre></div><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-Lua data-lang=Lua>...
item.button.onClick:RemoveAllListeners()
item.button.onClick:ReleaseUnusedListeners()
</code></pre></div><blockquote><p>笔者在issue基础上进行了优化。
此方案副作用小，只要不忘记调用，就可以释放掉对应事件。笔者也是采用这套方案。
这里要注意的是，如果是采用<code>Generate</code>的方式，需要增加<code>ButtonClickedEvent</code>等参数的接口，不然xlua会找不到方法。</p></blockquote><h3 id=升级版本>升级版本</h3><p>UnityEvent这个内存泄漏的问题，在<code>Unity 2021.2.x</code>版本就已经修复了（吐槽：这个bug在2017年前就已经存在了）。</p><blockquote><p>Scripting: Fixed a memory leak happening when removing listeners from a UnityEvent that is never raised afterwards. <a href=https://issuetracker.unity3d.com/issues/memory-of-non-persistent-event-listeners-isnt-cleared-when-calling-unityeventbase-dot-removealllisteners>(1303095)</a>
所以可以通过升级版进行修复。</p></blockquote><div class=highlight><pre style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-CSharp data-lang=CSharp><span style=color:#66d9ef>public</span> <span style=color:#66d9ef>void</span> RemoveListener(<span style=color:#66d9ef>object</span> targetObj, MethodInfo method)
{
    <span style=color:#66d9ef>var</span> toRemove = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;();
    <span style=color:#66d9ef>for</span> (<span style=color:#66d9ef>int</span> index = <span style=color:#ae81ff>0</span>; index &lt; m_RuntimeCalls.Count; index++)
    {
        <span style=color:#66d9ef>if</span> (m_RuntimeCalls[index].Find(targetObj, method))
            toRemove.Add(m_RuntimeCalls[index]);
    }
    m_RuntimeCalls.RemoveAll(toRemove.Contains);

    <span style=color:#75715e>// removals are done synchronously to avoid leaks
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>var</span> newExecutingCalls = <span style=color:#66d9ef>new</span> List&lt;BaseInvokableCall&gt;(m_PersistentCalls.Count + m_RuntimeCalls.Count);
    newExecutingCalls.AddRange(m_PersistentCalls);
    newExecutingCalls.AddRange(m_RuntimeCalls);
    m_ExecutingCalls = newExecutingCalls;
    m_NeedsUpdate = <span style=color:#66d9ef>false</span>;
}
</code></pre></div></div><footer><div class=stats><ul class=categories><li><a class=article-terms-link href=/categories/unity3d/>Unity3D</a></li></ul><ul class=tags><li><a class=article-terms-link href=/tags/unity3d/>Unity3D</a></li><li><a class=article-terms-link href=/tags/xlua/>xLua</a></li><li><a class=article-terms-link href=/tags/unityevent/>UnityEvent</a></li><li><a class=article-terms-link href=/tags/%e7%96%91%e9%9a%be%e6%9d%82%e7%97%87/>疑难杂症</a></li></ul></div></footer></div><div class=post><div><h2 id=say-something>说些什么</h2><form id=comment-form class=new-comment method=post><h3 class="reply-notice hidden"><span class=reply-name></span><a class="reply-close-btn button"><i class="fas fa-times"></i></a></h3><input type=hidden name=options[entryId] value=dc26db657ec279f90e2556a6970a258e>
<input type=hidden name=fields[replyThread]>
<input type=hidden name=fields[replyID]>
<input type=hidden name=fields[replyName]>
<input required name=fields[name] type=text placeholder=你的名字>
<input name=fields[website] type=text placeholder=你的网页>
<input required name=fields[email] type=email placeholder=你的邮件>
<textarea required name=fields[body] placeholder=你的信息 rows=10></textarea><div class=submit-notice><strong class="submit-notice-text submit-success hidden">感谢你的评论！被批准后它会立即在此站点展示。</strong>
<strong class="submit-notice-text submit-failed hidden">很抱歉，你的提交存在错误。请确保所有必填字段都已填写正确，然后再试一次。</strong></div><button type=button id=comment-form-submit class=button>发送</button>
<button type=button id=comment-form-submitted class="hidden button" disabled>已发送</button>
<button type=reset id=comment-form-reset class=button>重设</button></form></div><div class=comments-container><h2>评论</h2><p>还沒有留言。</p></div></div></article><div class=pagination><a href=/blog/publish/buildios/ class="button left"><span>构建iOS包</span></a>
<a href=/blog/csharp/reflection/ class="button right"><span>C#知识点-反射</span></a></div><div class=toc><aside class=toc-item><nav id=TableOfContents><ul><li><a href=#前言>前言</a></li><li><a href=#问题原因>问题原因</a></li><li><a href=#问题危害>问题危害</a><ul><li><a href=#正常流程>正常流程</a></li><li><a href=#泄漏情况>泄漏情况</a></li></ul></li><li><a href=#解决方案>解决方案</a><ul><li><a href=#调用invoke>调用Invoke</a></li><li><a href=#反射>反射</a></li><li><a href=#升级版本>升级版本</a></li></ul></li></ul></nav></aside></div></main><section id=site-sidebar><section id=recent-posts><header><h1>最新文章</h1></header><article class=mini-post><a href=/blog/xlua/delegatememoryleak/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/xlua/delegatememoryleak/>xlua Delegate 泄漏检查</a></h2><time class=published datetime="2024-02-01 00:00:00 +0000 UTC">February 1, 2024</time></header></article><article class=mini-post><a href=/blog/urp/issue/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/urp/issue/>Unity URP issue</a></h2><time class=published datetime="2024-01-10 00:00:00 +0000 UTC">January 10, 2024</time></header></article><article class=mini-post><a href=/blog/shader/hlsl/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/shader/hlsl/>HLSL</a></h2><time class=published datetime="2023-02-08 00:00:00 +0000 UTC">February 8, 2023</time></header></article><article class=mini-post><a href=/blog/plugin/yooasset/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/plugin/yooasset/>YooAsset插件</a></h2><time class=published datetime="2023-01-11 00:00:00 +0000 UTC">January 11, 2023</time></header></article><article class=mini-post><a href=/blog/publish/buildios/ class=image style="--bg-image: url('https://l-lawliet.github.io/img/2021/09/title/01.jpg')"><img class=stretchH src=https://l-lawliet.github.io/img/2021/09/title/01.jpg alt=Colourful></a><header><h2><a href=/blog/publish/buildios/>构建iOS包</a></h2><time class=published datetime="2022-12-28 00:00:00 +0000 UTC">December 28, 2022</time></header></article><footer><a href=/blog class=button>查看更多</a></footer></section><section id=categories><header><h1><a href=/categories>分类</a></h1></header><ul><li><a href=/categories/shader/>shader<span class=count>3</span></a><li><a href=/categories/srp/>srp<span class=count>2</span></a><li><a href=/categories/unity3d/>unity3d<span class=count>2</span></a><li><a href=/categories/urp/>urp<span class=count>2</span></a><li><a href=/categories/c/>c#<span class=count>1</span></a><li><a href=/categories/git/>git<span class=count>1</span></a><li><a href=/categories/hlsl/>hlsl<span class=count>1</span></a><li><a href=/categories/hugo/>hugo<span class=count>1</span></a><li><a href=/categories/issue/>issue<span class=count>1</span></a><li><a href=/categories/publish/>publish<span class=count>1</span></a><li><a href=/categories/xlua/>xlua<span class=count>1</span></a></li></ul></section><section id=mini-bio><header><h1>关于</h1></header><p>记录游戏开发的点点滴滴</p><footer><a href=/about class=button>详细了解</a></footer></section></section><footer id=site-footer><ul class=socnet-icons><li><a href=//github.com/L-Lawliet target=_blank rel=noopener title=GitHub class="fab fa-github"></a></li><li><a href=//www.zhihu.com/column/UnityDiary target=_blank rel=noopener title=mastodon class="fab fa-zhihu"></a></li><li><a href=mailto:2771918131@qq.com target=_blank title=Email class="far fa-envelope"></a></li></ul><p class=copyright>© 2024 L-Lawliet's Blog<br>主题: <a href=https://themes.gohugo.io/hugo-future-imperfect-slim/ target=_blank rel=noopener>Hugo Future Imperfect Slim</a><br>移植自 <a href=https://html5up.net/future-imperfect target=_blank rel=noopener>HTML5 UP</a> | 由 <a href=https://gohugo.io/ target=_blank rel=noopener title=0.74.2>Hugo</a> 驱动</p></footer><div id=back-to-top><a href=# class="fas fa-arrow-up fa-2x" style=margin:.3em></a></div><script src=/js/highlight.js></script><script>hljs.highlightAll();</script><script src=/js/bundle.min.c624e9a3ea22e2ef195a87bc45323129218c54ad08ea4847dd758846836744d1.js integrity="sha256-xiTpo+oi4u8ZWoe8RTIxKSGMVK0I6khH3XWIRoNnRNE="></script><script src=/js/add-on.js></script></div></body></html>